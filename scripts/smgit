#!/usr/bin/perl
my $help = <<EOF;
Mostly like plain old git, except recurses into one level of submodules.

There's not really anything magic about this script. For the most part,
it just executes the given command in each submodule directory and then
in the top-level ROSE repository. It can be invoked from any directory
under ROSE (either in the ROSE repository or one of the submodules).

SPECIAL COMMANDS

A few git commands get special handling by this script in order to
restrict their functionality or to extend it to do something more
useful in an environment with submodules.

   clone        After cloning the main repository, it initializes
                submodules, gives the user a chance to change
                their URLs (if the --edit switch is given), and
                then updates the submodules.

                These switches are supported: --edit (not a Git
                switch, but controls whether the user is given
                a chance to modify submodule URLs), --quiet,
                --verbose, --no-hardlinks, --branch, --templates,
                and --upload-pack.

                The following switches don't make sense in this
                environment: --shared, --reference, --no-checkout,
                --bare, --mirror, --origin, --depth.  The switch
                --recursive is not accepted since the behavior is
                to always recurse into submodules.

   checkout     Checks out the specified branch (after optionally
                creating it) in the main repo and then updates all
                submodules. Furthermore, if a submodule has a
                suitable branch, that branch will be checked out in
                the submodule. See CHOOSING SUBMODULE BRANCHES for
                details.

                These switches are supported: --quiet, -b, --track,
                --no-track, and -l.

                The following switches don't make sense in this
                environment: --force, --ours, --theirs, --merge,
                --conflict, and --patch.

   branch       Lists, creates, deletes or renames branches in the
                main repository and all submodules.  When creating
                a new branch the specified branch head (if any)
                is the one defined in the main ROSE repository. The
                head of the new branch in the submodules will be
                chosen according to the commit registered in the
                branch head of the main ROSE repository.  In other
                words, in the main repository "newbranch" will
                point to the same commit as "base", while in the
                submodule, "newbranch" will be created to point to
                the commit that is referenced by the submodule
                directory in the "base" commit of the main repository.

                   $ smgit branch newbranch base

                All git-branch switches are supported, namely: -d, -D,
                -l, -f, -m, -M, --color, -r, -a, --verbose, --abbrev,
                --track, --contains, --merged, and --no-merged.

   commit       Commits changes that are staged for committal, first
                in the submodules and then in the main repository,
                using a single commit message.

                These switches are supported: --all, --reuse-message,
                --reedit-message, --reset-author, --file, --author,
                --message, --templates, --signoff, --no-verify,
                --cleanup, --edit, --untracked-files, --verbose,
                and --quiet.

                These switches are not supported since they either
                don't make sense in this environment or are difficult
                to implement: --allow-empty, --amend, and --dry-run.

   merge        Merges one branch into another by first merging in
                the main repository (ignoring conflicts for the time
                being), then merging in the submodules, then adding
                new submodule versions to the main repository, then
                committing the changes in the main repository if
                necessary and possible.

                These switches are supported to varying degrees: --ff,
                --no-ff, --log, --no-log, --stat, --no-stat, -n,
                --ff-only, --quiet, --verbose, and -m.

                These switches are not supported: --commit, --no-commit,
                --squash and --no-squash. The default is that merges are
                always committed.

   push         Pushes in the submodules, but uses the submodule
                source ref that corresponds to the ref that would be
                checked out in the submodule by "smgit checkout" of
                that ref in the parent.  In other words, a command like
                  git push origin bugfix:matzke/bugfix-rc
                runs as in in the root module, but in the submodule
                "bugfix" is replaced by the commit that would be
                checked out in the submodule after doing an
                "smgit checkout bugfix" (the checkout doesn't
                actually occur though).

   debug        Prints some information about the repository that is
                useful for debugging problems with smgit.

CHOOSING SUBMODULE BRANCHES

When a branch is checked out in the main repository, we update the
submodules so their heads are pointing to the commit specified in the
main repository.  Furthermore, if a submodule has a suitable branch,
we check out that branch in the submodule rather than leaving the head
in a detached state.  If the parent's branch name is B and the parent
is pointing to submodule commit C, then here's how the branch is
chosen in a submodule:

   1. If the submodule has a branch named B that is pointing to
      commit C, then we check out branch B.

   2. Otherwise, if the submodule has a branch named origin/B
      that points to commit C, we do one of the following if
      their preconditions are met:

         A. If the submodule has no branch named B then
            branch B is created as a tracking branch of
            origin/B and is checked out.

         B. If branch B exists and can be fast forwarded to
            origin/B then we check out B and fast forward
            to origin/B.

   3. Otherwise, if the submodule has any local or remote branch
      that points to commit C we arbitrarily choose one.  If the
      chosen branch is a local branch we use case 1 above, otherwise
      we use case 2 above.

   4. Otherwise, the head of the submodule remains in a detached
      state.

OTHER COMMANDS

All other commands are identical to Git and are executed first in
the submodules and then in the main ROSE repository.

These global switches are not supported:
EOF
$help =~ s/\n$//s;

###############################################################################################################################
# Getopt::Long.pm inserted here to keep this script as easy to install as possible.  We don't want the user to have to install
# it before being able to run smgit.  And we can't include it along side smgit because perl might be running smgit from stdin.
#
# Search for "END OF" to find the end of Getopt::Long and the beginning of the smgit script itself.
###############################################################################################################################

# Getopt::Long.pm -- Universal options parsing

package Getopt::Long;

# RCS Status      : $Id: Long.pm,v 2.74 2007/09/29 13:40:13 jv Exp $
# Author          : Johan Vromans
# Created On      : Tue Sep 11 15:00:12 1990
# Last Modified By: Johan Vromans
# Last Modified On: Sat Sep 29 15:38:55 2007
# Update Count    : 1571
# Status          : Released

################ Copyright ################

# This program is Copyright 1990,2007 by Johan Vromans.
# This program is free software; you can redistribute it and/or
# modify it under the terms of the Perl Artistic License or the
# GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# If you do not have a copy of the GNU General Public License write to
# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
# MA 02139, USA.

################ Module Preamble ################

use 5.004;

use strict;

use vars qw($VERSION);
$VERSION        =  2.37;
# For testing versions only.
use vars qw($VERSION_STRING);
$VERSION_STRING = "2.37";

use Exporter;
use vars qw(@ISA @EXPORT @EXPORT_OK);
@ISA = qw(Exporter);

# Exported subroutines.
sub GetOptions(@);		# always
sub GetOptionsFromArray($@);	# on demand
sub GetOptionsFromString($@);	# on demand
sub Configure(@);		# on demand
sub HelpMessage(@);		# on demand
sub VersionMessage(@);		# in demand

BEGIN {
    # Init immediately so their contents can be used in the 'use vars' below.
    @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
    @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
		    &GetOptionsFromArray &GetOptionsFromString);
}

# User visible variables.
use vars @EXPORT, @EXPORT_OK;
use vars qw($error $debug $major_version $minor_version);
# Deprecated visible variables.
use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
	    $passthrough);
# Official invisible variables.
use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);

# Public subroutines.
sub config(@);			# deprecated name

# Private subroutines.
sub ConfigDefaults();
sub ParseOptionSpec($$);
sub OptCtl($);
sub FindOption($$$$$);
sub ValidValue ($$$$$);

################ Local Variables ################

# $requested_version holds the version that was mentioned in the 'use'
# or 'require', if any. It can be used to enable or disable specific
# features.
my $requested_version = 0;

################ Resident subroutines ################

sub ConfigDefaults() {
    # Handle POSIX compliancy.
    if ( defined $ENV{"POSIXLY_CORRECT"} ) {
	$genprefix = "(--|-)";
	$autoabbrev = 0;		# no automatic abbrev of options
	$bundling = 0;			# no bundling of single letter switches
	$getopt_compat = 0;		# disallow '+' to start options
	$order = $REQUIRE_ORDER;
    }
    else {
	$genprefix = "(--|-|\\+)";
	$autoabbrev = 1;		# automatic abbrev of options
	$bundling = 0;			# bundling off by default
	$getopt_compat = 1;		# allow '+' to start options
	$order = $PERMUTE;
    }
    # Other configurable settings.
    $debug = 0;			# for debugging
    $error = 0;			# error tally
    $ignorecase = 1;		# ignore case when matching options
    $passthrough = 0;		# leave unrecognized options alone
    $gnu_compat = 0;		# require --opt=val if value is optional
    $longprefix = "(--)";       # what does a long prefix look like
}

# Override import.
sub import {
    my $pkg = shift;		# package
    my @syms = ();		# symbols to import
    my @config = ();		# configuration
    my $dest = \@syms;		# symbols first
    for ( @_ ) {
	if ( $_ eq ':config' ) {
	    $dest = \@config;	# config next
	    next;
	}
	push(@$dest, $_);	# push
    }
    # Hide one level and call super.
    local $Exporter::ExportLevel = 1;
    push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
    $pkg->SUPER::import(@syms);
    # And configure.
    Configure(@config) if @config;
}

################ Initialization ################

# Values for $order. See GNU getopt.c for details.
($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
# Version major/minor numbers.
($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;

ConfigDefaults();

################ OO Interface ################

package Getopt::Long::Parser;

# Store a copy of the default configuration. Since ConfigDefaults has
# just been called, what we get from Configure is the default.
my $default_config = do {
    Getopt::Long::Configure ()
};

sub new {
    my $that = shift;
    my $class = ref($that) || $that;
    my %atts = @_;

    # Register the callers package.
    my $self = { caller_pkg => (caller)[0] };

    bless ($self, $class);

    # Process config attributes.
    if ( defined $atts{config} ) {
	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
	$self->{settings} = Getopt::Long::Configure ($save);
	delete ($atts{config});
    }
    # Else use default config.
    else {
	$self->{settings} = $default_config;
    }

    if ( %atts ) {		# Oops
	die(__PACKAGE__.": unhandled attributes: ".
	    join(" ", sort(keys(%atts)))."\n");
    }

    $self;
}

sub configure {
    my ($self) = shift;

    # Restore settings, merge new settings in.
    my $save = Getopt::Long::Configure ($self->{settings}, @_);

    # Restore orig config and save the new config.
    $self->{settings} = Getopt::Long::Configure ($save);
}

sub getoptions {
    my ($self) = shift;

    # Restore config settings.
    my $save = Getopt::Long::Configure ($self->{settings});

    # Call main routine.
    my $ret = 0;
    $Getopt::Long::caller = $self->{caller_pkg};

    eval {
	# Locally set exception handler to default, otherwise it will
	# be called implicitly here, and again explicitly when we try
	# to deliver the messages.
	local ($SIG{__DIE__}) = '__DEFAULT__';
	$ret = Getopt::Long::GetOptions (@_);
    };

    # Restore saved settings.
    Getopt::Long::Configure ($save);

    # Handle errors and return value.
    die ($@) if $@;
    return $ret;
}

package Getopt::Long;

################ Back to Normal ################

# Indices in option control info.
# Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
use constant CTL_TYPE    => 0;
#use constant   CTL_TYPE_FLAG   => '';
#use constant   CTL_TYPE_NEG    => '!';
#use constant   CTL_TYPE_INCR   => '+';
#use constant   CTL_TYPE_INT    => 'i';
#use constant   CTL_TYPE_INTINC => 'I';
#use constant   CTL_TYPE_XINT   => 'o';
#use constant   CTL_TYPE_FLOAT  => 'f';
#use constant   CTL_TYPE_STRING => 's';

use constant CTL_CNAME   => 1;

use constant CTL_DEFAULT => 2;

use constant CTL_DEST    => 3;
 use constant   CTL_DEST_SCALAR => 0;
 use constant   CTL_DEST_ARRAY  => 1;
 use constant   CTL_DEST_HASH   => 2;
 use constant   CTL_DEST_CODE   => 3;

use constant CTL_AMIN    => 4;
use constant CTL_AMAX    => 5;

# FFU.
#use constant CTL_RANGE   => ;
#use constant CTL_REPEAT  => ;

# Rather liberal patterns to match numbers.
use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
use constant PAT_XINT  =>
  "(?:".
	  "[-+]?_*[1-9][0-9_]*".
  "|".
	  "0x_*[0-9a-f][0-9a-f_]*".
  "|".
	  "0b_*[01][01_]*".
  "|".
	  "0[0-7_]*".
  ")";
use constant PAT_FLOAT => "[-+]?[0-9._]+(\.[0-9_]+)?([eE][-+]?[0-9_]+)?";

sub GetOptions(@) {
    # Shift in default array.
    unshift(@_, \@ARGV);
    # Try to keep caller() and Carp consitent.
    goto &GetOptionsFromArray;
}

sub GetOptionsFromString($@) {
    my ($string) = shift;
    require Text::ParseWords;
    my $args = [ Text::ParseWords::shellwords($string) ];
    $caller ||= (caller)[0];	# current context
    my $ret = GetOptionsFromArray($args, @_);
    return ( $ret, $args ) if wantarray;
    if ( @$args ) {
	$ret = 0;
	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
    }
    $ret;
}

sub GetOptionsFromArray($@) {

    my ($argv, @optionlist) = @_;	# local copy of the option descriptions
    my $argend = '--';		# option list terminator
    my %opctl = ();		# table of option specs
    my $pkg = $caller || (caller)[0];	# current context
				# Needed if linkage is omitted.
    my @ret = ();		# accum for non-options
    my %linkage;		# linkage
    my $userlinkage;		# user supplied HASH
    my $opt;			# current option
    my $prefix = $genprefix;	# current prefix

    $error = '';

    if ( $debug ) {
	# Avoid some warnings if debugging.
	local ($^W) = 0;
	print STDERR
	  ("Getopt::Long $Getopt::Long::VERSION (",
	   '$Revision: 2.74 $', ") ",
	   "called from package \"$pkg\".",
	   "\n  ",
	   "argv: (@$argv)",
	   "\n  ",
	   "autoabbrev=$autoabbrev,".
	   "bundling=$bundling,",
	   "getopt_compat=$getopt_compat,",
	   "gnu_compat=$gnu_compat,",
	   "order=$order,",
	   "\n  ",
	   "ignorecase=$ignorecase,",
	   "requested_version=$requested_version,",
	   "passthrough=$passthrough,",
	   "genprefix=\"$genprefix\",",
	   "longprefix=\"$longprefix\".",
	   "\n");
    }

    # Check for ref HASH as first argument.
    # First argument may be an object. It's OK to use this as long
    # as it is really a hash underneath.
    $userlinkage = undef;
    if ( @optionlist && ref($optionlist[0]) and
	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
	$userlinkage = shift (@optionlist);
	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
    }

    # See if the first element of the optionlist contains option
    # starter characters.
    # Be careful not to interpret '<>' as option starters.
    if ( @optionlist && $optionlist[0] =~ /^\W+$/
	 && !($optionlist[0] eq '<>'
	      && @optionlist > 0
	      && ref($optionlist[1])) ) {
	$prefix = shift (@optionlist);
	# Turn into regexp. Needs to be parenthesized!
	$prefix =~ s/(\W)/\\$1/g;
	$prefix = "([" . $prefix . "])";
	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
    }

    # Verify correctness of optionlist.
    %opctl = ();
    while ( @optionlist ) {
	my $opt = shift (@optionlist);

	unless ( defined($opt) ) {
	    $error .= "Undefined argument in option spec\n";
	    next;
	}

	# Strip leading prefix so people can specify "--foo=i" if they like.
	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;

	if ( $opt eq '<>' ) {
	    if ( (defined $userlinkage)
		&& !(@optionlist > 0 && ref($optionlist[0]))
		&& (exists $userlinkage->{$opt})
		&& ref($userlinkage->{$opt}) ) {
		unshift (@optionlist, $userlinkage->{$opt});
	    }
	    unless ( @optionlist > 0
		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
		$error .= "Option spec <> requires a reference to a subroutine\n";
		# Kill the linkage (to avoid another error).
		shift (@optionlist)
		  if @optionlist && ref($optionlist[0]);
		next;
	    }
	    $linkage{'<>'} = shift (@optionlist);
	    next;
	}

	# Parse option spec.
	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
	unless ( defined $name ) {
	    # Failed. $orig contains the error message. Sorry for the abuse.
	    $error .= $orig;
	    # Kill the linkage (to avoid another error).
	    shift (@optionlist)
	      if @optionlist && ref($optionlist[0]);
	    next;
	}

	# If no linkage is supplied in the @optionlist, copy it from
	# the userlinkage if available.
	if ( defined $userlinkage ) {
	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
		if ( exists $userlinkage->{$orig} &&
		     ref($userlinkage->{$orig}) ) {
		    print STDERR ("=> found userlinkage for \"$orig\": ",
				  "$userlinkage->{$orig}\n")
			if $debug;
		    unshift (@optionlist, $userlinkage->{$orig});
		}
		else {
		    # Do nothing. Being undefined will be handled later.
		    next;
		}
	    }
	}

	# Copy the linkage. If omitted, link to global variable.
	if ( @optionlist > 0 && ref($optionlist[0]) ) {
	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
		if $debug;
	    my $rl = ref($linkage{$orig} = shift (@optionlist));

	    if ( $rl eq "ARRAY" ) {
		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
	    }
	    elsif ( $rl eq "HASH" ) {
		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
	    }
	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
#		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
#		    my $t = $linkage{$orig};
#		    $$t = $linkage{$orig} = [];
#		}
#		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
#		}
#		else {
		    # Ok.
#		}
	    }
	    elsif ( $rl eq "CODE" ) {
		# Ok.
	    }
	    else {
		$error .= "Invalid option linkage for \"$opt\"\n";
	    }
	}
	else {
	    # Link to global $opt_XXX variable.
	    # Make sure a valid perl identifier results.
	    my $ov = $orig;
	    $ov =~ s/\W/_/g;
	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
		    if $debug;
		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
	    }
	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
		    if $debug;
		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
	    }
	    else {
		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
		    if $debug;
		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
	    }
	}
    }

    # Bail out if errors found.
    die ($error) if $error;
    $error = 0;

    # Supply --version and --help support, if needed and allowed.
    if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
	if ( !defined($opctl{version}) ) {
	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
	    $linkage{version} = \&VersionMessage;
	}
	$auto_version = 1;
    }
    if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
	    $linkage{help} = \&HelpMessage;
	}
	$auto_help = 1;
    }

    # Show the options tables if debugging.
    if ( $debug ) {
	my ($arrow, $k, $v);
	$arrow = "=> ";
	while ( ($k,$v) = each(%opctl) ) {
	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
	    $arrow = "   ";
	}
    }

    # Process argument list
    my $goon = 1;
    while ( $goon && @$argv > 0 ) {

	# Get next argument.
	$opt = shift (@$argv);
	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;

	# Double dash is option list terminator.
	if ( $opt eq $argend ) {
	  push (@ret, $argend) if $passthrough;
	  last;
	}

	# Look it up.
	my $tryopt = $opt;
	my $found;		# success status
	my $key;		# key (if hash type)
	my $arg;		# option argument
	my $ctl;		# the opctl entry

	($found, $opt, $ctl, $arg, $key) =
	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);

	if ( $found ) {

	    # FindOption undefines $opt in case of errors.
	    next unless defined $opt;

	    my $argcnt = 0;
	    while ( defined $arg ) {

		# Get the canonical name.
		print STDERR ("=> cname for \"$opt\" is ") if $debug;
		$opt = $ctl->[CTL_CNAME];
		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;

		if ( defined $linkage{$opt} ) {
		    print STDERR ("=> ref(\$L{$opt}) -> ",
				  ref($linkage{$opt}), "\n") if $debug;

		    if ( ref($linkage{$opt}) eq 'SCALAR'
			 || ref($linkage{$opt}) eq 'REF' ) {
			if ( $ctl->[CTL_TYPE] eq '+' ) {
			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
			      if $debug;
			    if ( defined ${$linkage{$opt}} ) {
			        ${$linkage{$opt}} += $arg;
			    }
		            else {
			        ${$linkage{$opt}} = $arg;
			    }
			}
			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
					  " to ARRAY\n")
			      if $debug;
			    my $t = $linkage{$opt};
			    $$t = $linkage{$opt} = [];
			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
			      if $debug;
			    push (@{$linkage{$opt}}, $arg);
			}
			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
					  " to HASH\n")
			      if $debug;
			    my $t = $linkage{$opt};
			    $$t = $linkage{$opt} = {};
			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
			      if $debug;
			    $linkage{$opt}->{$key} = $arg;
			}
			else {
			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
			      if $debug;
			    ${$linkage{$opt}} = $arg;
		        }
		    }
		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
			    if $debug;
			push (@{$linkage{$opt}}, $arg);
		    }
		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
			    if $debug;
			$linkage{$opt}->{$key} = $arg;
		    }
		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
			print STDERR ("=> &L{$opt}(\"$opt\"",
				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
				      ", \"$arg\")\n")
			    if $debug;
			my $eval_error = do {
			    local $@;
			    local $SIG{__DIE__}  = '__DEFAULT__';
			    eval {
				&{$linkage{$opt}}
				  (Getopt::Long::CallBack->new
				   (name    => $opt,
				    ctl     => $ctl,
				    opctl   => \%opctl,
				    linkage => \%linkage,
				    prefix  => $prefix,
				   ),
				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
				   $arg);
			    };
			    $@;
			};
			print STDERR ("=> die($eval_error)\n")
			  if $debug && $eval_error ne '';
			if ( $eval_error =~ /^!/ ) {
			    if ( $eval_error =~ /^!FINISH\b/ ) {
				$goon = 0;
			    }
			}
			elsif ( $eval_error ne '' ) {
			    warn ($eval_error);
			    $error++;
			}
		    }
		    else {
			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
				      "\" in linkage\n");
			die("Getopt::Long -- internal error!\n");
		    }
		}
		# No entry in linkage means entry in userlinkage.
		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
		    if ( defined $userlinkage->{$opt} ) {
			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
			    if $debug;
			push (@{$userlinkage->{$opt}}, $arg);
		    }
		    else {
			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
			    if $debug;
			$userlinkage->{$opt} = [$arg];
		    }
		}
		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
		    if ( defined $userlinkage->{$opt} ) {
			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
			    if $debug;
			$userlinkage->{$opt}->{$key} = $arg;
		    }
		    else {
			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
			    if $debug;
			$userlinkage->{$opt} = {$key => $arg};
		    }
		}
		else {
		    if ( $ctl->[CTL_TYPE] eq '+' ) {
			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
			  if $debug;
			if ( defined $userlinkage->{$opt} ) {
			    $userlinkage->{$opt} += $arg;
			}
			else {
			    $userlinkage->{$opt} = $arg;
			}
		    }
		    else {
			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
			$userlinkage->{$opt} = $arg;
		    }
		}

		$argcnt++;
		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
		undef($arg);

		# Need more args?
		if ( $argcnt < $ctl->[CTL_AMIN] ) {
		    if ( @$argv ) {
			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
			    $arg = shift(@$argv);
			    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
			    next;
			}
			warn("Value \"$$argv[0]\" invalid for option $opt\n");
			$error++;
		    }
		    else {
			warn("Insufficient arguments for option $opt\n");
			$error++;
		    }
		}

		# Any more args?
		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
		    $arg = shift(@$argv);
		    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
		    next;
		}
	    }
	}

	# Not an option. Save it if we $PERMUTE and don't have a <>.
	elsif ( $order == $PERMUTE ) {
	    # Try non-options call-back.
	    my $cb;
	    if ( (defined ($cb = $linkage{'<>'})) ) {
		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
		  if $debug;
		my $eval_error = do {
		    local $@;
		    local $SIG{__DIE__}  = '__DEFAULT__';
		    eval { &$cb ($tryopt) };
		    $@;
		};
		print STDERR ("=> die($eval_error)\n")
		  if $debug && $eval_error ne '';
		if ( $eval_error =~ /^!/ ) {
		    if ( $eval_error =~ /^!FINISH\b/ ) {
			$goon = 0;
		    }
		}
		elsif ( $eval_error ne '' ) {
		    warn ($eval_error);
		    $error++;
		}
	    }
	    else {
		print STDERR ("=> saving \"$tryopt\" ",
			      "(not an option, may permute)\n") if $debug;
		push (@ret, $tryopt);
	    }
	    next;
	}

	# ...otherwise, terminate.
	else {
	    # Push this one back and exit.
	    unshift (@$argv, $tryopt);
	    return ($error == 0);
	}

    }

    # Finish.
    if ( @ret && $order == $PERMUTE ) {
	#  Push back accumulated arguments
	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
	    if $debug;
	unshift (@$argv, @ret);
    }

    return ($error == 0);
}

# A readable representation of what's in an optbl.
sub OptCtl ($) {
    my ($v) = @_;
    my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
    "[".
      join(",",
	   "\"$v[CTL_TYPE]\"",
	   "\"$v[CTL_CNAME]\"",
	   "\"$v[CTL_DEFAULT]\"",
	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
	   $v[CTL_AMIN] || '',
	   $v[CTL_AMAX] || '',
#	   $v[CTL_RANGE] || '',
#	   $v[CTL_REPEAT] || '',
	  ). "]";
}

# Parse an option specification and fill the tables.
sub ParseOptionSpec ($$) {
    my ($opt, $opctl) = @_;

    # Match option spec.
    if ( $opt !~ m;^
		   (
		     # Option name
		     (?: \w+[-\w]* )
		     # Alias names, or "?"
		     (?: \| (?: \? | \w[-\w]* )? )*
		   )?
		   (
		     # Either modifiers ...
		     [!+]
		     |
		     # ... or a value/dest/repeat specification
		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
		     |
		     # ... or an optional-with-default spec
		     : (?: -?\d+ | \+ ) [@%]?
		   )?
		   $;x ) {
	return (undef, "Error in option spec: \"$opt\"\n");
    }

    my ($names, $spec) = ($1, $2);
    $spec = '' unless defined $spec;

    # $orig keeps track of the primary name the user specified.
    # This name will be used for the internal or external linkage.
    # In other words, if the user specifies "FoO|BaR", it will
    # match any case combinations of 'foo' and 'bar', but if a global
    # variable needs to be set, it will be $opt_FoO in the exact case
    # as specified.
    my $orig;

    my @names;
    if ( defined $names ) {
	@names =  split (/\|/, $names);
	$orig = $names[0];
    }
    else {
	@names = ('');
	$orig = '';
    }

    # Construct the opctl entries.
    my $entry;
    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
	# Fields are hard-wired here.
	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
    }
    elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
	my $def = $1;
	my $dest = $2;
	my $type = $def eq '+' ? 'I' : 'i';
	$dest ||= '$';
	$dest = $dest eq '@' ? CTL_DEST_ARRAY
	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
	# Fields are hard-wired here.
	$entry = [$type,$orig,$def eq '+' ? undef : $def,
		  $dest,0,1];
    }
    else {
	my ($mand, $type, $dest) =
	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
	  if $bundling && defined($4);
	my ($mi, $cm, $ma) = ($5, $6, $7);
	return (undef, "{0} is useless in option spec: \"$opt\"\n")
	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);

	$type = 'i' if $type eq 'n';
	$dest ||= '$';
	$dest = $dest eq '@' ? CTL_DEST_ARRAY
	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
	# Default minargs to 1/0 depending on mand status.
	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
	# Adjust mand status according to minargs.
	$mand = $mi ? '=' : ':';
	# Adjust maxargs.
	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
	  if defined($ma) && !$ma;
	return (undef, "Max less than min in option spec: \"$opt\"\n")
	  if defined($ma) && $ma < $mi;

	# Fields are hard-wired here.
	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
    }

    # Process all names. First is canonical, the rest are aliases.
    my $dups = '';
    foreach ( @names ) {

	$_ = lc ($_)
	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);

	if ( exists $opctl->{$_} ) {
	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
	}

	if ( $spec eq '!' ) {
	    $opctl->{"no$_"} = $entry;
	    $opctl->{"no-$_"} = $entry;
	    $opctl->{$_} = [@$entry];
	    $opctl->{$_}->[CTL_TYPE] = '';
	}
	else {
	    $opctl->{$_} = $entry;
	}
    }

    if ( $dups && $^W ) {
	foreach ( split(/\n+/, $dups) ) {
	    warn($_."\n");
	}
    }
    ($names[0], $orig);
}

# Option lookup.
sub FindOption ($$$$$) {

    # returns (1, $opt, $ctl, $arg, $key) if okay,
    # returns (1, undef) if option in error,
    # returns (0) otherwise.

    my ($argv, $prefix, $argend, $opt, $opctl) = @_;

    print STDERR ("=> find \"$opt\"\n") if $debug;

    return (0) unless $opt =~ /^$prefix(.*)$/s;
    return (0) if $opt eq "-" && !defined $opctl->{''};

    $opt = $+;
    my $starter = $1;

    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;

    my $optarg;			# value supplied with --opt=value
    my $rest;			# remainder from unbundling

    # If it is a long option, it may include the value.
    # With getopt_compat, only if not bundling.
    if ( ($starter=~/^$longprefix$/
          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
	  && $opt =~ /^([^=]+)=(.*)$/s ) {
	$opt = $1;
	$optarg = $2;
	print STDERR ("=> option \"", $opt,
		      "\", optarg = \"$optarg\"\n") if $debug;
    }

    #### Look it up ###

    my $tryopt = $opt;		# option to try

    if ( $bundling && $starter eq '-' ) {

	# To try overrides, obey case ignore.
	$tryopt = $ignorecase ? lc($opt) : $opt;

	# If bundling == 2, long options can override bundles.
	if ( $bundling == 2 && length($tryopt) > 1
	     && defined ($opctl->{$tryopt}) ) {
	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
	      if $debug;
	}
	else {
	    $tryopt = $opt;
	    # Unbundle single letter option.
	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
	    $tryopt = substr ($tryopt, 0, 1);
	    $tryopt = lc ($tryopt) if $ignorecase > 1;
	    print STDERR ("=> $starter$tryopt unbundled from ",
			  "$starter$tryopt$rest\n") if $debug;
	    $rest = undef unless $rest ne '';
	}
    }

    # Try auto-abbreviation.
    elsif ( $autoabbrev ) {
	# Sort the possible long option names.
	my @names = sort(keys (%$opctl));
	# Downcase if allowed.
	$opt = lc ($opt) if $ignorecase;
	$tryopt = $opt;
	# Turn option name into pattern.
	my $pat = quotemeta ($opt);
	# Look up in option names.
	my @hits = grep (/^$pat/, @names);
	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
		      "out of ", scalar(@names), "\n") if $debug;

	# Check for ambiguous results.
	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
	    # See if all matches are for the same option.
	    my %hit;
	    foreach ( @hits ) {
		my $hit = $_;
		$hit = $opctl->{$hit}->[CTL_CNAME]
		  if defined $opctl->{$hit}->[CTL_CNAME];
		$hit{$hit} = 1;
	    }
	    # Remove auto-supplied options (version, help).
	    if ( keys(%hit) == 2 ) {
		if ( $auto_version && exists($hit{version}) ) {
		    delete $hit{version};
		}
		elsif ( $auto_help && exists($hit{help}) ) {
		    delete $hit{help};
		}
	    }
	    # Now see if it really is ambiguous.
	    unless ( keys(%hit) == 1 ) {
		return (0) if $passthrough;
		warn ("Option ", $opt, " is ambiguous (",
		      join(", ", @hits), ")\n");
		$error++;
		return (1, undef);
	    }
	    @hits = keys(%hit);
	}

	# Complete the option name, if appropriate.
	if ( @hits == 1 && $hits[0] ne $opt ) {
	    $tryopt = $hits[0];
	    $tryopt = lc ($tryopt) if $ignorecase;
	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
		if $debug;
	}
    }

    # Map to all lowercase if ignoring case.
    elsif ( $ignorecase ) {
	$tryopt = lc ($opt);
    }

    # Check validity by fetching the info.
    my $ctl = $opctl->{$tryopt};
    unless  ( defined $ctl ) {
	return (0) if $passthrough;
	# Pretend one char when bundling.
	if ( $bundling == 1 && length($starter) == 1 ) {
	    $opt = substr($opt,0,1);
            unshift (@$argv, $starter.$rest) if defined $rest;
	}
	warn ("Unknown option: ", $opt, "\n");
	$error++;
	return (1, undef);
    }
    # Apparently valid.
    $opt = $tryopt;
    print STDERR ("=> found ", OptCtl($ctl),
		  " for \"", $opt, "\"\n") if $debug;

    #### Determine argument status ####

    # If it is an option w/o argument, we're almost finished with it.
    my $type = $ctl->[CTL_TYPE];
    my $arg;

    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
	if ( defined $optarg ) {
	    return (0) if $passthrough;
	    warn ("Option ", $opt, " does not take an argument\n");
	    $error++;
	    undef $opt;
	}
	elsif ( $type eq '' || $type eq '+' ) {
	    # Supply explicit value.
	    $arg = 1;
	}
	else {
	    $opt =~ s/^no-?//i;	# strip NO prefix
	    $arg = 0;		# supply explicit value
	}
	unshift (@$argv, $starter.$rest) if defined $rest;
	return (1, $opt, $ctl, $arg);
    }

    # Get mandatory status and type info.
    my $mand = $ctl->[CTL_AMIN];

    # Check if there is an option argument available.
    if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
	return (1, $opt, $ctl, $type eq 's' ? '' : 0) ;#unless $mand;
	$optarg = 0 unless $type eq 's';
    }

    # Check if there is an option argument available.
    if ( defined $optarg
	 ? ($optarg eq '')
	 : !(defined $rest || @$argv > 0) ) {
	# Complain if this option needs an argument.
#	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
	if ( $mand ) {
	    return (0) if $passthrough;
	    warn ("Option ", $opt, " requires an argument\n");
	    $error++;
	    return (1, undef);
	}
	if ( $type eq 'I' ) {
	    # Fake incremental type.
	    my @c = @$ctl;
	    $c[CTL_TYPE] = '+';
	    return (1, $opt, \@c, 1);
	}
	return (1, $opt, $ctl,
		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
		$type eq 's' ? '' : 0);
    }

    # Get (possibly optional) argument.
    $arg = (defined $rest ? $rest
	    : (defined $optarg ? $optarg : shift (@$argv)));

    # Get key if this is a "name=value" pair for a hash option.
    my $key;
    if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
	     ($mand ? undef : ($type eq 's' ? "" : 1)));
	if (! defined $arg) {
	    warn ("Option $opt, key \"$key\", requires a value\n");
	    $error++;
	    # Push back.
	    unshift (@$argv, $starter.$rest) if defined $rest;
	    return (1, undef);
	}
    }

    #### Check if the argument is valid for this option ####

    my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";

    if ( $type eq 's' ) {	# string
	# A mandatory string takes anything.
	return (1, $opt, $ctl, $arg, $key) if $mand;

	# Same for optional string as a hash value
	return (1, $opt, $ctl, $arg, $key)
	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;

	# An optional string takes almost anything.
	return (1, $opt, $ctl, $arg, $key)
	  if defined $optarg || defined $rest;
	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??

	# Check for option or option list terminator.
	if ($arg eq $argend ||
	    $arg =~ /^$prefix.+/) {
	    # Push back.
	    unshift (@$argv, $arg);
	    # Supply empty value.
	    $arg = '';
	}
    }

    elsif ( $type eq 'i'	# numeric/integer
            || $type eq 'I'	# numeric/integer w/ incr default
	    || $type eq 'o' ) { # dec/oct/hex/bin value

	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;

	if ( $bundling && defined $rest
	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
	    ($key, $arg, $rest) = ($1, $2, $+);
	    chop($key) if $key;
	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
	}
	elsif ( $arg =~ /^$o_valid$/si ) {
	    $arg =~ tr/_//d;
	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
	}
	else {
	    if ( defined $optarg || $mand ) {
		if ( $passthrough ) {
		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
		      unless defined $optarg;
		    return (0);
		}
		warn ("Value \"", $arg, "\" invalid for option ",
		      $opt, " (",
		      $type eq 'o' ? "extended " : '',
		      "number expected)\n");
		$error++;
		# Push back.
		unshift (@$argv, $starter.$rest) if defined $rest;
		return (1, undef);
	    }
	    else {
		# Push back.
		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
		if ( $type eq 'I' ) {
		    # Fake incremental type.
		    my @c = @$ctl;
		    $c[CTL_TYPE] = '+';
		    return (1, $opt, \@c, 1);
		}
		# Supply default value.
		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
	    }
	}
    }

    elsif ( $type eq 'f' ) { # real number, int is also ok
	# We require at least one digit before a point or 'e',
	# and at least one digit following the point and 'e'.
	# [-]NN[.NN][eNN]
	my $o_valid = PAT_FLOAT;
	if ( $bundling && defined $rest &&
	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
	    $arg =~ tr/_//d;
	    ($key, $arg, $rest) = ($1, $2, $+);
	    chop($key) if $key;
	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
	}
	elsif ( $arg =~ /^$o_valid$/ ) {
	    $arg =~ tr/_//d;
	}
	else {
	    if ( defined $optarg || $mand ) {
		if ( $passthrough ) {
		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
		      unless defined $optarg;
		    return (0);
		}
		warn ("Value \"", $arg, "\" invalid for option ",
		      $opt, " (real number expected)\n");
		$error++;
		# Push back.
		unshift (@$argv, $starter.$rest) if defined $rest;
		return (1, undef);
	    }
	    else {
		# Push back.
		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
		# Supply default value.
		$arg = 0.0;
	    }
	}
    }
    else {
	die("Getopt::Long internal error (Can't happen)\n");
    }
    return (1, $opt, $ctl, $arg, $key);
}

sub ValidValue ($$$$$) {
    my ($ctl, $arg, $mand, $argend, $prefix) = @_;

    if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
	return 0 unless $arg =~ /[^=]+=(.*)/;
	$arg = $1;
    }

    my $type = $ctl->[CTL_TYPE];

    if ( $type eq 's' ) {	# string
	# A mandatory string takes anything.
	return (1) if $mand;

	return (1) if $arg eq "-";

	# Check for option or option list terminator.
	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
	return 1;
    }

    elsif ( $type eq 'i'	# numeric/integer
            || $type eq 'I'	# numeric/integer w/ incr default
	    || $type eq 'o' ) { # dec/oct/hex/bin value

	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
	return $arg =~ /^$o_valid$/si;
    }

    elsif ( $type eq 'f' ) { # real number, int is also ok
	# We require at least one digit before a point or 'e',
	# and at least one digit following the point and 'e'.
	# [-]NN[.NN][eNN]
	my $o_valid = PAT_FLOAT;
	return $arg =~ /^$o_valid$/;
    }
    die("ValidValue: Cannot happen\n");
}

# Getopt::Long Configuration.
sub Configure (@) {
    my (@options) = @_;

    my $prevconfig =
      [ $error, $debug, $major_version, $minor_version,
	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
	$longprefix ];

    if ( ref($options[0]) eq 'ARRAY' ) {
	( $error, $debug, $major_version, $minor_version,
	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
	  $longprefix ) = @{shift(@options)};
    }

    my $opt;
    foreach $opt ( @options ) {
	my $try = lc ($opt);
	my $action = 1;
	if ( $try =~ /^no_?(.*)$/s ) {
	    $action = 0;
	    $try = $+;
	}
	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
	    ConfigDefaults ();
	}
	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
	    local $ENV{POSIXLY_CORRECT};
	    $ENV{POSIXLY_CORRECT} = 1 if $action;
	    ConfigDefaults ();
	}
	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
	    $autoabbrev = $action;
	}
	elsif ( $try eq 'getopt_compat' ) {
	    $getopt_compat = $action;
            $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
	}
	elsif ( $try eq 'gnu_getopt' ) {
	    if ( $action ) {
		$gnu_compat = 1;
		$bundling = 1;
		$getopt_compat = 0;
                $genprefix = "(--|-)";
		$order = $PERMUTE;
	    }
	}
	elsif ( $try eq 'gnu_compat' ) {
	    $gnu_compat = $action;
	}
	elsif ( $try =~ /^(auto_?)?version$/ ) {
	    $auto_version = $action;
	}
	elsif ( $try =~ /^(auto_?)?help$/ ) {
	    $auto_help = $action;
	}
	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
	    $ignorecase = $action;
	}
	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
	    $ignorecase = $action ? 2 : 0;
	}
	elsif ( $try eq 'bundling' ) {
	    $bundling = $action;
	}
	elsif ( $try eq 'bundling_override' ) {
	    $bundling = $action ? 2 : 0;
	}
	elsif ( $try eq 'require_order' ) {
	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
	}
	elsif ( $try eq 'permute' ) {
	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
	}
	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
	    $passthrough = $action;
	}
	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
	    $genprefix = $1;
	    # Turn into regexp. Needs to be parenthesized!
	    $genprefix = "(" . quotemeta($genprefix) . ")";
	    eval { '' =~ /$genprefix/; };
	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@;
	}
	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
	    $genprefix = $1;
	    # Parenthesize if needed.
	    $genprefix = "(" . $genprefix . ")"
	      unless $genprefix =~ /^\(.*\)$/;
	    eval { '' =~ m"$genprefix"; };
	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@;
	}
	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
	    $longprefix = $1;
	    # Parenthesize if needed.
	    $longprefix = "(" . $longprefix . ")"
	      unless $longprefix =~ /^\(.*\)$/;
	    eval { '' =~ m"$longprefix"; };
	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"") if $@;
	}
	elsif ( $try eq 'debug' ) {
	    $debug = $action;
	}
	else {
	    die("Getopt::Long: unknown config parameter \"$opt\"")
	}
    }
    $prevconfig;
}

# Deprecated name.
sub config (@) {
    Configure (@_);
}

# Issue a standard message for --version.
#
# The arguments are mostly the same as for Pod::Usage::pod2usage:
#
#  - a number (exit value)
#  - a string (lead in message)
#  - a hash with options. See Pod::Usage for details.
#
sub VersionMessage(@) {
    # Massage args.
    my $pa = setup_pa_args("version", @_);

    my $v = $main::VERSION;
    my $fh = $pa->{-output} ||
      ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR;

    print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
	       $0, defined $v ? " version $v" : (),
	       "\n",
	       "(", __PACKAGE__, "::", "GetOptions",
	       " version ",
	       defined($Getopt::Long::VERSION_STRING)
	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
	       " Perl version ",
	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
	       ")\n");
    exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
}

# Issue a standard message for --help.
#
# The arguments are the same as for Pod::Usage::pod2usage:
#
#  - a number (exit value)
#  - a string (lead in message)
#  - a hash with options. See Pod::Usage for details.
#
sub HelpMessage(@) {
    eval {
	require Pod::Usage;
	import Pod::Usage;
	1;
    } || die("Cannot provide help: cannot load Pod::Usage\n");

    # Note that pod2usage will issue a warning if -exitval => NOEXIT.
    pod2usage(setup_pa_args("help", @_));

}

# Helper routine to set up a normalized hash ref to be used as
# argument to pod2usage.
sub setup_pa_args($@) {
    my $tag = shift;		# who's calling

    # If called by direct binding to an option, it will get the option
    # name and value as arguments. Remove these, if so.
    @_ = () if @_ == 2 && $_[0] eq $tag;

    my $pa;
    if ( @_ > 1 ) {
	$pa = { @_ };
    }
    else {
	$pa = shift || {};
    }

    # At this point, $pa can be a number (exit value), string
    # (message) or hash with options.

    if ( UNIVERSAL::isa($pa, 'HASH') ) {
	# Get rid of -msg vs. -message ambiguity.
	$pa->{-message} = $pa->{-msg};
	delete($pa->{-msg});
    }
    elsif ( $pa =~ /^-?\d+$/ ) {
	$pa = { -exitval => $pa };
    }
    else {
	$pa = { -message => $pa };
    }

    # These are _our_ defaults.
    $pa->{-verbose} = 0 unless exists($pa->{-verbose});
    $pa->{-exitval} = 0 unless exists($pa->{-exitval});
    $pa;
}

# Sneak way to know what version the user requested.
sub VERSION {
    $requested_version = $_[1];
    shift->SUPER::VERSION(@_);
}

package Getopt::Long::CallBack;

sub new {
    my ($pkg, %atts) = @_;
    bless { %atts }, $pkg;
}

sub name {
    my $self = shift;
    ''.$self->{name};
}

use overload
  # Treat this object as an oridinary string for legacy API.
  '""'	   => \&name,
  fallback => 1;

1;

###############################################################################################################################
# END OF Getopt::Long
###############################################################################################################################

package main;

use Cwd qw/getcwd abs_path/;
use File::Temp 'tempfile';
sub GetOptionsFromArray { goto &Getopt::Long::GetOptionsFromArray }
#use Getopt::Long 'GetOptionsFromArray';  # included above
use Term::ReadLine;
use strict;

my($arg0) = $0 =~ /([^\/]+)$/; # just the base name of this script

Getopt::Long::Configure(qw/no_permute bundling/);

# Print usage message and exit
sub usage {
  open GIT, "-|", "git --help" or die;
  while (<GIT>) {
    s/\bgit\b/$arg0/;
    s/^usage: $arg0.*/usage: $arg0 COMMAND [ARGS]\n$help/;
    print;
  }
  close GIT;
  exit 1;
}

# Prints message from GetOptions about an unsupported switch.
sub unsupported {
  my($switch) = "-$_[0]";
  $switch = "-$switch" if length $switch > 2;
  die "$arg0: unsupported switch: $switch\n";
}

# Returns true if specified directory looks like it's the top of ROSE
sub is_top_of_rose {
  my($dir) = @_;
  return unless -d $dir && -d "$dir/.git";
  return unless open MODULES, "$dir/.gitmodules";
  my $has_edg = grep {m(^\[\s*submodule\s+\"src/frontend/CxxFrontend/EDG\"\s*]\s*$)} <MODULES>;
  close MODULES;
  return $has_edg;
}

# Returns absolute directory name for top of ROSE repo.  Your CWD must be somewhere inside ROSE to start with.
sub top_of_rose {
  my @comps = split /\//, getcwd;
  while (@comps) {
    my $s = join "/", @comps;
    return $s if is_top_of_rose $s;
    pop @comps;
  }
  die "$arg0: cannot find top of ROSE source tree (cwd=@{[getcwd]})";
}

# Rewrite the .git/config file for submodule URLs
sub rewrite_submodule_configs {
  my($edit) = @_;
  local $_;
  my @content; # rewritten content of .git/config file.
  open CONF, ".git/config" or die "$arg0: .git/config: $!";
  my($sectype,$secname,$origin_url); # set when we encounter a "[...]" line.
  while (<CONF>) {
    if (/^\s*\[\s*(\w+)\s+"(.*)"\s*\]/) {
      ($sectype,$secname) = ($1,$2);
    } elsif (my($key,$val) = /^\s*(\w+)\s*=\s*(.*?)\s*$/) {
      if ($key eq "url" && $sectype eq "remote" && $secname eq "origin") {
	$origin_url = $val;
	$origin_url =~ s/\/+$//;
      } elsif ($key eq "url" && $sectype eq "submodule") {
	die unless $origin_url;
	my($base) = $val =~ /([^\/]+)$/;
	my($path) = $origin_url =~ /^(.*)\//;
	my($url) = "$path/$base";
	if ($edit) {
	  print "Submodule $secname\n    Default: $url\n";
	  my($term) = Term::ReadLine->new($arg0);
	  $term->addhistory($url);
	  my($response) = $term->readline("  New Value: ");
	  $url = $response if $response ne "";
	}
	$_ = "\t$key = $url\n";
      }
    }
    push @content, $_;
  }
  close CONF;
  system "cp .git/config .git/config~"; #ignore status
  open CONF, ">.git/config" or die "$arg0: .git/config: $!\n";
  print CONF join "", @content;
  close CONF;
}

# Returns submodule info. Each return value is an array ref with two elements: the path of the submodule with respect
# to the supermodule, and the SHA1 as recorded in the supermodule.
sub submodules {
  my $cmd = "cd @{[top_of_rose]} && git submodule --quiet foreach 'echo \$sha1 \$path'";
  open F, "-|", $cmd or die "$arg0:cannot obtain submodule names";
  my @retval = map {chomp;[(split /\s+/, $_)[1,0]]} <F>;
  close F or die "$arg0: cannot obtain submodule names";
  return @retval;
}

# Like submodules, but return references instead.
sub refs {
  open F, "-|", "git show-ref" or die "$arg0:cannot obtain references";
  my @retval = map {chomp;[(split /\s+/, $_)[1,0]]} <F>;
  close F or die "$arg0: cannot obtain references";
  return @retval;
}

# Run arbitrary git command in CWD and optionally return all stdout as an array of chomped lines. Returns true
# on success, false on failure.  The command should be an array, one argument per element. Note that under certain
# circumstances the array will be converted to a space-separated string and passed to the shell (this happens when
# we're grabbing output to return or we specify a working directory).
sub git {
  my($output) = shift @_ if 'ARRAY' eq ref $_[0];
  my($opts) = 'HASH' eq ref $_[0] ? shift @_ : {};
  my(@cmd,$cmd) = ("git", @_);

  my $convert_to_string = sub { join " ", map {"'$_'"} @_ };

  if ($opts->{cd}) {
    $cmd ||= &{$convert_to_string}(@cmd);
    $cmd = "(cd '$opts->{cd}' && $cmd)";
  }

  unless ($opts->{quiet}) {
    if ($cmd ne "") {
      print "+ $cmd\n";
    } else {
      print "+", (map {" $_"} @cmd), "\n";
    }
  }

  if ($output) {
    $cmd ||= &{$convert_to_string}(@cmd);
    open F, "-|", $cmd or return;
    while (<F>) {
      chomp;
      push @$output, $_;
    }
    close F or return;
  } elsif ($cmd) {
    system $cmd and return;
  } else {
    system @cmd and return;
  }
  return 1;
}

# Wrappers around git commands that return a single line. Return undef on failure rather than die.
sub git1 { my @output; git \@output, @_; return $output[0] }
sub rev_parse { git1 {quiet=>1}, "rev-parse", "-q", "--verify", ($_[0]||"HEAD") }
sub symbolic_ref { git1 {quiet=>1}, "symbolic-ref", "-q", ($_[0]||"HEAD") }
sub merge_base { git1 {quiet=>1}, "merge-base", @_ }


# Try to find a branch that matches the current (possibly detached) HEAD, and switch to it.
#   (1) Prefer the supplied name if specified
#   (2) Otherwise, create or fast forward a local branch with the same name as the remote branch if found
#   (3) Otherwise, consider all local and remote branches
#   (4) Otherwise, leave things as they are
sub switch_to_branch {
  my($branch) = @_;
  my($verbose) = 0; # set to 1 for debugging
  my $HEAD = rev_parse or die;
  my %refs = map {@$_} refs; # hash indexed by ref name

  print "$arg0: switch_to_branch($branch) HEAD=$HEAD\n" if $verbose;

  # List of candidate branches to try, in the order we want to try them: $branch, origin/$branch, local branches, remote branches
  my @candidates;
  push @candidates, "refs/heads/$branch" if $refs{"refs/heads/$branch"} eq $HEAD;
  push @candidates, "refs/heads/remotes/origin/$branch" if $refs{"refs/heads/remotes/origin/$branch"} eq $HEAD;
  push @candidates, grep {m(^refs/heads/) && $refs{$_} eq $HEAD} sort keys %refs;
  push @candidates, grep {m(^refs/remotes/origin/) && $refs{$_} eq $HEAD} sort keys %refs;

  for my $full (@candidates) {
    print "  trying branch=$full ", $refs{$full}, "\n" if $verbose;
    my($base) = $full =~ /([^\/]*)$/;

    if ($full =~ m(^refs/remotes/origin/)) {
      if ($refs{"refs/heads/$base"}) {
	if (merge_base("refs/heads/$base", $full) eq $refs{"refs/heads/$base"}) {
	  # Remote branch matches HEAD and local branch can be fast-forwarded.
	  git "checkout", "--quiet", $base or die "$arg0: could not check out $base";
	  git "merge", $full or die "$arg0: could not merge $full";
	  return;
	}
      } else {
	# Remote branch ($full) matches head and local branch ($base) does not exist; create it.
	git "checkout", "--quiet", "-b", $base, $full or die;
	return;
      }
    } else {
      # $full is a local branch that matches $HEAD, so use it.
      git "checkout", "--quiet", $base or die "$arg0: could not checkout $base";
      return;
    }
  }
  print "  head is detached (no suitable branch found)\n" if $verbose;
}

# Execute the supplied code for each submodule. The list of submodules are the same format as returned by &submodules.
# To execute code in the top-level ROSE repo use undef (or an empty @modules).  CODE is called with two args: the sha1 and
# the path. All code is run with its CWD at the top of the module.
my($prev_path);
sub execute {
  my($code,@modules) = @_;
  push @modules, undef unless @modules;
  for my $module (@modules) {
    my($path,$sha1) = $module ? @$module : (".","HEAD");
    print "==== In ROSE $path ====\n" unless $path eq $prev_path;
    $prev_path = $path;
    chdir(top_of_rose . "/$path") or die "$arg0: cannot chdir: $!";
    &{$code}($path,$sha1);
  }
}

# Executes a command in every submodule and then the top ROSE repo regardless of whether any command fails. Exits
# nonzero if any command exited with nonzero status.
sub postorder {
  my @args = @_; # for closures
  my $exit;
  for my $sm (submodules, undef) {
    eval { execute sub {git @args}, $sm };
    $exit ||= $@;
  }
  exit 1 if $exit;
}

# Saves the commit message in a temporary file and returns its name.
sub save_commit_message {
  my($commit) = @_;
  my($tmp,$tmpname) = tempfile();
  open GIT, "-|", "git cat-file -p $commit" or die;
  1 while <GIT> =~ /\S/;
  print $tmp join "", <GIT>;
  close GIT;
  close $tmp;
  return $tmpname;
}

# Returns true if a commit would have an effect. First arg is true for "commit -a", false otherwise.
sub commit_has_effect {
  my($allflag) = @_;
  if ($allflag) {
    `git diff --quiet`; return 1 if $?;  # changes not staged yet?
  }
  `git diff --quiet --cached`; return $?; # changes which are staged already?
}

###############################################################################################################################
#                                  Functions implementing Git subcommands
###############################################################################################################################

# If we're creating a new branch then also create a new branch in the submodules.  Otherwise just have Git run
# the specified command at the top of the ROSE repo and then in each submodule.
sub do_branch {
  my(@allargs) = @_;
  my($delete,$create_reflog,$force,$move,$color,$remote,$all,$verbose,$abbrev,$track,$contains,$merged,$no_merged);
  GetOptionsFromArray(\@_,
		      d=>\$delete, D=>sub{$delete=2}, l=>\$create_reflog, f=>\$force, m=>\$move, M=>sub{$move=2},
		      "color!"=>\$color, r=>\$remote, a=>\$all, "v|verbose"=>sub{++$verbose}, "abbrev=i"=>\$abbrev,
		      "t|track!"=>\$track, "contains=s"=>\$contains, "merged:s"=>\$merged, "no-merged:s"=>\$no_merged)
    or exit 1;

  execute sub {git "branch", @allargs or die};

  if ($delete || $move) {
    execute sub {git "branch", @allargs or die}, submodules;
  } elsif (@_>=1) {
    # branch creation
    my($newbranch,$branchhead) = ($_[0], $_[1]||"HEAD");
    my($head_sha1) = rev_parse $branchhead;

    execute sub {
      my($path) = @_;
      my($rev) = git1 {cd=>".."}, "rev-parse", "$head_sha1:$path" or die;
      my(@gitargs) = ($newbranch, $rev);
      unshift @gitargs, "--track" if $track;
      unshift @gitargs, "--no-track" if defined($track) && !$track;
      unshift @gitargs, "-l" if $create_reflog;
      unshift @gitargs, "-f" if $force;
      git "branch", @gitargs or die;
    }, submodules;
  } else {
    # branch query
    execute sub {git "branch", @allargs or die}, submodules;
  }
}

# A checkout with the "-b" switch also create similar branches in the submodules.  Regardless of presence of "-b",
# we also run "git submodule update". Otherwise just run the git command in the top of the ROSE repo.
sub do_checkout {
  my($quiet,$mkbranch,$track,$create_reflog) = (1);
  GetOptionsFromArray(\@_,
		      "q|quiet"=>\$quiet, "f|force"=>\&unsupported, ours=>\&unsupported, theirs=>\&unsupported,
		      "b=s"=>\$mkbranch, "t|track!"=>\$track, l=>\$create_reflog,
		      "m|merge"=>\&unsupported, "conflict=s"=>\&unsupported, "p|patch"=>\&unsupported)
    or exit 1;
  die "$arg0: incorrect usage\n" unless @_<=1;
  my($startpoint) = @_>0 ? $_[0] : "HEAD";

  my $checkout = sub {
    my($path) = @_;
    my(@gitargs);
    push @gitargs, "--quiet" if $quiet;
    push @gitargs, "-b", $mkbranch if $mkbranch;
    push @gitargs, "--no-track" if !$track && defined $track;
    push @gitargs, "--track" if $track;
    push @gitargs, "-l" if $create_reflog;
    if ($path eq ".") {
      push @gitargs, $startpoint;
    } else {
      my($sha1) = git1 {cd=>".."}, "rev-parse", "$startpoint:$path" or die;
      push @gitargs, $sha1;
    }
    git "checkout", @gitargs or die;
  };

  execute $checkout;
  execute $checkout, submodules if $mkbranch;
  execute sub {git "submodule", "--quiet", "update", "--no-fetch" or die};
  execute sub {switch_to_branch($mkbranch||$startpoint)}, submodules;
}

# Run a "clone" command. Arguments are the same as the real Git "clone" command.  This is the only command we
# support that's run *outside* the git repository. It does the following:
#    (1) git clone ....
#    (2) git submodule init
#    (3) $EDITOR .git/config # give user chance to edit submodule URLs before submodule update
#    (4) git submodule update
sub do_clone {
  my($edit,$local,$no_hardlinks,$quiet,$verbose,$branch,$upload_pack,$template,$recursive);
  GetOptionsFromArray(\@_, "edit"=>\$edit, # not a git-clone switch
		      "l|local"=>\$local, "no-hardlinks"=>\$no_hardlinks, "shared"=>\&unsupported,
		      "reference"=>\&unsupported, "q|quiet"=>\$quiet, "v|verbose"=>\$verbose,
		      "n|no-checkout"=>\&unsupported, "bare"=>\&unsupported, "mirror"=>\&unsupported,
		      "o|origin"=>\&unsupported, "b|branch=s"=>\$branch, "u|upload-pack=s"=>\$upload_pack,
		      "template=s"=>\$template, "depth"=>\&unsupported, "recursive"=>\$recursive)
    or exit 1;
  die "$arg0: clone: incorrect usage\n" if $@>2;
  my($repo,$dir) = @_;

  # supermodule clone
  my @gitargs;
  push @gitargs, "--local" if $local;
  push @gitargs, "--no-hardlinks" if $no_hardlinks;
  push @gitargs, "--verbose" if $verbose; # do not pass "--quiet"
  push @gitargs, "--branch", $branch if $branch;
  push @gitargs, "--upload-pack", $upload_pack if $upload_pack;
  push @gitargs, "--template", $template if $template;
  push @gitargs, $repo;
  push @gitargs, $dir if $dir;
  open GIT, "-|", "git clone @{[join ' ', @gitargs]}" or die "$arg0: git clone failed";
  my($dirline) = <GIT>;
  close GIT or die "$arg0: git clone failed";

  # Find the local repository
  if ($dirline =~ /^Initialized empty Git repository in\s+(.*?)\.git\/?$/) {
    $dir = $1;
  } elsif ($dirline =~ /Cloning into\s+(.*?)\.\.\.$/) {
    $dir = $1;
  } else {
    die "$arg0: where's the local repository?!? dirline=$dirline"
  }
  chdir $dir or die "$arg0: cannot find Git repository at $dir: $!\n";

  # set up and clone submodules
  git "submodule", "--quiet", "init" or die;
  rewrite_submodule_configs($edit);
  git "submodule", "update" or
    die "$arg0: submodule update failed.  Fix your .git/config file and run \"git submodule update\" by hand.\n";

  # Switch to a branch of the submodule
  execute sub {switch_to_branch symbolic_ref}, submodules;
  print "Repository cloned to $dir\n";
}

# Commits changes in the main ROSE repo and in the submodules.
sub do_commit {
  my($all,$reuse,$reedit,$reset_author,$msgfile,$author,$message,$template,$signoff,$no_verify,$cleanup,$edit);
  my($untracked,$verbose,$quiet);
  GetOptionsFromArray(\@_,
		      "a|all"=>\$all, "C|reuse-message=s"=>\$reuse, "c|reedit-message=s"=>\$reedit,
		      "reset-author"=>\$reset_author, "F|file=s"=>\$msgfile, "author=s"=>\$author,
		      "m|message=s"=>\$message, "t|template=s"=>\$template, "s|signoff"=>\$signoff,
		      "n|no-verify"=>\$no_verify, "allow-empty"=>\&unsupported, "cleanup=s"=>\$cleanup,
		      "e|edit"=>\$edit, "amend"=>\&unsupported, "i|include"=>\&unsupported, "o|only"=>\&unsupported,
		      "u|untracked-files=s"=>\$untracked, "v|verbose"=>\$verbose, "q|quiet"=>\$quiet,
		      "dry-run"=>\&unsupported) or exit 1;
  die "$arg0: commit: incorrect usage\n" if @_;

  # Convert relative message files to absolute so we can pass the name to submodules.
  if (defined $msgfile) {
    if ($msgfile eq '-') {
      while (<STDIN>) {
	$message .= $_;
      }
      $msgfile = undef;
    } elsif ($msgfile !~ /^\//) {
      $msgfile = abs_path($msgfile);
    }
  }

  my $git_commit = sub {
    my($path,$sha1) = @_;
    unless (commit_has_effect($all)) {
      print "Nothing to commit.\n";
      return;
    }
    my @gitargs;
    push @gitargs, "--all" if $all;
    push @gitargs, "--reuse-message", $reuse if $reuse && $path eq ".";
    push @gitargs, "--reedit-message", $reedit if $reedit && $path eq ".";
    if ($msgfile) {
      push @gitargs, "--file", $msgfile;
    } elsif ($message) {
      push @gitargs, "--message", $message;
    }
    push @gitargs, "--template", $template if $template;
    push @gitargs, "--signoff" if $signoff;
    push @gitargs, "--no-verify" if $no_verify;
    push @gitargs, "--cleanup", $cleanup if $cleanup;
    push @gitargs, "--edit" if $edit;
    push @gitargs, "--untracked-files", $untracked if $untracked;
    push @gitargs, "--verbose" if $verbose;
    push @gitargs, "--quiet" if $quiet;
    git "commit", @gitargs or die "$arg0: commit failed\n";
    $msgfile = save_commit_message("HEAD"); #remember mesg so we don't have to retype it
  };

  execute $git_commit, submodules;                          # commit in submodules
  execute sub {git "add", map {$_->[0]} submodules or die}; # add submodule paths in top of ROSE
  execute $git_commit, undef;                               # commit in top of ROSE
  unlink $msgfile;
}

# Merges some branch into the current branch using the following algorithm:
#       (1) Merge (but do not commit) in the supermodule, ignoring conflicts for now
#       (2) Do merges in the submodules
#       (3) Add new submodule versions to supermodule, probably fixing most conflicts
#       (4) Commit the merge from step 1, checking for and failing if conflicts remain
sub do_merge {
  my(@args) = @_;
  my($unused,$allow_ff,$log,$diffstat,$ff_only,$quiet,$verbose,$message);
  GetOptionsFromArray(\@_,
		      "no-commit"=>\&unsupported, "commit"=>\$unused, "ff!"=>\$allow_ff,
		      "log!"=>\$log, "stat!"=>\$diffstat, "n"=>sub {$diffstat=0},
		      "squash"=>\&unsupported, "no-squash"=>\$unused, "ff-only"=>\$ff_only,
		      "s|strategy"=>\&unsupported, "q|quiet"=>\$quiet, "v|verbose"=>\$verbose,
		      "m=s"=>\$message) or exit 1;
  die "$arg0: merge: incorrect usage\n" unless @_;
  die "$arg0: merge: octopuses are not allowed\n" if @_>1;
  my $remote = $_[0];

  # Merge (but do not commit) in the supermodule, ignoring conflicts for now.
  my $merge = sub {
    my($path) = @_;
    my($rev) = $remote;
    if ($path ne ".") {
      $rev = git1 {cd=>".."}, "rev-parse", "$remote:$path" or die;
      if ($rev eq "$remote:$path") {
	print STDERR "$arg0: $remote does not have this submodule; skipping it\n";
	return;
      }
    }
    my @gitargs;
    push @gitargs, "--no-commit" if $path eq ".";
    push @gitargs, "--ff" if $allow_ff;
    push @gitargs, "--no-ff" if !$allow_ff && defined $allow_ff;
    push @gitargs, "--log" if $log;
    push @gitargs, "--no-log" if !$log && defined $log;
    push @gitargs, "--stat" if $diffstat;
    push @gitargs, "--no-stat" if !$diffstat && defined $diffstat;
    push @gitargs, "--ff-only" if $ff_only;
    push @gitargs, "--quiet" if $quiet;
    push @gitargs, "--verbose" if $verbose;
    my $ok = git "merge", @gitargs, $rev;
    die "$arg0: merge failed\n" unless $ok || $path eq ".";
  };

  execute $merge unless -f "@{[top_of_rose]}/.git/MERGE_HEAD";
  if (submodules) { # merge in supermodule may have removed the submodules!
    execute $merge, submodules if submodules;
    execute sub {git "add", map {$_->[0]} submodules or die};
  } else {
    print STDERR "$arg0: WARNING: merge removed all submodules!\n";
  }

  if (commit_has_effect) {
    execute sub {
      my @gitargs;
      push @gitargs, "-F", ".git/MERGE_MSG" if -f ".git/MERGE_MSG";
      if (commit_has_effect) {
	git "commit", @gitargs or
	  die "Fix conflicts, add to cache, and rerun $arg0 merge command (or commit manually).\n";
      }
    };
  }
}

# Similar to git-pull: essentially a fetch and merge.
sub do_pull {
  my($allow_ff,$log,$diffstat,$unused,$ff_only,$quiet,$verbose,$all,$append,$force,$keep,$tags,$upload_pack);
  GetOptionsFromArray(\@_,
		      "no-commit"=>\&unsupported, "commit"=>\$unused, "ff!"=>\$allow_ff,
		      "log!"=>\$log, "stat!"=>\$diffstat, "n"=>sub {$diffstat=0},
		      "squash"=>\&unsupported, "no-squash"=>\$unused, "ff-only"=>\$ff_only,
		      "s|strategy=s"=>\&unsupported, "q|quiet"=>\$quiet, "v|verbose"=>\$verbose,
		      "rebase!"=>\&unsupported,
		      "all"=>\$all, "a|append"=>\$append, "depth"=>\&unsupported, "f|force"=>\$force,
		      "k|keep"=>\$keep, "t|tags!"=>\$tags, "u|update-head-ok"=>\&unsupported,
		      "upload-pack=s"=>\$upload_pack) or exit 1;
  die "$arg0: pull: incorrect usage\n" unless @_ <= 2;
  my($repo,$refspec) = @_;

  # Fetch
  my @fargs;
  push @fargs, "--all" if $all;
  push @fargs, "--append" if $append;
  push @fargs, "--force" if $force;
  push @fargs, "--keep" if $keep;
  push @fargs, "--tags" if $tags;
  push @fargs, "--no-tags" if !$tags && defined $tags;
  push @fargs, "--upload-pack", $upload_pack if $upload_pack;
  push @fargs, $repo if defined $repo;
  push @fargs, $refspec if defined $refspec;
  postorder "fetch", @fargs; # exits on failure

  # What to merge?  We're basically reimplementing a good chunk of the git-pull logic here. Unfortunately we can't
  # use git-pull directly because we need to be careful of the order we merge the submodules -- see do_merge() for details.
  my($branch) = symbolic_ref =~ m(refs/heads/([^\/]+)$);
  die "$arg0: not on any branch" unless $branch;
  $repo ||= git1({quiet=>1}, "config", "--get", "branch.$branch.remote") || "origin";
  $refspec ||= git1({quiet=>1}, "config", "--get", "branch.$branch.merge");
  my $mergefrom;
  if ($refspec =~ /:(.*)/) {
    $mergefrom = $1;
    $mergefrom = undef if $mergefrom =~ /\*$/;
  } elsif ($refspec =~ m(refs/heads/(.*))) {
    $mergefrom = "refs/remotes/$repo/$branch";
  }

  # Debugging
  print "$arg0-pull: info: branch=$branch\n";
  print "$arg0-pull: info: repo=$repo\n";
  print "$arg0-pull: info: refspec=$refspec\n";
  print "$arg0-pull: info: mergefrom=$mergefrom\n";

  # Merge
  if ($mergefrom) {
    my @margs;
    push @margs, "--ff" if $allow_ff;
    push @margs, "--no-ff" if !$allow_ff && defined $allow_ff;
    push @margs, "--log" if $log;
    push @margs, "--no-log" if !$log && defined $log;
    push @margs, "--stat" if $diffstat;
    push @margs, "--no-stat" if !$diffstat && defined $diffstat;
    push @margs, "--ff-only" if $ff_only;
    push @margs, "--quiet" if $quiet;
    push @margs, "--verbose" if $verbose;
    print "$arg0-pull: does the following command look suitable?\n";
    print "    git merge", (map {" $_"} @margs), " $mergefrom\n";
    print "ENTER to continue; Control-C to abort... ";
    scalar <STDIN>;
    do_merge(@margs,$mergefrom);
  } else {
    print "$arg0-pull: nothing to merge\n";
  }
}

# Same as git-push in each submodule, except when a specific top-level branch is specified something special happens in the
# submodules:
#
# When a top-level branch is specified (such as "smgit push origin rpm-bugfixes-rc") then instead of trying to push
# rpm-bugfixes-rc in each submodule, we push the submodule branch that would be checked out by "smgit checkout rpm-bugfixes-rc".
sub do_push {
  my($all, $mirror, $dry_run, $porcelain, $tags, $receive_pack, $exec, $conditional_repo, $thin, $verbose, $quiet, $force);
  GetOptionsFromArray(\@_,
		      "all"=>\$all, "mirror"=>\$mirror, "n|dry-run"=>\$dry_run, "porcelain"=>\$porcelain,
		      "tags"=>\$tags, "receive-pack=s"=>\$receive_pack, "exec=s"=>\$exec, "f|force"=>\&unsupported,
		      "repo=s"=>\$conditional_repo, "thin!"=>\$thin, "v|verbose"=>\$verbose, "q|quiet"=>\$quiet,
		      "f|force"=>\$force) or exit 1;
  die "$arg0: push: incorrect usage\n" unless @_ <= 2;
  my($repo,$refspec) = @_;

  $repo =~ /[:\/]/ and
    die "$arg0: push: repo paths are not supported by smgit.  Use a repo name instead, such as \"origin\".\n";

  my $push = sub {
    my($path) = @_;
    my(@gitargs);
    push @gitargs, "--all" if $all;
    push @gitargs, "--mirror" if $mirror;
    push @gitargs, "--dry-run" if $dry_run;
    push @gitargs, "--porcelain" if $porcelain;
    push @gitargs, "--tags" if $tags;
    push @gitargs, "--receive-pack=$receive_pack" if $receive_pack;
    push @gitargs, "--repo=$conditional_repo" if $conditional_repo;
    push @gitargs, "--thin" if $thin;
    push @gitargs, "--verbose" if $verbose;
    push @gitargs, "--quiet" if $quiet;
    push @gitargs, $repo if $repo;
    if ($path eq "." || !$refspec) {
      push @gitargs, $refspec if $refspec;
      git "push", @gitargs;
    } elsif (my($dstref) = $refspec =~ /^\+?:(.+)/) {
      if ($force) {
	$dstref = "refs/heads/".$dstref unless $dstref =~ /^refs\//;
	git "push", @gitargs, ":$dstref";
      } else {
	warn "$arg0: refusing to delete $refspec in submodule (add \"--force\" if you really want that)\n";
      }
    } else {
      my($force,$srcref,$dstref);
      if ($refspec =~ /^(\+?)(.+?):(.*)$/) {
	($force,$srcref,$dstref) = ($1,$2,$3)
      } elsif ($refspec =~ /^(\+?)(.+)$/) {
	($force,$srcref,$dstref) = ($1,$2,$2);
      } else {
	die "$arg0: maformed refspec: $refspec\n";
      }
      if ($force) {
	warn "$arg0: disallowing non-fast-forward pushing in submodules\n";
      }

      # $srcref is from the parent module; replace it with the submodule ref that would be checked out in the parent.
      $srcref = git1 {cd=>".."}, "rev-parse", "$srcref:$path" or die;

      # If the remote ref doesn't start with "refs/heads/" then we probably need to add that.  But this means smgit can't be used
      # to push to other things.  Oh well.
      $dstref = "refs/heads/".$dstref unless $dstref =~ /^refs\//;

      git "push", @gitargs, "$srcref:$dstref"
    }
  };

  # Run the push command in all the submodules, then the super module. Doing it in this order will allow the remote
  # hooks to check that a supermodule's submodules are all present before accepting the super module update.
  execute $push, submodules;
  execute $push;
}

# Prints some info that's useful for debugging
sub do_debug {
  print "Debugging information from $arg0:\n";
  print "cwd=", cwd(), "\n";
  execute sub {
    git "--version";
    system "cat", ".git/config";
    git "submodule";
  };
  execute sub {
    git "status";
    git "branch", "-av";
  }, undef, submodules;
}

###############################################################################################################################
# MAIN PROGRAM
###############################################################################################################################

# Provide a name for this script when run from stdin as 'perl -' (as done by smgit_launcher')
if (@ARGV>0 && $ARGV[0] =~ /^--name=(.*)/) {
  $arg0 = $1;
  shift;
}

# Make sure we're using Git version 1.6.4 or later (we need the "git submodule foreach" command with the ability to pass
# the submodule name to the script.
my @gvers = `git --version` =~ /(\d+)\.(\d+)\.(\d+)/;
die "$arg0: requires Git version 1.6.4 or later\n"
  unless $gvers[0]>1 || ($gvers[0]==1 && ($gvers[1]>6 || ($gvers[1]==6 && $gvers[2]>=4)));

my %cmds = (branch      => \&do_branch,
            checkout    => \&do_checkout,
            clone       => \&do_clone,
            commit      => \&do_commit,
	    debug       => \&do_debug,
            help        => sub {execute sub {git "help", @ARGV}}, # no need to execute in submodules
            merge       => \&do_merge,
	    pull        => \&do_pull,
	    push        => \&do_push,
           );

my $cmd = shift @ARGV;
usage if $cmd =~ /^-/ || !$cmd || ($cmd eq "help" && 0==@ARGV);
die "$arg0: you have no submodules; use plain old git instead.
    (smgit is a wrapper around git that limits the functionality in order to
    make it easier to use submodules.)\n" unless $cmd eq "clone" || submodules;
$cmds{$cmd} ? &{$cmds{$cmd}}(@ARGV) : postorder $cmd, @ARGV;
