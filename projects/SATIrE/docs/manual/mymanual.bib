@InProceedings{conf/esop/SteffenKR90,
  title =	"The Value Flow Graph: {A} Program Representation for
		 Optimal Program Transformations",
  author =	"Bernhard Steffen and Jens Knoop and Oliver
		 R{\"u}thing",
  year = 	"1990",
  bibdate =	"2002-02-13",
  bibsource =	"DBLP,
		 http://dblp.uni-trier.de/db/conf/esop/esop90.html#SteffenKR90",
  booktitle =	"ESOP'90",
  pages =	"389--405",
}
@InProceedings{conf/cc/KnoopR00,
  title =	"Constant Propagation on the Value Graph: Simple
		 Constants and Beyond",
  author =	"Jens Knoop and Oliver R{\"u}thing",
  year = 	"2000",
  bibdate =	"2002-01-03",
  bibsource =	"DBLP,
		 http://dblp.uni-trier.de/db/conf/cc/cc2000.html#KnoopR00",
  booktitle =	"CC'00",
  pages =	"94--109",
  URL =  	"http://link.springer.de/link/service/series/0558/bibs/1781/17810094.htm",
}
@Article{SRW98,
  author =       "Mooly Sagiv and Thomas Reps and Reinhard Wilhelm",
  title =        "Solving shape-analysis problems in languages with
                 destructive updating",
  journal =      "ACM Transactions on Programming Languages and
                 Systems",
  volume =       "20",
  number =       "1",
  pages =        "1--50",
  month =        jan,
  year =         "1998",
  coden =        "ATPSDT",
  ISSN =         "0164-0925",
  bibdate =      "Sat Jan 2 10:46:05 MST 1999",
  url =          "http://www.acm.org:80/pubs/citations/journals/toplas/1998-20-1/p1-sagiv/",
  abstract =     "This article concerns the static analysis of programs
                 that perform destructive updating on heap-allocated
                 storage. We give an algorithm that uses finite shape
                 graphs to approximate conservatively the possible
                 ``shapes'' that heap-allocated structures in a program
                 can take on. For certain programs, our technique is
                 able to determine such properties as (1) when the input
                 to the program is a list, the output is also a list and
                 (2) when the input to the program is a tree, the output
                 is also a tree. For example, the method can determine
                 that ``listness'' is preserved by (1) a program that
                 performs list reversal via destructive updating of the
                 input list and (2) a program that searches a list and
                 splices a new element into the list. None of the
                 previously known methods that use graphs to model the
                 program's store are capable of determining that
                 ``listness'' is preserved on these examples (or
                 examples of similar complexity). In contrast with most
                 previous work, our shape analysis algorithm is even
                 accurate for certain programs that update cyclic data
                 structures; that is, it is sometimes able to show that
                 when the input to the program is a circular list, the
                 output is also a circular list. For example, the
                 shape-analysis algorithm can determine that an
                 insertion into a circular list preserves ``circular
                 listness.''",
  acknowledgement = ack-nhfb,
  keywords =     "algorithms; languages; theory; verification",
  subject =      "{\bf F.3.2} Theory of Computation, LOGICS AND MEANINGS
                 OF PROGRAMS, Semantics of Programming Languages,
                 Program analysis. {\bf D.2.5} Software, SOFTWARE
                 ENGINEERING, Testing and Debugging, Symbolic execution.
                 {\bf D.3.3} Software, PROGRAMMING LANGUAGES, Language
                 Constructs and Features, Data types and structures.
                 {\bf D.3.4} Software, PROGRAMMING LANGUAGES,
                 Processors, Optimization. {\bf E.1} Data, DATA
                 STRUCTURES, Graphs and networks. {\bf F.3.3} Theory of
                 Computation, LOGICS AND MEANINGS OF PROGRAMS, Studies
                 of Program Constructs, Type structure. {\bf E.1} Data,
                 DATA STRUCTURES, Lists, stacks, and queues. {\bf E.1}
                 Data, DATA STRUCTURES, Trees. {\bf E.2} Data, DATA
                 STORAGE REPRESENTATIONS, Linked representations.",
}

@InProceedings{MS-SCAM05,
  author =       "Markus Schordan and Daniel Quinlan",
  title =        "Specifying Transformation Sequences as Computation on Program Fragments with an Abstract Attribute Grammar",
  booktitle =    "Proceedings of the Fifth IEEE International Workshop on Source Code Analysis and Manipulation (SCAM'05)",
  publisher =    "IEEE Computer Society Press",
  year =         "2005",
  mon =          sep,
  pages =        "97--106",
  isbn =         "0-7695-2292-0",
}

@MISC{EDG,
author =         "{{E}dison {D}esign {G}roup.}",
title =          "http://www.edg.com",
}

@MISC{ROSE,
author =         "{ROSE}",
title =          "http://www.rosecompiler.org",
}

@MISC{pag,
author =         "{{A}bs{I}nt {A}ngewandte {I}nformatik {G}mb{H}}",
title =          "Program Analyzer Generator: User's Manual",
year  =          "2002",
}

@Article{knoop98basicblock,
  author =       {Jens Knoop and Dirk Kosch\"{u}tzki and Bernhard Steffen},
  title  =       "Basic-block graphs: Living dinosaurs?",
  journal =      "Lecture Notes in Computer Science",
  volume =       "1383",
  pages =        "65--79",
  year =         "1998",
  ISBN =         "3-540-64304-4",
}

@ARTICLE{martin98, 
AUTHOR= "Florian Martin", 
TITLE= "{PAG} -- an efficient program analyzer generator", 
YEAR={1998},
EDITOR="Chris Hankin",
PUBLISHER={Springer},
JOURNAL = "International Journal on Software Tools for Technology Transfer",
VOLUME=2,
NUMBER=1,
PAGES={46--67}
}

