SYNTAX
START:CompilationUnit
BinaryOperation:
	 LogOp
	|CompOp
	|AddOp
	|MulOp
	|AssignmentOp
	|Exp(right:Expression,left:Expression)
	|BinaryApplyOp
	|BinaryFromOp
	;
BinaryApplyLogOp:
	 BinaryApplyAnd(right:Expression,left:Expression)
	|BinaryApplyOr(right:Expression,left:Expression)
	;
ParameterList:
	 NotEmptyParameterList(items:Parameter+)
	|EmptyParameterList()
	;
AbstractUseItemList:
	 UseItemList(items:AbstractUseItem+)
	;
UnaryApplyAddOp:
	 UnaryApplySub(operand:Expression)
	|UnaryApplyAdd(operand:Expression)
	;
UnaryApplyComOp:
	 UnaryApplyGreaterEq(operand:Expression)
	|UnaryApplyNotEq(operand:Expression)
	|UnaryApplyLesserEq(operand:Expression)
	|UnaryApplyNotIn(operand:Expression)
	|UnaryApplySubset(operand:Expression)
	|UnaryApplyEq(operand:Expression)
	|UnaryApplyLesser(operand:Expression)
	|UnaryApplyGreater(operand:Expression)
	|UnaryApplyIn(operand:Expression)
	|UnaryApplyIncs(operand:Expression)
	;
BinaryApplyCompOp:
	 BinaryApplySubset(right:Expression,left:Expression)
	|BinaryApplyNotIn(right:Expression,left:Expression)
	|BinaryApplyLesserEq(right:Expression,left:Expression)
	|BinaryApplyIncs(right:Expression,left:Expression)
	|BinaryApplyIn(right:Expression,left:Expression)
	|BinaryApplyGreater(right:Expression,left:Expression)
	|BinaryApplyLesser(right:Expression,left:Expression)
	|BinaryApplyGreaterEq(right:Expression,left:Expression)
	|BinaryApplyNotEqual(right:Expression,left:Expression)
	|BinaryApplyEqual(right:Expression,left:Expression)
	;
LogOp:
	 And(right:Expression,left:Expression)
	|Or(right:Expression,left:Expression)
	;
QuantifierOp:
	 Exists(expr:Expression,exprList:Expression+)
	|ForAll(expr:Expression,exprList:Expression+)
	;
CompilationUnit:
	 PackageBody(name:String,usePart:UsePart,procedures:ProcedureList,dataDeclaration:DataDeclarationPart)
	|Program(name:String,usePart:UsePart,procedures:ProcedureList,body:Body,dataDeclaration:DataDeclarationPart)
	|ProcessBody(name:String,usePart:UsePart,procedures:ProcedureList,dataDeclaration:DataDeclarationPart)
	|PackageSpecification(name:String,declarations:ProcedureDeclarationList,dataDeclaration:DataDeclarationPart)
	|ProcessSpecification(name:String,declarations:ProcedureDeclarationList,dataDeclaration:DataDeclarationPart)
	|ClassSpecificaiton(name:String,dataDeclaration:DataDeclarationPart,declarations:ProcedureDeclarationList,baseClasses:BaseClassList)
	|NativePackage(name:String,declarations:ProcedureDeclarationList)
	|ClassBody(name:String,usePart:UsePart,methods:ProcedureList,dataDeclaration:DataDeclarationPart)
	;
StatementOrExpr:
	 Statement
	|Expression
	;
AbstractProcedureDeclaration:
	 ProcedureDeclaration(name:String,parameters:ParameterList)
	;
ProcedureDeclarationList:
	 EmptyProcedureDeclarationList()
	|NotEmptyProcedureDeclarationList(items:AbstractProcedureDeclaration+)
	;
Body:
	 NotEmptyBody(items:StatementOrExpr+)
	|EmptyBody()
	;
AssignmentCompOp:
	 AssignLesser(right:Expression,left:Expression)
	|AssignGreater(right:Expression,left:Expression)
	|AssignEqual(right:Expression,left:Expression)
	|AssignSubset(right:Expression,left:Expression)
	|AssignGreaterEq(right:Expression,left:Expression)
	|AssignIn(right:Expression,left:Expression)
	|AssignLesserEq(right:Expression,left:Expression)
	|AssignIncs(right:Expression,left:Expression)
	|AssignNotIn(right:Expression,left:Expression)
	|AssignNotEqual(right:Expression,left:Expression)
	;
AbstractCaseItem:
	 AbstractCaseItemExprList
	|AbstractCaseItemExpr
	;
Parameter:
	 ReadWriteParam(name:String)
	|WriteOnlyParam(name:String)
	|ReadOnlyParam(name:String)
	;
VarDeclaration:
	 UninitializedVarDeclaration(Name:String)
	|InitializedVarDeclaration(Name:String,initializer:Expression)
	;
Statement:
	 NullExpression()
	|AssertStmt(expr:Expression)
	|Stop()
	|Return
	|Continue
	|Exit
	;
CaseExpr:
	 CaseExprNoDefault(items:AbstractCaseItemExpr+)
	|CaseExprDefault(items:AbstractCaseItemExpr+,defaultBody:StatementOrExpr+)
	;
AbstractCaseItemExprList:
	 CaseItemExprList(expr:Expression+,body:StatementOrExpr+)
	;
UnaryApplyMulOp:
	 UnaryApplyQuestionmark(operand:Expression)
	|UnaryApplyMod(operand:Expression)
	|UnaryApplyDiv(operand:Expression)
	|UnaryApplyLess(operand:Expression)
	|UnaryApplyPow(operand:Expression)
	|UnaryApplyMin(operand:Expression)
	|UnaryApplyMul(operand:Expression)
	|UnaryApplyLessf(operand:Expression)
	|UnaryApplyMax(operand:Expression)
	|UnaryApplyWith(operand:Expression)
	;
AssignAddOp:
	 AssignAdd(right:Expression,left:Expression)
	|AssignSub(right:Expression,left:Expression)
	;
BinaryApplyAddOp:
	 BinaryApplyAdd(right:Expression,left:Expression)
	|BinaryApplySub(right:Expression,left:Expression)
	;
Tuple:
	 DescriptiveTuple(items:Expression+)
	|IteratorTuple(iteratorExpr:Expression,expr:Expression)
	|SuchthatTuple(item:Expression,selector:Expression,from:Expression+)
	|EmptyTuple()
	|OtherTuple(expr:Expression,exprList:Expression+)
	|CalculatedTuple(end:Expression,startItems:Expression+)
	;
AbstractBaseClass:
	 BaseClass()
	;
ClassVarDeclaration:
	 InitializedClassVarDeclaration(Name:String,Initializer:Expression)
	|UninitializedClassVarDeclaration(Name:String)
	;
Case:
	 CaseExpr
	|CaseExprList
	;
BinaryApplyMulOp:
	 BinaryApplyLessf(right:Expression,left:Expression)
	|BinaryApplyLess(right:Expression,left:Expression)
	|BinaryApplyMax(right:Expression,left:Expression)
	|BinaryApplyMin(right:Expression,left:Expression)
	|BinaryApplyQuestionmark(right:Expression,left:Expression)
	|BinaryApplyPow(right:Expression,left:Expression)
	|BinaryApplyMul(right:Expression,left:Expression)
	|BinaryApplyWith(right:Expression,left:Expression)
	|BinaryApplyDiv(right:Expression,left:Expression)
	|BinaryApplyMod(right:Expression,left:Expression)
	;
Expression:
	 BinaryOperation
	|Self()
	|QuantifierOp
	|Until(expr:Expression,body:StatementOrExpr+)
	|Ident(name:String)
	|Selector(parameters:Expression+)
	|FNum(value:float)
	|MapSelector(parameters:Expression+,leftPart:Expression)
	|MemberAccess(leftPart:Expression)
	|Tuple
	|Case
	|While(condition:Expression,body:StatementOrExpr+)
	|StringValue(value:String)
	|Loop(body:StatementOrExpr+)
	|Call
	|For
	|If
	|INum(value:int)
	|UnaryOperation
	|Set
	|Assignment(right:Expression,left:Expression)
	|LambdaExpression(parameters:LambdaParameterList,dataDeclaration:DataDeclarationPart,procedures:ProcedureList,body:Body)
	;
CompOp:
	 In(right:Expression,left:Expression)
	|Greater(right:Expression,left:Expression)
	|GreaterEq(right:Expression,left:Expression)
	|NotIn(right:Expression,left:Expression)
	|Equal(right:Expression,left:Expression)
	|Lesser(right:Expression,left:Expression)
	|Subset(right:Expression,left:Expression)
	|LesserEq(right:Expression,left:Expression)
	|NotEqual(right:Expression,left:Expression)
	|Incs(right:Expression,left:Expression)
	;
AddOp:
	 Sub(right:Expression,left:Expression)
	|Add(right:Expression,left:Expression)
	;
MulOp:
	 Max(right:Expression,left:Expression)
	|Mod(right:Expression,left:Expression)
	|Mul(right:Expression,left:Expression)
	|Less(right:Expression,left:Expression)
	|Lessf(right:Expression,left:Expression)
	|Div(right:Expression,left:Expression)
	|Questionmark(right:Expression,left:Expression)
	|With(right:Expression,left:Expression)
	|NPow(right:Expression,left:Expression)
	|Min(right:Expression,left:Expression)
	;
Return:
	 ReturnExpr(expr:Expression)
	|EmptyReturn()
	;
DataDeclarationPart:
	 NotEmptyDataDeclarationPart(items:DataDeclaration+)
	|EmptyDataDeclarationPart()
	;
AbstractUseItem:
	 UseItem(name:String)
	;
LambdaParameterList:
	 NotEmptyLambdaParameterList(items:AbstractLambdaParameter+)
	|EmptyLambdaParameterList()
	;
Continue:
	 UnconditionalContinue()
	|ContinueWhen(condition:Expression)
	;
Exit:
	 EmptyExit()
	|ExitExpr(expr:Expression)
	|ExitExprWhen(expr:Expression,condition:Expression)
	|ExitWhen(condition:Expression)
	;
BaseClassList:
	 NoteEmptyBaseClassList(items:AbstractBaseClass+)
	|EmptyBaseClassList()
	;
Call:
	 CalculatedCall2Ex(leftPart:Expression,expr2:Expression,expr1:Expression)
	|CalculatedCall1Ex(leftPart:Expression,expr:Expression)
	|ParameterCall(leftPart:Expression,parameterList:Expression+)
	|EmptyCall(leftPart:Expression)
	;
UsePart:
	 EmptyUsePart()
	|NotEmptyUsePart(lists:AbstractUseItemList+)
	;
AbstractCaseItemExpr:
	 CaseItemExpr(expr:Expression,body:StatementOrExpr+)
	;
UnaryApplyLogOp:
	 UnaryApplyOr(operand:Expression)
	|UnaryApplyAnd(operand:Expression)
	;
AbstractLambdaParameter:
	 LambdaParameter(name:String)
	;
For:
	 ForExprListOnly(exprList:Expression+,body:StatementOrExpr+)
	|ForSuchthat(exprList:Expression+,body:StatementOrExpr+,expr:Expression)
	;
If:
	 IfThen(ifBodies:AbstractIfBody+)
	|IfThenElse(ifBodies:AbstractIfBody+,elseBody:StatementOrExpr+)
	;
AssignmentOp:
	 AssignmentCompOp
	|AssignAddOp
	|AssignMulOp
	|AssignmentLogOp
	;
UnaryOperation:
	 Domain(operand:Expression)
	|Sign(operand:Expression)
	|Num(operand:Expression)
	|Pow(operand:Expression)
	|Arb(operand:Expression)
	|A(operand:Expression)
	|UnaryFromOp
	|UnaryApplyOp
	|Not(operand:Expression)
	|Range(operand:Expression)
	;
UnaryFromOp:
	 UnaryFromE(operand:Expression)
	|UnaryFromB(operand:Expression)
	|UnaryFrom(operand:Expression)
	;
ProcedureList:
	 EmptyProcedureList()
	|NotEmptyProcedureList(procedures:AbstractProcedure+)
	;
UnaryApplyOp:
	 UnaryApplyAddOp
	|UnaryApplyComOp
	|UnaryApplyMulOp
	|UnaryApplyLogOp
	;
Set:
	 CalculatedSet(end:Expression,startItems:Expression+)
	|SuchthatSet(item:Expression,selector:Expression,from:Expression+)
	|DescriptiveSet(items:Expression+)
	|EmptySet()
	|OtherSet(expr:Expression,exprList:Expression+)
	|IteratorSet(iteratorExpr:Expression,expr:Expression)
	;
AssignMulOp:
	 AssignMod(right:Expression,left:Expression)
	|AssignPow(right:Expression,left:Expression)
	|AssignMax(right:Expression,left:Expression)
	|AssignWith(right:Expression,left:Expression)
	|AssignQuestionmark(right:Expression,left:Expression)
	|AssignMin(right:Expression,left:Expression)
	|AssignMul(right:Expression,left:Expression)
	|AssignDiv(right:Expression,left:Expression)
	|AssignLessf(right:Expression,left:Expression)
	|AssignLess(right:Expression,left:Expression)
	;
AssignmentLogOp:
	 AssignAnd(right:Expression,left:Expression)
	|AssignOr(right:Expression,left:Expression)
	;
CaseExprList:
	 CaseExprListDefault(expr:Expression,items:AbstractCaseItemExprList+,defaultBody:StatementOrExpr+)
	|CaseExprListNoDefault(expr:Expression,items:AbstractCaseItemExprList+)
	;
BinaryApplyOp:
	 BinaryApplyLogOp
	|BinaryApplyCompOp
	|BinaryApplyAddOp
	|BinaryApplyMulOp
	;
AbstractProcedure:
	 Procedure(name:String,parameters:ParameterList,dataDeclaration:DataDeclarationPart,nestedProcs:ProcedureList,body:Body)
	;
AbstractIfBody:
	 IfBody(Expr:Expression,body:StatementOrExpr+)
	;
DataDeclaration:
	 VarDeclaration
	|ConstDeclaration(Name:String,initializer:Expression)
	|ClassVarClause
	|SelDeclaration(Name:String,selector:int)
	;
ClassVarClause:
	 ClassVarDeclaration
	;
BinaryFromOp:
	 BinaryFromB(right:Expression,left:Expression)
	|BinaryFrom(right:Expression,left:Expression)
	|BinaryFromE(right:Expression,left:Expression)
	;

String==snum;
int==inum;
float==fnum;
