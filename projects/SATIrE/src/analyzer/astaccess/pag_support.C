// -*- mode: c++; c-basic-offset: 4; -*-
// Copyright 2005,2006,2007 Markus Schordan, Gergo Barany
// $Id: pag_support.C,v 1.19 2009-02-09 11:02:36 gergo Exp $

#include <iostream>

#include <satire_rose.h>

#include "syntree.h"
#include "pignodelist.h"
#include "pag_support.h"
#include "IrCreation.h"

CFG *global_cfg = NULL;

CFG *get_global_cfg()
{
    return global_cfg;
}

PIG_EXTERN_C
const char *basic_type_name(const void *p)
{
    const SgNode *node = (SgNode *) p;

    switch (node->variantT())
    {
    case V_SgTypeBool: return "bool"; break;
    case V_SgTypeChar: return "char"; break;
    case V_SgTypeDouble: return "double"; break;
    case V_SgTypeFloat: return "float"; break;
    case V_SgTypeInt: return "int"; break;
    case V_SgTypeLong: return "long"; break;
    case V_SgTypeLongDouble: return "long double"; break;
    case V_SgTypeLongLong: return "long long"; break;
    case V_SgTypeShort: return "short"; break;
    case V_SgTypeSignedChar: return "signed char"; break;
    case V_SgTypeSignedInt: return "signed int"; break;
    case V_SgTypeSignedLong: return "signed long"; break;
    case V_SgTypeSignedShort: return "signed short"; break;
    case V_SgTypeString: return "string"; break;
    case V_SgTypeUnsignedChar: return "unsigned char"; break;
    case V_SgTypeUnsignedInt: return "unsinged int"; break;
    case V_SgTypeUnsignedLong: return "unsigned long"; break;
    case V_SgTypeUnsignedLongLong: return "unsigned long long"; break;
    case V_SgTypeUnsignedShort: return "unsigned short"; break;
    case V_SgTypeVoid: return "void"; break;
    case V_SgTypeWchar: return "wchar"; break;
    default: return NULL;
    }
}


#if HAVE_PAG

// GB (2008-05-08): The manual doesn't tell you this, but apparently these
// need to be initialized to negative values in the beginning; then the
// analyzer generated by PAG will call the syntax_init function, which is
// important.
int syntaxtype = -1;
int e_syntaxtype = -1;

#if OLD_GET_VALUE
#define get_value_macro(T) char *T##_get_value(void *s) \
    { if (s == NULL) return "<null>"; return (char *) s; }
#else
#define get_value_macro(T) char *T##_get_value(T x) \
{ std::stringstream s; s << x; return Ir::getCharPtr(s.str()); }
#endif

PIG_EXTERN_C get_value_macro(astint)
PIG_EXTERN_C get_value_macro(aststring)
PIG_EXTERN_C get_value_macro(astshort)
PIG_EXTERN_C get_value_macro(astchar)
PIG_EXTERN_C get_value_macro(astuchar)
PIG_EXTERN_C get_value_macro(astushort)
PIG_EXTERN_C get_value_macro(astuint)
PIG_EXTERN_C get_value_macro(astlong)
PIG_EXTERN_C get_value_macro(astllong)
PIG_EXTERN_C get_value_macro(astullong)
PIG_EXTERN_C get_value_macro(astulong)
PIG_EXTERN_C get_value_macro(astfloat)
PIG_EXTERN_C get_value_macro(astdouble)
PIG_EXTERN_C get_value_macro(astldouble)

#include "str.h"

PIG_EXTERN_C
const char *Expression_print(void *e)
{
    std::cout << expr_to_string(isSgExpression((SgNode *) e)) << std::flush;
    return str_create("");
}

PIG_EXTERN_C
const char *c_str_print(const void *s)
{
    std::cout << (const char *) s;
    return (const char *) s;
}

PIG_EXTERN_C
const char *LIST_VariableSymbolNT_print(void **l)
{
    std::cout << "[!";
    while (*l != NULL)
    {
        SgVariableSymbol *sym = (SgVariableSymbol *) *l;
        std::cout << sym->get_name().str() << ",";
        l++;
    }
    std::cout << "!]";
    return str_create("");
}

PIG_EXTERN_C
const char *Statement_print(void *s)
{
    SgStatement *stmt = isSgStatement((SgNode *) s);
    if (stmt != NULL && !isSgDoWhileStmt(stmt))
        std::cout << Ir::fragmentToString(stmt) << std::flush;
    else
        std::cout << ((SgNode *) s)->class_name() << std::flush;
    return str_create("");
}

// GB (2007-10-31): This has been commented out for a while. The reason is
// that these functions are now generated by pig.
#if 0
PIG_EXTERN_C
int LIST_VariableSymbolNT_empty(void *l)
{
    return ((PigNodeList *) l)->empty();
}

PIG_EXTERN_C
void *LIST_VariableSymbolNT_hd(void *l)
{
    return ((PigNodeList *) l)->head();
}

PIG_EXTERN_C
void *LIST_VariableSymbolNT_tl(void *l)
{
    return ((PigNodeList *) l)->tail();
}
#endif

#include "genkfg.h"

KFG_ATTR_DEF empty = { 0 };
KFG_ATTR_DEF *addr = &empty;
int zero = 0;

char const *kfg_get_attribute_symbol(char *)
{
    return NULL;
}

int kfg_get_global_attribute_information(KFG, KFG_ATTR_DEF **arr, int *len)
{
    arr = &addr;
    len = &zero;
    return 1;
}

int kfg_get_routine_attribute_information(KFG, KFG_ATTR_DEF **arr, int *len)
{
    arr = &addr;
    len = &zero;
    return 1;
}

int kfg_get_bblock_attribute_information(KFG, KFG_ATTR_DEF **arr, int *len)
{
    arr = &addr;
    len = &zero;
    return 1;
}

int kfg_get_instruction_attribute_information(KFG, KFG_ATTR_DEF **arr, int *len)
{
    arr = &addr;
    len = &zero;
    return 1;
}

int kfg_remap_global_attributes(KFG, KFG_ATTR_DEF **, int)
{
    return 1;
}

int kfg_remap_routine_attributes(KFG, KFG_ATTR_DEF **, int)
{
    return 1;
}

int kfg_remap_bblock_attributes(KFG, KFG_ATTR_DEF **, int)
{
    return 1;
}

int kfg_remap_instruction_attributes(KFG, KFG_ATTR_DEF **, int)
{
    return 1;
}

char const *kfg_get_global_attribute(KFG, int)
{
    return "";
}

char const *kfg_get_routine_attribute(KFG, int, int)
{
    return "";
}

char const *kfg_get_bblock_attribute(KFG, KFG_NODE, int)
{
    return "";
}

char const *kfg_get_instruction_attribute(KFG, KFG_NODE, int, int)
{
    return "";
}

char const *kfg_get_global_attribute_by_name(KFG, char *)
{
    return "";
}

char const *kfg_get_routine_attribute_by_name(KFG, int, char*)
{
    return "";
}

char const *kfg_get_bblock_attribute_by_name(KFG, KFG_NODE, char *)
{
    return "";
}

char const *kfg_get_instruction_attribute_by_name(KFG, KFG_NODE, int, char *)
{
    return "";
}

// GB (2008-08-21): Inclusion of snum.h, below, also includes "general.h".
// Funnily, this is supposed to include PAG's general.h, but there is also
// one in ROSE, which takes precedence due to -I flags. But that's OK,
// actually.
// What's not OK is that ROSE's general.h #defines FALSE and TRUE without
// definition guards. However, these macros are also defined (in an
// incompatible way, but ironically *with* guards) by sage3.h, which is
// already included via satire_rose.h. So all in all, including "snum.h"
// fails with a multiple definition error. We will try to get around this by
// undefining TRUE and FALSE here.
#undef TRUE
#undef FALSE

/* static attributes */
//#define HAVE_MEMMOVE
#include "pagheader.h"
#include "snum.h"
#include "unum.h"
/* list of global variables */
extern "C" void *kfg_get_global_attribute__globals(KFG cfg)
{
    return Ir::createNodeList(((CFG *) cfg)->globals);
 // return new PigNodeList(((CFG *) cfg)->globals);
}
/* numbers of types and expressions */
extern "C" unum kfg_get_global_attribute__numtypes(KFG cfg)
{
    return int_to_unum(((CFG *) cfg)->types_numbers.size());
}
extern "C" unum kfg_get_global_attribute__numexprs(KFG cfg)
{
    return int_to_unum(((CFG *) cfg)->numbers_exprs.size());
}
/* number of the current procedure */
extern "C" snum kfg_get_routine_attribute__procnum(KFG, int procnum)
{
    return int_to_snum(procnum);
}
/* statement labels */
extern "C" snum kfg_get_bblock_attribute__label(KFG cfg, KFG_NODE bb)
{
    return int_to_snum(kfg_get_id(cfg, bb));
}
/* position (context) IDs */
extern "C" snum kfg_get_position_attribute__position(KFG, KFG_NODE, int, int p)
{
    return int_to_snum(p);
}
/* context objects */
#include "o_ContextInfo.h"
extern "C" void *kfg_get_position_attribute__context(KFG cfg, KFG_NODE bb,
                                                     int, int position)
{
    ContextInfo c(kfg_procnumnode(cfg, bb), position);
    return o_ContextInfo_duplicate(&c);
}

/* external support functions */
#include "bool.h"
extern "C" FLO_BOOL o_is_unary(void *expr)
{
    return (isSgUnaryOp((SgNode *) expr) ? FLO_TRUE : FLO_FALSE);
}

extern "C" FLO_BOOL o_is_binary(void *expr)
{
    return (isSgBinaryOp((SgNode *) expr) ? FLO_TRUE : FLO_FALSE);
}

extern "C" FLO_BOOL o_is_value(void *expr)
{
    return (isSgValueExp((SgNode *) expr) ? FLO_TRUE : FLO_FALSE);
}

#include "assert.h"

extern "C" void *o_unary_get_child(void *expr)
{
    assert(o_is_unary(expr) == FLO_TRUE);
    return isSgUnaryOp((SgNode *) expr)->get_operand();
}

extern "C" FLO_BOOL o_unary_is_prefix(void *expr)
{
    assert(o_is_unary(expr) == FLO_TRUE);
    return (isSgUnaryOp((SgNode *) expr)->get_mode() == SgUnaryOp::prefix ?
            FLO_TRUE : FLO_FALSE);
}

extern "C" void *o_binary_get_left_child(void *expr)
{
    assert(o_is_binary(expr) == FLO_TRUE);
    return isSgBinaryOp((SgNode *) expr)->get_lhs_operand();
}

extern "C" void *o_binary_get_right_child(void *expr)
{
    assert(o_is_binary(expr) == FLO_TRUE);
    return isSgBinaryOp((SgNode *) expr)->get_rhs_operand();
}

// GB (2008-07-01): Global variables are not very elegant. I know.
extern bool satire_warn_deprecated;

extern "C" void *o_typenum_to_type(unum n)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'typenum_to_type'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return get_global_cfg()->numbers_types[unum_to_unsigned(n)];
}

extern "C" unum o_type_to_typenum(void *type)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'type_to_typenum'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return int_to_unum(get_global_cfg()->types_numbers[isSgType((SgNode *) type)]);
}

#include "str.h"

extern "C" str o_typenum_to_str(unum n)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'typenum_to_str'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return Ir::getCharPtr(Ir::fragmentToString(isSgType((SgNode *)o_typenum_to_type(n))));
}

extern "C" void *o_exprnum_to_expr(unum n)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'exprnum_to_expr'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return get_global_cfg()->numbers_exprs[unum_to_unsigned(n)];
}

extern "C" unum o_expr_to_exprnum(void *expr)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'expr_to_exprnum'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return int_to_unum(get_global_cfg()->exprs_numbers[isSgExpression((SgNode *) expr)]);
}

extern "C" str o_exprnum_to_str(unum n)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'exprnum_to_str'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return expr_to_string((SgExpression *) o_exprnum_to_expr(n));
}

extern "C" void *o_expr_type(void *expr)
{
    return isSgExpression((SgNode *) expr)->get_type();
}

extern "C" unum o_exprnum_typenum(unum n)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'exprnum_typenum'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return o_type_to_typenum(o_expr_type(o_exprnum_to_expr(n)));
}

extern "C" FLO_BOOL o_is_subtype_of(void *a, void *b)
{
    SgClassType *at = isSgClassType((SgType *) a),
                *bt = isSgClassType((SgType *) b);
    /* a is subtype of b if a inherits from b: look at a's
     * inheritances (base classes) */
    if (at == NULL) return FLO_FALSE;
    if (bt == NULL) return FLO_FALSE;
    const SgBaseClassPtrList &base_classes = 
        isSgClassDeclaration(at->get_declaration())->get_definition()
            ->get_inheritances();
    SgBaseClassPtrList::const_iterator i;
    for (i = base_classes.begin(); i != base_classes.end(); ++i)
    {
        SgClassDeclaration *base = (*i)->get_base_class();
        SgClassDeclaration *bdecl
            = isSgClassDeclaration(bt->get_declaration());
        if (base == bdecl || (base->get_type() != NULL && bdecl != NULL
                    && o_is_subtype_of(base->get_type(), bdecl->get_type())))
            return FLO_TRUE;
    }
    return FLO_FALSE;
}

extern "C" FLO_BOOL o_is_subtypenum_of(unum a, unum b)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'is_subtypenum_of'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return o_is_subtype_of(o_typenum_to_type(a), o_typenum_to_type(b));
}

extern "C" void *o_global_get_type(void *symbol)
{
    SgVariableSymbol *varsym = (SgVariableSymbol *) symbol;
    return varsym->get_type();
}

extern "C" FLO_BOOL o_global_has_initializer(void *symbol)
{
    SgVariableSymbol *varsym = (SgVariableSymbol *) symbol;
    if (get_global_cfg()->globals_initializers.find(varsym)
            != get_global_cfg()->globals_initializers.end())
    {
        return FLO_TRUE;
    }
    else
        return FLO_FALSE;
}

extern "C" void *o_global_get_initializer(void *symbol)
{
    SgVariableSymbol *varsym = (SgVariableSymbol *) symbol;
    return get_global_cfg()->globals_initializers[varsym];
}

extern "C" FLO_BOOL o_global_has_defining_declaration(void *symbol)
{
    SgVariableSymbol *varsym = (SgVariableSymbol *) symbol;
    std::map<SgVariableSymbol *, const SgVariableDeclaration *>::iterator pos
        = get_global_cfg()->globals_definingdecls.find(varsym);
    if (pos != get_global_cfg()->globals_definingdecls.end()
        && pos->second != NULL)
    {
        return FLO_TRUE;
    }
    else
        return FLO_FALSE;
}

extern "C" FLO_BOOL o_is_integer_type(void *t)
{
    SgType *type = (SgType *) t;
    return (type->isIntegerType() ? FLO_TRUE : FLO_FALSE);
}

// GB (2008-08-04): Two functions requested by Viktor to make the structure
// of ASTs explicit when trying to write patterns that match them.
extern "C" str o_stmt_asttext(void *statement)
{
    SgStatement *stmt = (SgStatement *) statement;
    std::string result = Ir::fragmentToTreeRepresentation(stmt);
    return Ir::getCharPtr(result);
}

extern "C" str o_expr_asttext(void *expression)
{
    SgExpression *expr = (SgExpression *) expression;
    std::string result = Ir::fragmentToTreeRepresentation(expr);
    return Ir::getCharPtr(result);
}

// GB (2008-05-09): This function returns a variable symbol's "ID", which is
// just the expression number that we also assign to uses of the same
// variable. These IDs are computed by the ICFG builder after having
// numbered all expressions.
// GB (2008-05-13): (Temporarily?) renamed "ID" to varnum because the
// VariableID class was introduced.
// GB (2008-07-01): This function apprears unnecessary because we have
// varsym_varid and varref_varid; it was also never documented, apparently.
#if 0
extern "C" unum o_variable_varnum(void *symbol)
{
    SgVariableSymbol *varsym = (SgVariableSymbol *) symbol;
    unsigned long id = get_global_cfg()->varsyms_ids[varsym];
    return int_to_unum(id);
}
#endif

extern "C" str o_exp_root_str(void *exp)
{
    /* WARNING: This is not clean at all, but the Value Flow Graph
     * analysis relies on the fact that the strings representing
     * operators returned by this function begin with "op " (yes,
     * including the space character; that ensures it is not a
     * variable name beginning with "op").
     * Please do not change that without due cause, thanks. */
    SgExpression *expr = isSgExpression((SgNode *) exp);
    if (expr == NULL)
        return "'not an expression'";
    else switch (expr->variantT())
    {
    case V_SgAddOp:             return "op +";
    case V_SgSubtractOp:        return "op -";
    case V_SgMultiplyOp:        return "op *";
    case V_SgDivideOp:          return "op / (floating)";
    case V_SgIntegerDivideOp:   return "op / (integer)";
    case V_SgModOp:             return "op %";
    case V_SgAndOp:             return "op &&";
    case V_SgOrOp:              return "op ||";
    case V_SgBitXorOp:          return "op ^";
    case V_SgBitAndOp:          return "op &";
    case V_SgBitOrOp:           return "op |";
    case V_SgLshiftOp:          return "op <<";
    case V_SgRshiftOp:          return "op >>";
    case V_SgMinusOp:           return "op - (unary)";
    case V_SgPointerDerefExp:   return "op * (dereference)";
    case V_SgAddressOfOp :      return "op & (address of)";
    case V_SgVarRefExp:
        {
            SgVarRefExp *v = isSgVarRefExp(expr);
            std::string name = v->get_symbol()->get_name().str();
            return Ir::getCharPtr(name);
        }
    case V_SgIntVal:
        {
            std::stringstream value;
            value << isSgIntVal((SgNode *) expr)->get_value();
            return Ir::getCharPtr(value.str());
        }
    default:
        {
            SgValueExp *ve = isSgValueExp(expr);
            if (ve != NULL)
                return expr_to_string(ve);
            std::string class_name = expr->class_name();
            return Ir::getCharPtr(class_name);
        }
    }
}

extern "C" FLO_BOOL o_is_operatorname(str s)
{
    return (strncmp(s, "op ", 3) == 0 ? FLO_TRUE : FLO_FALSE);
}

#include <string.h>
#include "gc_mem.h"

unsigned long synttype_hash(void *x)
{
    return (unsigned long) x;
}

int syntax_eq(void *x, void *y)
{
    return (strcmp((const char *) x, (const char *) y) != 0);
}

void syntax_mcopy(void *x, void *y)
{
    strcpy((char *) y, (const char *) x);
}

void syntaxdummy(void *)
{
}

#ifdef __cplusplus
extern "C"
#endif
void syntax_init(void)
{
    bool calledBefore = false;
    if (!calledBefore)
    {
     // GB (2008-05-08): This code is required by PAG; in the manual I have,
     // it is in Section 9.4 "Additional Requirements" of Chapter 9
     // "Frontend Interface Reference".
        syntaxtype = GC_registertype(48, syntaxdummy, syntax_mcopy,
            syntax_eq, synttype_hash, 0);
        e_syntaxtype = GC_registertype(1024, syntaxdummy, syntax_mcopy,
            syntax_eq, synttype_hash, 0);
     // Don't execute this code again, even if this function should be
     // called again.
        calledBefore = true;
    }
}

#include "ast_support_funcs.h"

// GB (2007-10-31): These are not marked extern "C" because they are not
// called directly from the PAG code; PAG calls the functions with the o_
// prefixes.
SgType *typenum_to_type(unsigned long n)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'typenum_to_type'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return get_global_cfg()->numbers_types[n];
}

unsigned long type_to_typenum(SgType *type)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'type_to_typenum'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return get_global_cfg()->types_numbers[type];
}

std::string typenum_to_str(unsigned long n)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'typenum_to_str'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return Ir::fragmentToString(typenum_to_type(n));
}

SgExpression *exprnum_to_expr(unsigned long n)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'exprnum_to_expr'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return get_global_cfg()->numbers_exprs[n];
}

unsigned long expr_to_exprnum(SgExpression *expr)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'expr_to_exprnum'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return get_global_cfg()->exprs_numbers[expr];
}

std::string exprnum_to_str(unsigned long n)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'exprnum_to_str'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return expr_to_string(exprnum_to_expr(n));
}

SgType *expr_type(SgExpression *expr)
{
    return expr->get_type();
}

unsigned long exprnum_typenum(unsigned long n)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'exprnum_typenum'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    return type_to_typenum(expr_type(exprnum_to_expr(n)));
}

bool is_subtype_of(SgClassType *a, SgClassType *b)
{
    return o_is_subtype_of(a, b) == FLO_TRUE;
}

bool is_subtypenum_of(unsigned long a, unsigned long b)
{
    if (satire_warn_deprecated)
    {
        std::cerr
            << "** Warning: calling deprecated SATIrE support function 'is_subtypenum_of'"
            << std::endl
            << "(use --no-warn-deprecated command line flag to suppress this warning)"
            << std::endl;
    }
    SgClassType *ta = isSgClassType(typenum_to_type(a));
    SgClassType *tb = isSgClassType(typenum_to_type(b));
    return (ta != NULL && tb != NULL && is_subtype_of(ta, tb));
}


// Two support functions that PAG suddenly started to require at some point.
int kfg_routine_is_loop (KFG cfg, KFG_ROUTINE routine)
{
    return 0;
}

int kfg_routine_is_infeasible (KFG cfg, KFG_ROUTINE routine)
{
    return 0;
}

#endif
