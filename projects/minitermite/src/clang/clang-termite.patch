Index: include/clang/AST/DeclBase.h
===================================================================
--- include/clang/AST/DeclBase.h	(revision 63505)
+++ include/clang/AST/DeclBase.h	(working copy)
@@ -197,7 +197,7 @@
   Decl(Kind DK, DeclContext *DC, SourceLocation L) 
     : Loc(L), NextDeclarator(0), NextDeclInScope(0), 
       DeclCtx(reinterpret_cast<uintptr_t>(DC)), DeclKind(DK), InvalidDecl(0),
-      HasAttrs(false), Implicit(false) {
+      HasAttrs(false), Implicit(false), Access(AS_none) {
     if (Decl::CollectingStats()) addDeclKind(DK);
   }
 
Index: include/clang/AST/ASTConsumer.h
===================================================================
--- include/clang/AST/ASTConsumer.h	(revision 63505)
+++ include/clang/AST/ASTConsumer.h	(working copy)
@@ -20,7 +20,7 @@
   class Decl;
   class TagDecl;
   class HandleTagDeclDefinition;
-  
+
 /// ASTConsumer - This is an abstract interface that should be implemented by
 /// clients that read ASTs.  This abstraction layer allows the client to be
 /// independent of the AST producer (e.g. parser vs AST dump file reader, etc).
@@ -53,8 +53,15 @@
   /// PrintStats - If desired, print any statistics.
   virtual void PrintStats() {
   }
-};
 
+  /// This is a quick hack added to support prolog and epilog generation for consumers
+  /// that produce a whole-program representation
+  virtual void OnFirstFile(const char*) { }; //called by the driver for the very first file
+  virtual void OnNewFile(const char*)   { }; //called by the driver for every file but the very first one
+  virtual void OnLastFile()  { };            //called by the driver for the very last file
+  virtual void OnFileEnd()  { };             //called by the driver after a file has been processed
+};  
+  
 } // end namespace clang.
 
 #endif
Index: include/clang/AST/Expr.h
===================================================================
--- include/clang/AST/Expr.h	(revision 63505)
+++ include/clang/AST/Expr.h	(working copy)
@@ -1750,12 +1750,18 @@
   virtual child_iterator child_end();
   
   typedef std::vector<Stmt *>::iterator iterator;
+  typedef std::vector<Stmt *>::const_iterator const_iterator;
   typedef std::vector<Stmt *>::reverse_iterator reverse_iterator;
+  typedef std::vector<Stmt *>::const_reverse_iterator const_reverse_iterator;
   
   iterator begin() { return InitExprs.begin(); }
+  const_iterator begin() const { return InitExprs.begin(); }
   iterator end() { return InitExprs.end(); }
+  const_iterator end() const { return InitExprs.end(); }
   reverse_iterator rbegin() { return InitExprs.rbegin(); }
+  const_reverse_iterator rbegin() const { return InitExprs.rbegin(); }
   reverse_iterator rend() { return InitExprs.rend(); }
+  const_reverse_iterator rend() const { return InitExprs.rend(); }
   
   // Serailization.
   virtual void EmitImpl(llvm::Serializer& S) const;
Index: include/clang/Lex/PPCallbacks.h
===================================================================
--- include/clang/Lex/PPCallbacks.h	(revision 63505)
+++ include/clang/Lex/PPCallbacks.h	(working copy)
@@ -53,6 +53,18 @@
   virtual void PragmaComment(SourceLocation Loc, const IdentifierInfo *Kind, 
                              const std::string &Str) {
   }
+
+  /// IncludeDirective - This callback is invoked when a #include directive
+  /// is read.
+  ///
+  virtual void IncludeDirective(SourceLocation Loc, const std::string &file) {
+  }
+
+  /// DefineDirective - This callback is invoked when a #undef directive
+  /// is read.
+  ///
+  virtual void UndefDirective(SourceLocation Loc, const std::string &name) {
+  }
   
 };
 
Index: Driver/TermDumper.cpp
===================================================================
--- Driver/TermDumper.cpp	(revision 0)
+++ Driver/TermDumper.cpp	(revision 0)
@@ -0,0 +1,1961 @@
+
+//===--- StmtTermDumper.cpp - TermDumping implementation for Stmt ASTs ----===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements a pass to emit clang's internal AST into an external
+// file using the Termite representation of SATIrE.
+// 
+// See: http://www.complang.tuwien.ac.at/satire/
+//      http://www.complang.tuwien.ac.at/adrian/termite/
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang.h"
+#include "clang/Lex/PPCallbacks.h"
+#include "clang/Lex/Preprocessor.h"
+#include "ASTConsumers.h"
+#include "clang/AST/ASTConsumer.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/StmtVisitor.h"
+#include "clang/AST/DeclObjC.h"
+#include "clang/AST/DeclCXX.h"
+#include "clang/Basic/SourceManager.h"
+#include "clang/Basic/FileManager.h"
+#include "llvm/Support/Compiler.h"
+#include <cstdio>
+#include <iostream>
+#include <iomanip>
+#include <fstream>
+#include <sstream>
+#include <queue>
+#include <string>
+#include <memory>
+
+#include "minitermite/minitermite.h"
+
+using namespace clang;
+
+#define PPI "preprocessing_info([])"
+#define AIB "analysis_info([])"
+//#define AI "analysis_info(null,null)"
+#define DA "default_annotation(null, " PPI "), " AIB
+#define DAB "default_annotation(null, " PPI "), " AIB
+
+//===----------------------------------------------------------------------===//
+/// ASTTermDumper - TERMITE dump of ASTs
+
+namespace {
+  class PPTracker : public PPCallbacks {
+
+  public:    
+    typedef enum {
+      ppd_include,
+      ppd_undef,
+      ppd_define
+    } pp_directive_t;
+   
+    typedef struct {
+      SourceLocation loc;
+      std::string code;
+      pp_directive_t type;
+    } PPDirective;
+
+  protected:
+    Preprocessor &PP;
+    SourceManager &SM;
+    
+    // a map of encountered preprocessor directives (per file)
+    std::map< FileID, std::queue<PPDirective> > PPDs;
+    
+  public:    
+    PPTracker(Preprocessor &pp) : PP(pp), SM(pp.getSourceManager()) { }
+
+    void EnqueueDirective(SourceLocation loc, std::string directive, pp_directive_t type) {
+      if(!SM.isInSystemHeader(loc)) {
+        PPDirective d;
+
+        d.loc = loc;
+        d.code = directive;
+        d.type = type;
+        
+        assert(!loc.isInvalid() && "expecting valid source location");
+        FileID fid = SM.getFileID(loc);
+        PPDs[fid].push(d);
+      }
+    }
+    
+    virtual void IncludeDirective(SourceLocation Loc, const std::string &file) {
+      EnqueueDirective(Loc, std::string("#include ") + file, ppd_include);
+    }
+
+    virtual void UndefDirective(SourceLocation Loc, const std::string &name) {
+      EnqueueDirective(Loc, std::string("#undef ") + name, ppd_undef);
+    }
+    
+    bool location_lt(SourceLocation l1, SourceLocation l2) {
+      assert(l1.isValid() && l2.isValid() && "expecting valid source locations");
+      PresumedLoc p1 = SM.getPresumedLoc(l1);
+      PresumedLoc p2 = SM.getPresumedLoc(l2);
+      
+      assert(strcmp(p1.getFilename(), p2.getFilename()) == 0
+             && "comparing locations for different files");
+      return p1.getLine() < p2.getLine() ||
+        (p1.getLine() == p2.getLine() && p1.getColumn() <= p2.getColumn());
+    }
+    
+    //dequeue directives declared _before_ loc
+    void dequeueDirectives(SourceLocation loc, std::list<PPDirective> &ppds) {
+      assert(!loc.isInvalid() && "expecting valid source location");
+      
+      FileID fid = SM.getFileID(loc);
+      std::queue<PPDirective> &Q = PPDs[fid];
+
+      while(!Q.empty()) {
+        PPDirective *d = &Q.front();
+        if(!location_lt(d->loc, loc))
+          break;
+        ppds.push_back(*d);
+        Q.pop();
+      }
+    }
+
+  };
+  
+  
+  class ASTTermDumper : public ASTConsumer {
+    /** reference to the source manager
+     */
+    SourceManager *SM;
+
+    /** name of the input source file.
+     */
+    const std::string &infile;
+
+    /** name of the output (term) file
+     */
+    const std::string &outfile;
+
+    /** this is the current preprocessor object
+     */
+    Preprocessor *PP;
+
+    /** a preprocessor callback tracking #include and #define directives
+     */
+    PPTracker *tracker;
+
+    /** a _static_ list of file declarations
+     */
+    static PrologList file_list;
+
+    /** name of the current source file
+     */
+    std::string current_source_file;
+    
+    /** a list of top-level declarations for the current file
+     */
+    PrologList *current_declaration_list;
+    
+  public:
+    ASTTermDumper(const std::string &infilename,
+                  const std::string &outfilename,
+                  Preprocessor *pp)
+      : infile(infilename),
+        outfile(outfilename),
+        PP(pp),
+        tracker(NULL),
+        current_declaration_list(NULL) {
+      
+      //create and register a new PPTracker Object
+      assert(PP && "expecting a preprocessor object");
+      tracker = new PPTracker(*PP);
+     
+      //configure the preprocessor
+      PP->setPPCallbacks(tracker);
+    }
+
+    ~ASTTermDumper() {
+      PP->setPPCallbacks(NULL);
+    }
+
+    void Initialize(ASTContext &Context) {
+      SM = &Context.getSourceManager();
+    }
+
+  private:
+
+//     ////////////////////////////////////////////////////////
+//     // helper functions
+    
+    std::ostream&
+    get_output_stream() {
+      if (outfile.empty())
+        return std::cout;
+      else
+        return *new std::ofstream(outfile.c_str(), std::ofstream::app);
+    }
+
+    char
+    toLower(const char c) {
+      return (c - ('A'-'a'));
+    };
+
+    bool
+    isUpper(const char c) {
+      return (('A' <= c) && ('Z' >= c));
+    }
+    
+    std::string
+    prologize(std::string s) {
+      std::string t;
+      std::string::iterator it;
+      it = s.begin();
+
+      // skip all leading '_'
+      while (*it == '_')
+        it++;
+
+      //lowercase first char (without prepending underscore)
+      if(it != s.end()) {
+        if(isUpper(*it)) {
+          t.push_back(toLower(*it));
+        } else {
+          t.push_back(*it);
+        }
+        it++;
+      }
+
+      //replace an uppercase letter with an underscore
+      //and its lowercase equivalent
+      while(it != s.end()) {
+        if(*it == ' ')
+          t.push_back('_');
+        else if(isUpper(*it)) {
+          t.push_back('_');
+          t.push_back(toLower(*it));
+        } else {
+          t.push_back(*it);
+        }
+        it++;
+      }
+      return t;
+    }
+
+    static std::string escape(std::string s) {
+      std::string r;
+      for (unsigned int i = 0; i < s.length(); ++i) {
+        unsigned char c = s[i];
+        switch (c) {
+        case '\\': r += "\\\\"; break; // Literal backslash
+        case '\"': r += "\\\""; break; // Double quote
+        case '\'': r += "\\'"; break;  // Single quote
+        case '\n': r += "\\n"; break;  // Newline (line feed)
+        case '\r': r += "\\r"; break;  // Carriage return
+        case '\b': r += "\\b"; break;  // Backspace
+        case '\t': r += "\\t"; break;  // Horizontal tab
+        case '\f': r += "\\f"; break;  // Form feed
+        case '\a': r += "\\a"; break;  // Alert (bell)
+        case '\v': r += "\\v"; break;  // Vertical tab
+        default:
+          if (c < 32 || c > 127) {
+            std::stringstream strm;
+            strm << '\\' 
+                 << std::oct 
+                 << std::setfill('0') 
+                 << std::setw(3) 
+                 << (unsigned int)c // \nnn Character with octal value nnn
+                 << '\\'; // Prolog expects this weird syntax with a
+            // trailing backslash
+            r += strm.str();
+          } else {
+            r += c;
+          }
+        }
+      }
+      //cerr<<"escape("<<s<<") = "<< r <<endl;
+      return r;
+    }
+    
+
+    static std::string escape_double(std::string s) {
+      std::string r;
+      for (unsigned int i = 0; i < s.length(); ++i) {
+        unsigned char c = s[i];
+        switch (c) {
+        case '\\': r += "\\\\"; break; // Literal backslash
+        case '\"': r += "\\\\\""; break; // Double quote
+        case '\'': r += "\\\\'"; break;  // Single quote
+        case '\n': r += "\\\\n"; break;  // Newline (line feed)
+        case '\r': r += "\\\\r"; break;  // Carriage return
+        case '\b': r += "\\\\b"; break;  // Backspace
+        case '\t': r += "\\\\t"; break;  // Horizontal tab
+        case '\f': r += "\\\\f"; break;  // Form feed
+        case '\a': r += "\\\\a"; break;  // Alert (bell)
+        case '\v': r += "\\\\v"; break;  // Vertical tab
+        default:
+          if (c < 32 || c > 127) {
+            std::stringstream strm;
+            strm << "\\\\" 
+                 << std::oct 
+                 << std::setfill('0') 
+                 << std::setw(3) 
+                 << (unsigned int)c // \nnn Character with octal value nnn
+                 << "\\\\"; // Prolog expects this weird syntax with a
+            // trailing backslash
+            r += strm.str();
+          } else {
+            r += c;
+          }
+        }
+      }
+      //cerr<<"escape_double("<<s<<") = "<< r <<endl;
+      return r;
+    }
+
+    static std::string
+    filter_string(std::string s) {
+      std::stringstream S;
+      for (unsigned int i = 0; i < s.length(); ++i) {
+        unsigned char c = s[i];
+        if(isalnum(c) || c == '_')
+          S << c;
+        else if (c == '.')
+          S << "_dot_";
+      }      
+      return S.str();
+    }
+
+    
+    PrologTerm *
+    make_identifier_atom(const Decl *D, const char* prefix = "") {
+      const NamedDecl *V;
+      const IdentifierInfo *I;    
+      assert(D && "identifier information expected");
+      std::string s(prefix);
+
+      if((V = cast<NamedDecl>(D)) != NULL && (I = V->getIdentifier()) != NULL){
+        s += I->getName();
+      }
+      else {
+        std::ostringstream O;
+        std::string kind(D->getDeclKindName());
+        std::transform(kind.begin(), kind.end(), kind.begin(), tolower);      
+        O << "__anonymous_" << kind << "_decl";
+
+        //do we have source information?
+        const SourceLocation Loc = D->getLocation();
+        SourceLocation SpellingLoc = SM->getSpellingLoc(Loc);
+        if(!SpellingLoc.isInvalid()) {
+          PresumedLoc PLoc = SM->getPresumedLoc(SpellingLoc);
+          std::string file(std::string("/") +  PLoc.getFilename());
+          file = file.substr(file.rfind("/") + 1);
+          std::transform(file.begin(), file.end(), file.begin(), tolower);
+          O << "_" << filter_string(file) << "_" << PLoc.getLine() << "_" << PLoc.getColumn();
+        }
+        O << "_" << D;
+        s+= O.str();
+      }
+      return make_atom(s);
+    }
+
+    const Decl *
+    get_type_decl(const Type *T) const {
+      switch (T->getTypeClass()) {
+      case Type::Tagged: 
+        if (const RecordType *RT = dyn_cast<RecordType>(T)) {
+          return  RT->getDecl();
+        }
+        else if (const EnumType *ET = dyn_cast<EnumType>(T)) {
+          return ET->getDecl();
+        }
+        else assert(0 && "Unknown Tagged Type");
+      default:
+        return NULL;
+      }
+    }
+
+    const QualType
+    get_qualified_type(const Decl *D) const {
+      QualType type(NULL, 0);
+
+      if (const VarDecl *V = dyn_cast<VarDecl>(D))
+        type = V->getType();
+      else if (const EnumConstantDecl *E = dyn_cast<EnumConstantDecl>(D))
+        type = E->getType();
+      else if (const FunctionDecl *F = dyn_cast<FunctionDecl>(D))
+        type = F->getType();
+      else if (const FieldDecl *F = dyn_cast<FieldDecl>(D))
+        type = F->getType();
+      else
+        assert(0 && "Unknown decl type!");
+
+      return type;
+    }
+
+    
+    std::string
+    get_builtin_type_name(const BuiltinType &T) {
+      switch (T.getKind()) {
+      case BuiltinType::Char_U:    return "unsigned_char";
+      case BuiltinType::UChar:     return "unsigned_char";
+      case BuiltinType::UShort:    return "unsigned_short";
+      case BuiltinType::UInt:      return "unsigned_int";
+      case BuiltinType::ULong:     return "unsigned_long";
+      case BuiltinType::ULongLong: return "unsigned_long_long";
+      case BuiltinType::Char_S:    return "char";
+      case BuiltinType::SChar:     return "char";
+      case BuiltinType::WChar:     return "wchar";
+      case BuiltinType::Short:     return "short";
+      case BuiltinType::Int:       return "int";
+      case BuiltinType::Long:      return "long_int";
+      case BuiltinType::LongLong:  return "long_long_int";
+      default:
+        assert(0 && "cannot handle given builtin type");
+      }
+    }
+
+    
+    PrologAtom *
+    make_atom(std::string s) {
+      return new PrologAtom(s);
+    }
+
+    PrologAtom *
+    make_quoted_atom(std::string s) {
+      return new PrologAtom(s, true);
+    }
+    
+    PrologAtom *
+    make_null_atom() {
+      return make_atom("null");
+    }
+
+    
+    PrologAtom *
+    make_default_atom() {
+      return make_atom("default");
+    }
+
+    
+    PrologInt *
+    make_int(int v) {
+      return new PrologInt(v);
+    }
+
+    
+    PrologList *
+    make_list(size_t n, ...) {
+      PrologList *L = new PrologList();
+      va_list params;
+      va_start(params, n);
+      for (size_t i=0; i < n; i++)
+        L->addElement(va_arg(params, PrologTerm *));
+      va_end(params);
+      return L;
+    }
+
+    PrologTerm *
+    make_file_info() {
+      return new PrologCompTerm("file_info", 3,
+                                make_atom("NULL_FILE"),
+                                make_int(0),
+                                make_int(0));
+    }
+
+    PrologTerm *
+    make_file_info(const SourceLocation Loc) {
+      SourceLocation L = SM->getInstantiationLoc(Loc);
+      if (L.isInvalid()) {
+        return make_file_info();
+      }
+      else {
+        PresumedLoc PLoc = SM->getPresumedLoc(L);
+        assert(PLoc.isValid() && "encountered invalid presumed location");
+        return new PrologCompTerm("file_info", 3,
+                                  make_atom(PLoc.getFilename()),
+                                  make_int(PLoc.getLine()),
+                                  make_int(PLoc.getColumn()));
+      }
+    }
+
+    PrologTerm *
+    make_file_info(const std::string &file_name) {
+      assert(file_name.size() > 0 && "invalid file name");
+      return new PrologCompTerm("file_info", 3,
+                                make_atom(file_name),
+                                make_int(0),
+                                make_int(0));
+    }
+
+    PrologTerm *
+    make_file_info(const Stmt *S) {
+      if (!S)
+        return make_file_info();
+      else
+        return make_file_info(S->getSourceRange().getBegin());
+    }
+
+    
+    PrologTerm *
+    make_file_info(const Decl *D) {
+      if (!D)
+        return make_file_info();
+      else
+        return make_file_info(D->getLocation());
+    }
+    
+    PrologTerm *
+    make_preprocessing_info() {
+      return new PrologCompTerm("preprocessing_info", 1,
+                                new PrologList());
+    }
+
+    
+    PrologTerm *
+    make_preprocessing_info(SourceLocation loc) {
+      std::list<PPTracker::PPDirective> L;
+      tracker->dequeueDirectives(loc, L);
+      return make_preprocessing_info(L);
+    }
+
+    
+    PrologTerm *
+    make_preprocessing_info(std::list<PPTracker::PPDirective> &L) {
+      PrologList *ppi_list = new PrologList();
+
+      while(!L.empty()) {
+        PPTracker::PPDirective &d = L.front();
+        std::string term_name;
+        switch(d.type) {
+        case PPTracker::ppd_include:
+          term_name = "cpreprocessorIncludeDeclaration";
+          break;
+        case PPTracker::ppd_undef:
+          term_name = "cpreprocessorUndefDeclaration";
+          break;
+        default:
+          assert(0 && "not yet supported");          
+        }
+
+        ppi_list->addElement(new PrologCompTerm(term_name, 3,
+                                               make_atom(d.code + "\\n"),
+                                               make_atom("before"),
+                                               make_file_info(d.loc)));
+        L.pop_front();
+      }
+      
+      return new PrologCompTerm("preprocessing_info", 1, ppi_list);
+    }
+
+    
+    PrologTerm *
+    make_default_analysis_info() {
+      return new PrologCompTerm("analysis_info", 1, new PrologList());
+    }
+
+    
+    PrologTerm *
+    make_default_annotation() {
+      return new PrologCompTerm("default_annotation", 2,
+                                make_null_atom(),
+                                make_preprocessing_info());
+    }
+
+    
+    PrologTerm *
+    make_static_attribute(const Decl *D) {
+      const VarDecl *V = dyn_cast<VarDecl>(D);
+      const FunctionDecl *F = dyn_cast<FunctionDecl>(D);
+      bool isStatic = (V && V->getStorageClass() == VarDecl::Static) ||
+        (F && F->getStorageClass() == FunctionDecl::Static);
+      if(isStatic)
+        return make_atom("static");
+      else
+        return make_atom("default");
+    }
+    
+
+    PrologTerm *
+    make_file_term() {
+      assert(current_declaration_list && !current_source_file.empty() && "expecting current file");
+
+      return new PrologCompTerm("source_file", 4,
+                                new PrologCompTerm("global", 4,
+                                                   current_declaration_list,
+                                                   make_default_annotation(),
+                                                   make_default_analysis_info(),
+                                                   make_file_info(current_source_file)),
+                                new PrologCompTerm("default_annotation", 1,
+                                                   make_null_atom()),
+                                make_default_analysis_info(),
+                                make_file_info(current_source_file));
+    }
+    
+    
+    PrologTerm *
+    make_project_term() {
+      return new PrologCompTerm("project", 4,
+                                &file_list,
+                                new PrologCompTerm("default_annotation", 1,
+                                                   make_null_atom()),
+                                make_default_analysis_info(),
+                                make_file_info());
+    }
+    
+    ////////////////////////////////////////////////////////
+    // modifier
+
+    PrologTerm *
+    make_access_modifier(const Decl *D) {
+      switch (D->getAccess()) {
+      case AS_none:      return make_atom("default");
+      case AS_public:    return make_atom("public");
+      case AS_protected: return make_atom("protected");
+      case AS_private:   return make_atom("private");
+      }
+      assert(0 && "should be never reached");
+    }
+
+
+    PrologTerm *
+    make_storage_modifier(const Decl *D) {
+      if (const VarDecl *V = dyn_cast<VarDecl>(D)) {
+        switch (V->getStorageClass()) {
+        case VarDecl::None:          return make_atom("unspecified");
+        case VarDecl::Extern:        return make_atom("extern");
+        case VarDecl::Static:        return make_atom("static");
+        case VarDecl::Auto:          return make_atom("auto");
+        case VarDecl::Register:      return make_atom("register");
+        case VarDecl::PrivateExtern: return make_atom("privateExtern");
+        }
+      }
+      else if (const FunctionDecl *F = dyn_cast<FunctionDecl>(D)) {
+        switch (F->getStorageClass()) {
+        case FunctionDecl::None:          return make_atom("unspecified");
+        case FunctionDecl::Extern:        return make_atom("extern");
+        case FunctionDecl::Static:        return make_atom("static");
+        case FunctionDecl::PrivateExtern: return make_atom("privateExtern");
+        }
+      }
+      else if (dyn_cast<FieldDecl>(D)) {
+        return make_atom("default");
+      }
+      assert(0 && "should be never reached");
+    }
+
+
+    PrologTerm *
+    make_type_modifier(const Decl *D) {
+      QualType type(get_qualified_type(D));
+      assert(!type.isNull());
+      return make_type_modifier(type);
+    }
+
+
+    PrologTerm *
+    make_type_modifier(const QualType &T) {
+      PrologList *arg0 = make_list(1, make_atom("default"));
+      if (T.isRestrictQualified())
+        arg0->addElement(make_atom("restrict"));
+
+      PrologAtom *arg1 = NULL, *arg2 = NULL, *arg3 = NULL;
+
+      arg1 = make_default_atom();
+
+      if(T.isConstQualified())
+        arg2 = make_atom("const");
+      else if (T.isVolatileQualified())
+        arg2 = make_atom("volatile");
+      else
+        arg2 = make_default_atom();
+
+      if (T->isClassType())
+        arg3 = make_atom("class");
+      else if (T->isStructureType())
+        arg3 = make_atom("struct");
+      else if (T->isUnionType())
+        arg3 = make_atom("union");
+      else if (T->isEnumeralType())
+        arg3 = make_atom("enum");
+      else if (T->isTemplateTypeParmType())
+        arg3 = make_atom("typename");
+      else
+        arg3 = make_default_atom();
+
+      return new PrologCompTerm("type_modifier", 4, arg0, arg1, arg2, arg3);
+    }
+
+
+    PrologTerm *
+    make_declaration_modifier(const Decl *D) {
+      return new PrologCompTerm("declaration_modifier", 4,
+                                make_list(1, make_default_atom()),
+                                make_type_modifier(D),
+                                make_access_modifier(D),
+                                make_storage_modifier(D));
+    }
+
+    
+    ////////////////////////////////////////////////////////
+    // declarations
+
+    PrologTerm *
+    make_declaration_context(const DeclContext *C) {
+      switch (C->getDeclKind()) {
+      case Decl::Namespace:
+        return make_identifier_atom(cast<NamespaceDecl>(C));
+      case Decl::Record:
+        if (const RecordDecl *RD = dyn_cast<RecordDecl>(C)) {
+          if(RD->getKind() == Decl::Enum && !RD->getIdentifier()) {
+            //mimic the bahaviour of the ROSE implementation here
+            return make_atom("::");
+          }
+          else {
+            return new PrologCompTerm("class_scope", 2,
+                                      make_identifier_atom(RD, "::"),
+                                      make_atom(RD->getKindName()));
+          }
+        }
+        break;
+      default:
+        return make_null_atom();
+      }
+      assert(0 && "should be never reached");
+    }
+    
+    PrologTerm *
+    make_declaration_attributes(const Decl *D) {
+      //TODO: check what goes here
+      return new PrologCompTerm("decl_attributes", 5,
+                                make_int(0),
+                                make_int(0),
+                                make_int(0),
+                                make_int(0),
+                                make_int(0));
+    }
+
+    
+    PrologTerm *
+    make_typedef_declaration_term(const Decl *D) {
+      const TypedefDecl *TD = cast<TypedefDecl>(D);
+
+      const Decl* UD = get_type_decl(TD->getUnderlyingType().getTypePtr());
+      
+      return new PrologCompTerm("typedef_declaration", 4,
+                                (UD ? make_declaration_term(UD) : make_null_atom()),
+                                new PrologCompTerm("typedef_annotation", 4,
+                                                   make_identifier_atom(D),
+                                                   make_type_term(TD->getUnderlyingType()),
+                                                   (UD ? make_declaration_term(UD) : make_null_atom()),
+                                                   make_preprocessing_info(TD->getLocation())),
+                                make_default_analysis_info(),
+                                make_file_info(TD));
+    }
+
+    
+    PrologTerm *
+    make_enum_declaration_term(const Decl *D) {
+      const EnumDecl *E = cast<EnumDecl>(D);
+
+      PrologList *fields = new PrologList();
+      EnumDecl::enumerator_iterator i, ie;
+      for(i = E->enumerator_begin(), ie = E->enumerator_end(); i != ie; i++)
+        fields->addElement(make_initialized_name_declaration_term(*i));
+
+      return new PrologCompTerm("enum_declaration", 4,
+                                fields,
+                                new PrologCompTerm("enum_declaration_annotation", 3,
+                                                   make_identifier_atom(E),
+                                                   make_declaration_attributes(D),
+                                                   make_int(1)),
+                                make_default_analysis_info(),
+                                make_file_info(D));
+    }
+
+
+    PrologTerm *
+    make_record_declaration_term(const Decl *D) {
+      const RecordDecl *R = cast<RecordDecl>(D);
+
+      PrologList *fields = new PrologList();
+      RecordDecl::field_iterator i, ie;
+      for(i=R->field_begin(), ie = R->field_end(); i != ie; i++)
+        fields->addElement(make_field_declaration_term(*i));
+
+      return new PrologCompTerm("class_declaration", 4,
+                                new PrologCompTerm("class_definition", 4,
+                                                   fields,
+                                                   new PrologCompTerm("class_definition_annotation", 2,
+                                                                      make_file_info(D),
+                                                                      make_preprocessing_info()),
+                                                   make_default_analysis_info(),
+                                                   make_file_info(D)),
+                                new PrologCompTerm("class_declaration_annotation", 4,
+                                                   make_identifier_atom(R),
+                                                   make_atom(R->getKindName()),
+                                                   new PrologCompTerm("class_type", 3,
+                                                                      make_identifier_atom(R),
+                                                                      make_atom(R->getKindName()),
+                                                                      make_atom("::")),
+                                                   make_preprocessing_info(D->getLocation())),
+                                make_default_analysis_info(),
+                                make_file_info(D));
+    }
+
+    
+    PrologTerm *
+    make_function_declaration_term(const Decl *D) {
+      const FunctionDecl *FD = cast<FunctionDecl>(D);
+      const FunctionType *AFT = FD->getType()->getAsFunctionType();
+
+      //parameter list
+      PrologList *parms = new PrologList();
+      if (const FunctionTypeProto *FT = dyn_cast<FunctionTypeProto>(AFT)) {
+        for (unsigned i = 0, e = FD->getNumParams(); i != e; ++i)
+          parms->addElement(make_declaration_term(FD->getParamDecl(i)));
+
+        if (FT->isVariadic()) {
+          parms->addElement(new PrologCompTerm("initialized_name", 4,
+                                               make_null_atom(),
+                                               new PrologCompTerm("initialized_name_annotation", 4,
+                                                                  make_atom("type_ellipse"),
+                                                                  make_atom(""),
+                                                                  make_atom("default"),
+                                                                  make_null_atom()),
+                                               make_default_analysis_info(),
+                                               make_file_info(D)));
+        }
+      }
+      
+      PrologTerm *parameter_list = new PrologCompTerm("function_parameter_list", 4,
+                                                      parms,
+                                                      make_default_annotation(),
+                                                      make_default_analysis_info(),
+                                                      make_file_info(FD));
+      
+      //collect all preprocessor declarations _before_ handling the function body
+      std::list<PPTracker::PPDirective> PPD;
+      tracker->dequeueDirectives(FD->getLocation(), PPD);
+
+      //create body
+      PrologTerm *body;
+      if (FD->isThisDeclarationADefinition()) {
+        body = new PrologCompTerm("function_definition", 4,
+                                  make_statement_term(FD->getBody()),
+                                  make_default_annotation(),
+                                  make_default_analysis_info(),
+                                  make_file_info(FD));
+      } else {
+        body = make_null_atom();
+      }
+
+      //create annotation
+      PrologTerm *annotation;
+      annotation = new PrologCompTerm("function_declaration_annotation", 4,
+                                      make_type_term(FD->getType()),
+                                      make_identifier_atom(FD),
+                                      make_declaration_modifier(D),
+                                      make_preprocessing_info(PPD));
+      
+      return new PrologCompTerm("function_declaration", 5,
+                                parameter_list,
+                                body,
+                                annotation,
+                                make_default_analysis_info(),
+                                make_file_info(FD));
+    }
+
+    
+    PrologTerm *
+    make_initializer_term(const Stmt *S) {
+      const Expr *E = dyn_cast<Expr>(S);
+      bool is_aggregate = E && (E->getType()->isRecordType() ||
+                                E->getType()->isArrayType());
+      if(is_aggregate && InitListExpr::classof(S)) {
+        return new PrologCompTerm("aggregate_initializer", 4,
+                                  make_statement_term(S),
+                                  make_default_annotation(),
+                                  make_default_analysis_info(),
+                                  make_file_info(S));
+      }
+      else {
+        PrologTerm *type_term = E ? make_type_term(E->getType()) : make_null_atom();
+        
+        return new PrologCompTerm("assign_initializer", 4,
+                                  make_statement_term(S),
+                                  new PrologCompTerm("assign_initializer_annotation", 2,
+                                                     type_term,
+                                                     make_preprocessing_info()),
+                                  make_default_analysis_info(),
+                                  make_file_info(S));
+      }
+    }
+
+    
+    PrologTerm *
+    make_initialized_name_declaration_term(const Decl *D) {
+      const NamedDecl *V = cast<NamedDecl>(D);
+      const Expr* init = NULL;
+      QualType type(get_qualified_type(V));
+      if (VarDecl::classof(V)) {
+        const VarDecl *VD = cast<VarDecl>(V);
+        init = VD->getInit();
+      }
+      else if (EnumConstantDecl::classof(V)) {
+        const EnumConstantDecl *ED = cast<EnumConstantDecl>(V);
+        init = ED->getInitExpr();
+      }
+
+      PrologTerm *initializer_term;
+      if (init)
+        initializer_term = make_initializer_term(init);
+      else
+        initializer_term = make_null_atom();
+
+      PrologTerm *type_term;
+      if (type.isNull())
+        type_term = make_null_atom();
+      else
+        type_term = make_type_term(type);
+      
+      return new PrologCompTerm("initialized_name", 4,
+                                initializer_term,
+                                new PrologCompTerm("initialized_name_annotation", 4,
+                                                   type_term,
+                                                   make_identifier_atom(D),
+                                                   make_static_attribute(V),
+                                                   make_declaration_context(V->getDeclContext())),
+                                make_default_analysis_info(),
+                                make_file_info(D));
+    }
+
+    PrologTerm * make_variable_declaration_term(const Decl *D) {
+      PrologCompTerm *specifics = new PrologCompTerm("variable_declaration_specific");
+      specifics->addSubterm(make_declaration_modifier(D));
+      specifics->addSubterm(make_null_atom()); // FIXME: base type definition
+      if(D->getKind() == Decl::Var)
+        specifics->addSubterm(make_preprocessing_info(D->getLocation()));
+      else
+        specifics->addSubterm(make_preprocessing_info());
+      
+      return new PrologCompTerm("variable_declaration", 4,
+                                make_list(1, make_initialized_name_declaration_term(D)),
+                                specifics,
+                                make_default_analysis_info(),
+                                make_file_info(D));
+    }
+
+    
+    PrologTerm *
+    make_field_declaration_term(const Decl *D) {
+      return make_variable_declaration_term(D);
+    }
+
+    
+    PrologTerm *
+    make_declaration_term(const Decl *D) {
+      switch (D->getKind()) {
+      case Decl::Typedef:
+        return make_typedef_declaration_term(D);
+        break;
+      case Decl::Enum:
+        return make_enum_declaration_term(D);
+        break;
+      case Decl::Record:
+        return make_record_declaration_term(D);
+        break;
+      case Decl::Function:
+        return make_function_declaration_term(D);
+        break;
+      case Decl::ParmVar:
+        return make_initialized_name_declaration_term(D);
+        break;
+      case Decl::Field:
+        return make_field_declaration_term(D);
+        break;
+      case Decl::EnumConstant:
+      case Decl::Var:
+      case Decl::OriginalParmVar:
+      case Decl::ImplicitParam:
+        return make_variable_declaration_term(D);
+      default:
+        assert(0 && "not yet implemented");
+      }
+
+      assert(0 && "should be never reached");
+      return NULL;
+    }
+
+    ////////////////////////////////////////////////////////
+    // types
+    PrologTerm *
+    make_type_term(const QualType &T) {
+      PrologTerm *t = NULL;
+      
+      switch (T->getTypeClass()) {
+      case Type::Builtin:
+        t = make_atom(std::string("type_") + prologize(cast<BuiltinType>(T)->getName()));
+        break;
+
+      case Type::Pointer:
+        t = new PrologCompTerm("pointer_type", 1,
+                               make_type_term(cast<PointerLikeType>(T)->getPointeeType()));
+        break;
+
+      case Type::ConstantArray:
+      case Type::VariableArray:
+      case Type::IncompleteArray:
+      case Type::DependentSizedArray:
+        {
+          ArrayType *AT = cast<ArrayType>(T);
+          PrologTerm *arg2 = NULL;
+          switch (T->getTypeClass()) {
+          case Type::ConstantArray:
+            arg2 = new PrologCompTerm("unsigned_long_val", 4,
+                                      make_null_atom(),
+                                      new PrologCompTerm("value_annotation", 2,
+                                                         make_atom(cast<ConstantArrayType>(T)->getSize().toString(10, false)),
+                                                         make_preprocessing_info()),
+                                      make_default_analysis_info(),
+                                      make_file_info());
+            break;
+          case Type::VariableArray:
+            arg2 = make_statement_term(cast<VariableArrayType>(T)->getSizeExpr());
+            break;
+          case Type::DependentSizedArray:
+            arg2 = make_statement_term(cast<DependentSizedArrayType>(T)->getSizeExpr());
+            break;
+          case Type::IncompleteArray:
+            arg2 = make_null_atom();
+            break;
+          default:
+            assert(0 && "not yet implemented");
+          }
+
+          t = new PrologCompTerm("array_type", 2,
+                                 make_type_term(AT->getElementType()),
+                                 arg2);
+          break;
+        }
+
+      case Type::FunctionNoProto:
+        t = new PrologCompTerm("function_type", 3,
+                               make_type_term(cast<FunctionTypeNoProto>(T)->getResultType()),
+                               make_default_atom(),
+                               new PrologList());
+        break;
+        
+      case Type::FunctionProto:
+        { 
+          FunctionTypeProto *FT = cast<FunctionTypeProto>(T);
+          PrologList *args = new PrologList();
+          FunctionTypeProto::arg_type_iterator i, ie;
+          for(i = FT->arg_type_begin(), ie = FT->arg_type_end(); i != ie; i++)
+            args->addElement(make_type_term(*i));
+
+          if (FT->isVariadic())
+            args->addElement(make_atom("type_ellipse"));
+          
+          t  = new PrologCompTerm("function_type", 3,
+                                  make_type_term(FT->getResultType()),
+                                  make_atom(FT->isVariadic() ? "ellipses" : "default"),
+                                  args);
+          break;
+        }
+
+      case Type::TypeOfExp:
+        t = new PrologCompTerm("type_of_expr", 1,
+                               make_statement_term(cast<TypeOfExpr>(T)->getUnderlyingExpr()));
+        break;
+        
+      case Type::TypeOfTyp:
+        t = new PrologCompTerm("type_of_expr", 1,
+                               make_type_term(cast<TypeOfType>(T)->getUnderlyingType()));
+        break;
+                               
+      case Type::TypeName:
+        {
+          
+          TypedefType *TDT = cast<TypedefType>(T);
+          QualType Simplified = TDT->LookThroughTypedefs();
+          t = new PrologCompTerm("typedef_type", 2,
+                                 make_identifier_atom(TDT->getDecl()),
+                                 make_type_term(Simplified));
+          break;
+        }
+
+      case Type::Tagged:
+        if (RecordType *RT = dyn_cast<RecordType>(T))
+          t = new PrologCompTerm("class_type", 3,
+                                 make_identifier_atom(RT->getDecl()),
+                                 make_atom(RT->getDecl()->getKindName()),
+                                 make_atom("::"));
+        else if (EnumType *ET = dyn_cast<EnumType>(T))
+          t = new PrologCompTerm("enum_type", 1,
+                                 make_declaration_term(ET->getDecl()));
+        else
+          assert(0 && "not yet implemented");
+        break;
+
+      case Type::Reference:
+        assert(0 && "not yet implemented");
+        
+      default:
+        assert(0 && "should be never reached");
+      }
+
+      if (T.getCVRQualifiers())
+        t = new PrologCompTerm("modifier_type", 2,
+                               t,
+                               make_type_modifier(T));
+      return t;
+    }
+    
+    
+    ////////////////////////////////////////////////////////
+    // statements and expressions
+
+    PrologTerm *
+    make_unary_operator_expr(const Stmt *S) {
+      const UnaryOperator* UO = cast<UnaryOperator>(S);
+      
+      std::string op;
+      switch (UO->getOpcode()) {
+      case UnaryOperator::PostInc:   op = "plus_plus_op";      break;
+      case UnaryOperator::PostDec:   op = "minus_minus_op";    break;
+      case UnaryOperator::PreInc:    op = "plus_plus_op";      break;
+      case UnaryOperator::PreDec:    op = "minus_minus_op";    break;
+      case UnaryOperator::AddrOf:    op = "address_of_op";     break;
+      case UnaryOperator::Deref:     op = "pointer_deref_exp"; break;
+      case UnaryOperator::Plus:      op = "plus_op";           break;
+      case UnaryOperator::Minus:     op = "minus_op";          break;
+      case UnaryOperator::Not:       op = "bit_complement_op"; break;
+      case UnaryOperator::LNot:      op = "not_op";            break;
+      case UnaryOperator::Real:      op = "real_op";           break;
+      case UnaryOperator::Imag:      op = "imag_op";           break;
+      case UnaryOperator::Extension: op = "extension_op";      break;
+      case UnaryOperator::OffsetOf:  op = "offset_op";         break;
+      default:
+        assert(0 && "should be never reached");
+      }
+
+      return new PrologCompTerm(op, 4,
+                                make_statement_term(UO->getSubExpr()),
+                                new PrologCompTerm("unary_op_annotation", 5,
+                                                   make_atom(UO->isPostfix() ? "postfix" : "prefix"),
+                                                   make_type_term(UO->getType()),
+                                                   make_null_atom(),
+                                                   make_null_atom(),
+                                                   make_preprocessing_info()),
+                                make_default_analysis_info(),
+                                make_file_info(UO));
+    }
+
+    
+    PrologTerm *    
+    make_binary_operator_expr(const Stmt *S) {
+      const BinaryOperator* BO = cast<BinaryOperator>(S);
+
+      std::string op;
+      switch (BO->getOpcode()) {
+      case BinaryOperator::Mul:       op =         "multiply_op"; break;
+      case BinaryOperator::Div:       op =           "divide_op"; break;
+      case BinaryOperator::Rem:       op =              "mod_op"; break;
+      case BinaryOperator::Add:       op =              "add_op"; break;
+      case BinaryOperator::Sub:       op =         "subtract_op"; break;
+      case BinaryOperator::Shl:       op =           "lshift_op"; break;
+      case BinaryOperator::Shr:       op =           "rshift_op"; break;
+      case BinaryOperator::LT:        op =        "less_than_op"; break;
+      case BinaryOperator::GT:        op =     "greater_than_op"; break;
+      case BinaryOperator::LE:        op =    "less_or_equal_op"; break;
+      case BinaryOperator::GE:        op = "greater_or_equal_op"; break;
+      case BinaryOperator::EQ:        op =         "equality_op"; break;
+      case BinaryOperator::NE:        op =        "not_equal_op"; break;
+      case BinaryOperator::And:       op =          "bit_and_op"; break;
+      case BinaryOperator::Xor:       op =          "bit_xor_op"; break;
+      case BinaryOperator::Or:        op =           "bit_or_op"; break;
+      case BinaryOperator::LAnd:      op =              "and_op"; break;
+      case BinaryOperator::LOr:       op =               "or_op"; break;
+      case BinaryOperator::Assign:    op =           "assign_op"; break;
+      case BinaryOperator::MulAssign: op =      "mult_assign_op"; break;
+      case BinaryOperator::DivAssign: op =       "div_assign_op"; break;
+      case BinaryOperator::RemAssign: op =       "mod_assign_op"; break;
+      case BinaryOperator::AddAssign: op =      "plus_assign_op"; break;
+      case BinaryOperator::SubAssign: op =     "minus_assign_op"; break;
+      case BinaryOperator::ShlAssign: op =    "lshift_assign_op"; break;
+      case BinaryOperator::ShrAssign: op =    "rshift_assign_op"; break;
+      case BinaryOperator::AndAssign: op =       "and_assign_op"; break;
+      case BinaryOperator::XorAssign: op =       "xor_assign_op"; break;
+      case BinaryOperator::OrAssign:  op =       "ior_assign_op"; break;
+      case BinaryOperator::Comma:     op =        "comma_op_exp"; break;
+      default:
+        assert(0 && "should be never reached");
+      }
+
+      return new PrologCompTerm(op, 5,
+                                make_statement_term(BO->getLHS()),
+                                make_statement_term(BO->getRHS()),
+                                new PrologCompTerm("binary_op_annotation", 2,
+                                                   make_type_term(BO->getType()),
+                                                   make_preprocessing_info()),
+                                make_default_analysis_info(),
+                                make_file_info(BO));
+    }
+
+    
+    PrologTerm *    
+    make_var_ref_expr(const Decl *D, const QualType &T, const Stmt *SL) {
+      return new PrologCompTerm("var_ref_exp", 3,
+                                new PrologCompTerm("var_ref_exp_annotation", 5,
+                                                   make_type_term(T),
+                                                   make_identifier_atom(D),
+                                                   make_static_attribute(D),
+                                                   make_declaration_context(D->getDeclContext()),
+                                                   make_preprocessing_info()),
+                                make_default_analysis_info(),
+                                make_file_info(SL));
+    }
+
+
+    PrologTerm *
+    make_va_start_expr(const CallExpr *CE) {
+      assert(CE->getNumArgs() == 2 && "unexpected va_start call");
+      const Expr *ap_arg = CE->getArg(0);
+      const Expr *last_arg = CE->getArg(1);
+      return new PrologCompTerm("var_arg_start_op", 5,
+                                make_statement_term(ap_arg),
+                                make_statement_term(last_arg),
+                                new PrologCompTerm("vararg_annotation", 2,
+                                                   make_atom("type_default"),
+                                                   make_preprocessing_info()),
+                                make_default_analysis_info(),
+                                make_file_info(CE));
+    }
+
+
+    PrologTerm *
+    make_va_arg_expr(const Stmt *S) {
+      const VAArgExpr *VAE = cast<VAArgExpr>(S);
+      return new PrologCompTerm("var_arg_op", 4,
+                                make_statement_term(VAE->getSubExpr()),
+                                new PrologCompTerm("vararg_annotation", 2,
+                                                   make_type_term(VAE->getType()),
+                                                   make_preprocessing_info()),
+                                make_default_analysis_info(),
+                                make_file_info(VAE));
+    }
+
+    
+    PrologTerm *
+    make_va_end_expr(const CallExpr *CE) {
+      assert(CE->getNumArgs() == 1 && "unexpected va_end call");
+      const Expr *ap_arg = CE->getArg(0);
+      return new PrologCompTerm("var_arg_end_op", 4,
+                                make_statement_term(ap_arg),
+                                new PrologCompTerm("vararg_annotation", 2,
+                                                   make_atom("type_default"),
+                                                   make_preprocessing_info()),
+                                make_default_analysis_info(),
+                                make_file_info(CE));
+    }
+
+
+    PrologTerm *
+    make_va_copy_expr(const CallExpr *CE) {
+      assert(CE->getNumArgs() == 2 && "unexpected va_copy call");
+      const Expr *dest_arg = CE->getArg(0);
+      const Expr *src_arg = CE->getArg(1);
+      return new PrologCompTerm("var_arg_copy_op", 5,
+                                make_statement_term(dest_arg),
+                                make_statement_term(src_arg),
+                                new PrologCompTerm("vararg_annotation", 2,
+                                                   make_atom("type_default"),
+                                                   make_preprocessing_info()),
+                                make_default_analysis_info(),
+                                make_file_info(CE));
+    }
+
+
+    PrologTerm *    
+    make_builtin_callee_term(const Expr *CE) {
+      // All simple function calls (e.g. func()) are implicitly cast to pointer to
+      // function. As a result, we try and obtain the DeclRefExpr from the 
+      // ImplicitCastExpr.
+      const ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(CE);
+      assert(ICE && "expecting dyn_cast here");
+      const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(ICE->getSubExpr());
+      assert(DRE && "can't find DeclRefExpr");
+      const FunctionDecl *FDecl = dyn_cast<FunctionDecl>(DRE->getDecl());
+      assert(FDecl && FDecl->getIdentifier() && "can't find FunctionDecl");
+      return make_atom(FDecl->getIdentifier()->getName());
+    }
+
+    
+    PrologTerm *
+    make_statement_term(const Stmt *S) {
+      
+      enum cast_kind_t {
+        ck_undef,
+        ck_implicit,
+        ck_c_style,
+        ck_const,
+        ck_static,
+        ck_dynamic,
+        ck_reinterpret
+      };
+      cast_kind_t castKind = ck_undef;
+
+      if(!S)
+        return new PrologCompTerm("null_expression", 3,
+                                  make_default_annotation(),
+                                  make_default_analysis_info(),
+                                  make_file_info(S));
+      
+      switch (S->getStmtClass()) {
+      case Stmt::NullStmtClass:
+        {
+          return new PrologCompTerm("null_statement", 3,
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+
+      case Stmt::CompoundStmtClass:
+        {
+          const CompoundStmt *CS = cast<CompoundStmt>(S);
+          PrologList *stmts = new PrologList();
+          CompoundStmt::const_body_iterator i, ie;
+          for(i = CS->body_begin(), ie = CS->body_end(); i != ie; i++) {
+            const Stmt *S = *i;
+            //if this is a DeclStmt, emit all declarations separately
+            if(S->getStmtClass() == Stmt::DeclStmtClass) {
+              const DeclStmt *DS = cast<DeclStmt>(S);
+              for(DeclStmt::const_decl_iterator d = DS->decl_begin(), de = DS->decl_end(); d != de; ++d)
+                stmts->addElement(make_declaration_term(*d));
+            }
+            //a LabelStmt might have a sub-statement
+            else if(S->getStmtClass() == Stmt::LabelStmtClass) {
+              stmts->addElement(make_statement_term_wrapped(S));
+              const Stmt *sub = cast<LabelStmt>(S)->getSubStmt();
+              if(sub->getStmtClass() != Stmt::NullStmtClass)
+                stmts->addElement(make_statement_term_wrapped(sub));
+            }
+            else {
+              stmts->addElement(make_statement_term_wrapped(S));
+            }
+          }
+          return new PrologCompTerm("basic_block",4,
+                                    stmts,
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+
+      case Stmt::CaseStmtClass:
+        {
+          const CaseStmt *CS = cast<CaseStmt>(S);
+          assert(!CS->getRHS() && "GNU extension for case not supported.\n");
+
+          return new PrologCompTerm("case_option_stmt", 6,
+                                    make_statement_term(CS->getLHS()),
+                                    make_statement_term_wrapped(CS->getSubStmt()),
+                                    make_null_atom(),
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(CS));
+        }
+
+      case Stmt::DefaultStmtClass:
+        {
+          const DefaultStmt *DS = cast<DefaultStmt>(S);
+          return new PrologCompTerm("default_option_stmt", 4,
+                                    make_statement_term_wrapped(DS->getSubStmt()),
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(DS));
+        }
+
+      case Stmt::LabelStmtClass:
+        {
+          const LabelStmt *L = cast<LabelStmt>(S);
+          //The caller is responsible to dump a sub-statement if there is one
+          return new PrologCompTerm("label_statement", 3,
+                                    new PrologCompTerm("label_annotation", 2,
+                                                       make_atom(L->getName()),
+                                                       make_preprocessing_info()),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+
+      case Stmt::IfStmtClass:
+        {
+          const IfStmt *IFS = cast<IfStmt>(S);
+
+          PrologTerm *else_term;
+          if(IFS->getElse())
+            else_term = make_statement_term_wrapped(IFS->getElse());
+          else
+            else_term = make_null_atom();
+          
+          return new PrologCompTerm("if_stmt", 6,
+                                    make_statement_term_wrapped(IFS->getCond()),
+                                    make_statement_term_wrapped(IFS->getThen()),
+                                    else_term,
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(IFS));
+        }
+
+      case Stmt::SwitchStmtClass:
+        {
+          const SwitchStmt *SS = cast<SwitchStmt>(S);
+
+          return new PrologCompTerm("switch_statement", 5,
+                                    make_statement_term_wrapped(SS->getCond()),
+                                    make_statement_term(SS->getBody()),
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(SS));
+        }
+
+      case Stmt::WhileStmtClass:
+        {
+          const WhileStmt *WS = cast<WhileStmt>(S);
+          return new PrologCompTerm("while_stmt", 5,
+                                    make_statement_term_wrapped(WS->getCond()),
+                                    make_statement_term_wrapped(WS->getBody()),
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(WS));
+        }
+
+      case Stmt::DoStmtClass:
+        {
+          const DoStmt *DS = cast<DoStmt>(S);
+          return new PrologCompTerm("do_while_stmt", 5,
+                                    make_statement_term_wrapped(DS->getBody()),
+                                    make_statement_term_wrapped(DS->getCond()),
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(DS));
+        }
+
+      case Stmt::ForStmtClass:
+        {
+          const ForStmt *FS = cast<ForStmt>(S);
+
+          PrologList *init_stmt = new PrologList();
+          if(const Stmt *S = FS->getInit()) {
+            //if this is a DeclStmt, emit all declarations separately
+            if(S->getStmtClass() == Stmt::DeclStmtClass) {
+              const DeclStmt *DS = cast<DeclStmt>(S);
+              for(DeclStmt::const_decl_iterator d = DS->decl_begin(), de = DS->decl_end(); d != de; ++d)
+                init_stmt->addElement(make_declaration_term(*d));
+            }
+            //a LabelStmt might have a sub-statement
+            else if(S->getStmtClass() == Stmt::LabelStmtClass) {
+              init_stmt->addElement(make_statement_term_wrapped(S));
+              const Stmt *sub = cast<LabelStmt>(S)->getSubStmt();
+              if(sub->getStmtClass() != Stmt::NullStmtClass)
+                init_stmt->addElement(make_statement_term_wrapped(sub));
+            }
+            else {
+              init_stmt->addElement(make_statement_term_wrapped(S));
+            }
+          }
+          
+          return new PrologCompTerm("for_statement", 7,
+                                    new PrologCompTerm("for_init_statement", 4,
+                                                       init_stmt,
+                                                       make_default_annotation(),
+                                                       make_default_analysis_info(),
+                                                       make_file_info(FS)),
+                                    make_statement_term_wrapped(FS->getCond()),
+                                    make_statement_term(FS->getInc()),
+                                    make_statement_term_wrapped(FS->getBody()),
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(FS));
+        }
+
+      case Stmt::GotoStmtClass:
+        {
+          return new PrologCompTerm("goto_statement", 3,
+                                    new PrologCompTerm("label_annotation", 2,
+                                                       make_atom(cast<GotoStmt>(S)->getLabel()->getName()),
+                                                       make_preprocessing_info()),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+
+      case Stmt::ContinueStmtClass:
+        {
+          return new PrologCompTerm("continue_stmt", 3,
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+        
+      case Stmt::BreakStmtClass:
+        {
+          return new PrologCompTerm("break_stmt", 3,
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+
+      case Stmt::ReturnStmtClass:
+        {
+          const ReturnStmt *RS = cast<ReturnStmt>(S);
+          
+          return new PrologCompTerm("return_stmt", 4,
+                                    make_statement_term(RS->getRetValue()),
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(RS));
+        }
+
+      case Stmt::DeclStmtClass:
+        assert(0 && "this should be handled elsewhere");
+        
+      case Stmt::DeclRefExprClass:
+        {
+          const DeclRefExpr *DRE = cast<DeclRefExpr>(S);
+          const Decl *D = DRE->getDecl();
+
+          switch (D->getKind()) {
+          case Decl::Function:
+            {
+              return new PrologCompTerm("function_ref_exp", 3,
+                                        new PrologCompTerm("function_ref_exp_annotation", 3,
+                                                           make_identifier_atom(D),
+                                                           make_type_term(cast<FunctionDecl>(D)->getType()),
+                                                           make_preprocessing_info()),
+                                        make_default_analysis_info(),
+                                        make_file_info(S));
+            }
+          case Decl::EnumConstant:
+            {
+              const EnumConstantDecl *ED = cast<EnumConstantDecl>(D);
+              const llvm::APSInt &val = ED->getInitVal();
+              return new PrologCompTerm("int_val", 4,
+                                        make_null_atom(),
+                                        new PrologCompTerm("value_annotation", 2,
+                                                           make_atom(val.toString(10)),
+                                                           make_preprocessing_info()),
+                                        make_default_analysis_info(),
+                                        make_file_info(S));
+            }
+
+          case Decl::Var:
+          case Decl::OriginalParmVar:
+          case Decl::ImplicitParam:
+          case Decl::ParmVar:
+            {
+              return make_var_ref_expr(D, DRE->getType(), DRE);
+            }
+            
+          default:
+            assert(0 && "cannot handle declaration in DeclRefExpr");
+          }
+        }
+          
+        break;
+
+      case Stmt::IntegerLiteralClass:
+        {
+          const IntegerLiteral *IL = cast<IntegerLiteral>(S);
+          const BuiltinType *ILT = cast<BuiltinType>(IL->getType());
+          bool isSigned = ILT->isSignedIntegerType();
+
+          return new PrologCompTerm(get_builtin_type_name(*ILT) + std::string("_val"), 4,
+                                    make_null_atom(),
+                                    new PrologCompTerm("value_annotation", 2,
+                                                       make_atom(IL->getValue().toString(10, isSigned)),
+                                                       make_preprocessing_info()),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+
+      case Stmt::CharacterLiteralClass:
+        {
+          const CharacterLiteral *CL = cast<CharacterLiteral>(S);
+
+          //if the type of the expression is an integer type, emit character
+          //literals as integers
+          const Expr *E = dyn_cast<Expr>(S);
+          const QualType &T = E->getType();
+          if(T->getTypeClass() == Type::Builtin) {
+            BuiltinType *BT = cast<BuiltinType>(T);
+            
+            if(BT->getKind() != BuiltinType::Char_U &&
+               BT->getKind() != BuiltinType::UChar &&
+               BT->getKind() != BuiltinType::Char_S &&
+               BT->getKind() != BuiltinType::SChar ) {
+
+              return new PrologCompTerm(get_builtin_type_name(*BT) + std::string("_val"), 4,
+                                        make_null_atom(),
+                                        new PrologCompTerm("value_annotation", 2,
+                                                           make_int(CL->getValue()),
+                                                           make_preprocessing_info()),
+                                        make_default_analysis_info(),
+                                        make_file_info(S));
+            }
+          }
+
+          return new PrologCompTerm("char_val", 4,
+                                    make_null_atom(),
+                                    new PrologCompTerm("value_annotation", 2,
+                                                       make_atom(std::string(1, CL->getValue())),
+                                                       make_preprocessing_info()),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+        
+      case Stmt::FloatingLiteralClass:
+        {
+          const FloatingLiteral *FL = cast<FloatingLiteral>(S);
+          const BuiltinType *FLT = cast<BuiltinType>(FL->getType());
+          std::string type;
+          
+          switch (FLT->getKind()) {
+          case BuiltinType::Float:      type = "float"; break;
+          case BuiltinType::Double:     type = "double"; break;
+          case BuiltinType::LongDouble: type = "long_double"; break;
+          default:
+            assert(false);
+          }
+
+
+          std::stringstream ss;
+          ss << FL->getValueAsApproximateDouble();
+          
+          return new PrologCompTerm(type + "_val", 4,
+                                    make_null_atom(),
+                                    new PrologCompTerm("value_annotation", 2,
+                                                       make_atom(ss.str()),
+                                                       make_preprocessing_info()),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+        
+      case Stmt::StringLiteralClass:
+        {
+          const StringLiteral *SL = cast<StringLiteral>(S);
+
+          std::stringstream ss;
+          ss << (SL->isWide() ? "L" : "")
+             << escape(std::string(SL->getStrData(), SL->getByteLength()));
+          
+          return new PrologCompTerm("string_val", 4,
+                                    make_null_atom(),
+                                    new PrologCompTerm("value_annotation", 2,
+                                                       make_quoted_atom(ss.str()),
+                                                       make_preprocessing_info()),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+
+      case Stmt::ParenExprClass:
+        {
+          const ParenExpr *PE = cast<ParenExpr>(S);
+          return make_statement_term(PE->getSubExpr());
+        }
+        
+      case Stmt::UnaryOperatorClass:
+        {
+          return make_unary_operator_expr(S);
+          
+        }
+
+      case Stmt::SizeOfAlignOfExprClass:
+        {
+          const SizeOfAlignOfExpr *SoP = cast<SizeOfAlignOfExpr>(S);
+
+          PrologTerm *t;
+          if (SoP->isArgumentType())
+            t = make_null_atom();
+          else
+            t = make_statement_term(SoP->getArgumentExpr());
+          
+          if(SoP->isSizeOf()) {
+            return new PrologCompTerm("size_of_op", 4,
+                                      t,
+                                      new PrologCompTerm("size_of_op_annotation", 3,
+                                                         make_type_term(SoP->getTypeOfArgument()),
+                                                         make_type_term(SoP->getType()),
+                                                         make_preprocessing_info()),
+                                      make_default_analysis_info(),
+                                      make_file_info(SoP));
+          }
+          else {
+            return new PrologCompTerm("align_of_op", 4,
+                                      t,
+                                      make_default_annotation(),
+                                      make_default_analysis_info(),
+                                      make_file_info(SoP));
+            
+          }
+        }
+
+      case Stmt::ArraySubscriptExprClass:
+        {
+          const ArraySubscriptExpr *ASE = cast<ArraySubscriptExpr>(S);
+          return new PrologCompTerm("pntr_arr_ref_exp", 5,
+                                    make_statement_term(ASE->getBase()),
+                                    make_statement_term(ASE->getIdx()),
+                                    new PrologCompTerm("binary_op_annotation", 2,
+                                                       make_type_term(ASE->getType()),
+                                                       make_preprocessing_info()),
+                                    make_default_analysis_info(),
+                                    make_file_info(ASE));
+        }
+
+      case Stmt::VAArgExprClass:
+        {
+          return make_va_arg_expr(S);
+        }
+        
+      case Stmt::CallExprClass:
+        {
+          const CallExpr *CE = cast<CallExpr>(S);
+
+          PrologTerm *callee = NULL;
+          
+          //we have to mimic ROSE's behaviour for variadic functions here
+          unsigned builtin = CE->isBuiltinCall();
+          switch(builtin) {
+          case 0: /*nothing to do here */
+            break;
+          case Builtin::BI__builtin_va_start:
+            return make_va_start_expr(CE);
+          case Builtin::BI__builtin_va_end:
+            return make_va_end_expr(CE);
+          case Builtin::BI__builtin_va_copy:
+            return make_va_copy_expr(CE);
+          default:
+            callee = make_builtin_callee_term(CE->getCallee());
+          }
+          
+          PrologList *exprs = new PrologList();
+          CallExpr::const_arg_iterator i, ie;
+          for(i = CE->arg_begin(), ie = CE->arg_end();i != ie; ++i)
+            exprs->addElement(make_statement_term(*i));
+
+          if(!callee) callee = make_statement_term(CE->getCallee());
+          
+          return new PrologCompTerm("function_call_exp", 5,
+                                    callee,
+                                    new PrologCompTerm("expr_list_exp", 4,
+                                                       exprs,
+                                                       make_default_annotation(),
+                                                       make_default_analysis_info(),
+                                                       make_file_info(S)),
+                                    new PrologCompTerm("function_call_exp_annotation", 2,
+                                                       make_type_term(CE->getType()),
+                                                       make_preprocessing_info()),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+
+      case Stmt::MemberExprClass:
+        {
+          const MemberExpr *ME = cast<MemberExpr>(S);
+          std::string name(ME->isArrow() ? "arrow_exp" : "dot_exp");
+
+          return new PrologCompTerm(name, 5,
+                                    make_statement_term(ME->getBase()),
+                                    make_var_ref_expr(ME->getMemberDecl(), ME->getType(), ME),
+                                    new PrologCompTerm("binary_op_annotation", 2,
+                                                       make_type_term(ME->getType()),
+                                                       make_preprocessing_info()),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+
+      case Stmt::ImplicitCastExprClass:
+        if (castKind == ck_undef)
+          castKind = ck_implicit;
+      case Stmt::CStyleCastExprClass:
+        if (castKind == ck_undef)
+          castKind = ck_c_style;
+      case Stmt::ExplicitCastExprClass:
+        if (castKind == ck_undef) {
+          // TODO: add support when clang is able to handle const, reinterpret
+          // and dynamic casts
+          assert(0 && "not yet implemented");
+          castKind = ck_undef;
+        }
+      case Stmt::CastExprClass:
+        {
+          const CastExpr *CE = cast<CastExpr>(S);
+          std::string cast_type;
+          switch (castKind) {
+          case ck_implicit:    cast_type = "implicit"; break;
+          case ck_c_style:     cast_type = "C_style_cast"; break;
+          case ck_const:       cast_type = "const"; break;
+          case ck_static:      cast_type = "static"; break;
+          case ck_dynamic:     cast_type = "dynamic"; break;
+          case ck_reinterpret: cast_type = "reinterpret"; break;
+          case ck_undef:
+            assert(0 && "should be never reached");
+          }
+          
+          return new PrologCompTerm("cast_exp", 5,
+                                    make_statement_term(CE->getSubExpr()),
+                                    make_null_atom(),
+                                    new PrologCompTerm("unary_op_annotation", 5,
+                                                       make_atom("prefix"),
+                                                       make_type_term(CE->getType()),
+                                                       make_atom(cast_type),
+                                                       make_null_atom(),
+                                                       make_preprocessing_info()),
+                                    make_default_analysis_info(),
+                                    make_file_info(CE));
+        }
+
+      case Stmt::BinaryOperatorClass:
+      case Stmt::CompoundAssignOperatorClass:
+        {
+          return make_binary_operator_expr(S);
+        }
+
+      case Stmt::ConditionalOperatorClass:
+        {
+          const ConditionalOperator *CO = cast<ConditionalOperator>(S);
+          return new PrologCompTerm("conditional_exp", 6,
+                                    make_statement_term(CO->getCond()),
+                                    make_statement_term(CO->getTrueExpr()),
+                                    make_statement_term(CO->getFalseExpr()),
+                                    new PrologCompTerm("conditional_exp_annotation", 2,
+                                                       make_type_term(CO->getType()),
+                                                       make_preprocessing_info()),
+                                    make_default_analysis_info(),
+                                    make_file_info(CO));
+        }
+
+      case Stmt::InitListExprClass:
+        {          
+          const InitListExpr *ILE = cast<InitListExpr>(S);
+
+          PrologList *items = new PrologList();
+          InitListExpr::const_iterator i, ie;
+          for(i = ILE->begin(), ie = ILE->end(); i != ie; i++)
+            items->addElement(make_initializer_term(*i));
+          
+          return new PrologCompTerm("expr_list_exp", 4,
+                                    items,
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(ILE));
+        }
+
+      case Stmt::SwitchCaseClass:
+        assert(0 && "should be never reached");
+
+      case Stmt::PredefinedExprClass:
+        {
+          const PredefinedExpr *PE = cast<PredefinedExpr>(S);
+          switch (PE->getIdentType()) {
+          case PredefinedExpr::Func:           return make_atom(" __func__");
+          case PredefinedExpr::Function:       return make_atom(" __FUNCTION__");
+          case PredefinedExpr::PrettyFunction: return make_atom(" __PRETTY_FUNCTION__");
+          default:
+            assert(0 && "should be never reached");
+          }
+        }
+
+      case Stmt::StmtExprClass:
+        {
+          const StmtExpr *SE = cast<StmtExpr>(S);
+          return new PrologCompTerm("statement_expression", 4,
+                                    make_statement_term(SE->getSubStmt()),
+                                    make_default_annotation(),
+                                    make_default_analysis_info(),
+                                    make_file_info(S));
+        }
+        
+      default:
+        assert(0 && "not yet implemented");
+      }
+    }
+
+    
+    PrologTerm *
+    make_statement_term_wrapped(const Stmt *S) {
+      PrologTerm *t = make_statement_term(S);
+
+      if (!S || dyn_cast<Expr>(S)) {
+        t =  new PrologCompTerm("expr_statement", 4,
+                                t,
+                                make_default_annotation(),
+                                make_default_analysis_info(),
+                                make_file_info(S));
+        
+      }
+
+      return t;
+    }
+    
+    ////////////////////////////////////////////////////////
+    // global file handling
+    
+    void
+    HandleNewFile(const std::string &fileName, bool first) {
+      //start a new file 
+      current_source_file = fileName;
+      current_declaration_list = new PrologList();
+    }
+
+    //called by the driver after a file has been processed
+    virtual void OnFileEnd() {
+      file_list.addElement(make_file_term());
+    }
+    
+    //called by the driver for the very first file
+    virtual void
+    OnFirstFile(const char* fileName) {
+      HandleNewFile(fileName, true);
+    }
+    
+    //called by the driver for every file but the very first one
+    virtual void
+    OnNewFile(const char *fileName) {
+      HandleNewFile(fileName, false);
+    }
+    
+    //called by the driver for the very last file
+    virtual void
+    OnLastFile() {
+      PrologTerm *project = make_project_term();
+      static std::ostream& out = get_output_stream();
+      out << project->getRepresentation() << ".";
+      if (&out != &std::cout && &out != &std::cerr)
+        delete &out;
+    }
+    
+    virtual void
+    HandleTopLevelDecl(Decl *D) {
+      current_declaration_list->addElement(make_declaration_term(D));
+      if (D->getNextDeclarator())
+        HandleTopLevelDecl(D->getNextDeclarator());
+    }
+
+  };
+
+  PrologList ASTTermDumper::file_list;
+  
+} //end of anonymous namespace
+
+ASTConsumer *clang::CreateASTTermDumper(const std::string &infile,
+                                        const std::string &outfile,
+                                        Preprocessor *PP) {
+  
+  return new ASTTermDumper(infile, outfile, PP);
+}
+
Index: Driver/clang.cpp
===================================================================
--- Driver/clang.cpp	(revision 63505)
+++ Driver/clang.cpp	(working copy)
@@ -83,6 +83,7 @@
   EmitHTML,                     // Translate input source into HTML.
   ASTPrint,                     // Parse ASTs and print them.
   ASTDump,                      // Parse ASTs and dump them.
+  ASTTermDump,                  // Parse ASTs and dump them in TERMITE format.
   ASTView,                      // Parse ASTs and view them in Graphviz.
   PrintDeclContext,             // Print DeclContext and their Decls.
   TestSerialization,            // Run experimental serialization code.
@@ -124,6 +125,8 @@
                         "Build ASTs and then pretty-print them"),
              clEnumValN(ASTDump, "ast-dump",
                         "Build ASTs and then debug dump them"),
+			 clEnumValN(ASTTermDump, "emit-term",
+                        "Build ASTs and then export them in the TERMITE format"),
              clEnumValN(ASTView, "ast-view",
                         "Build ASTs and view them with GraphViz"),
              clEnumValN(PrintDeclContext, "print-decl-contexts",
@@ -490,12 +493,12 @@
                        llvm::cl::desc("Disallow implicit conversions between "
                                       "vectors with a different number of "
                                       "elements or different element types"));
+
 static llvm::cl::opt<bool>
-EnableBlocks("fblocks", llvm::cl::desc("enable the 'blocks' language feature"), llvm::cl::ValueDisallowed);
+EnableBlocks("fblocks", llvm::cl::desc("enable the 'blocks' language feature"),
+             llvm::cl::ValueDisallowed, llvm::cl::AllowInverse,
+             llvm::cl::ZeroOrMore);
 
-static llvm::cl::inverse_opt
-DisableBlocks("fno-blocks", llvm::cl::opposite_of(EnableBlocks), llvm::cl::ValueDisallowed);
-
 static llvm::cl::opt<bool>
 ObjCNonFragileABI("fobjc-nonfragile-abi", llvm::cl::desc("enable objective-c's nonfragile abi"));
 
@@ -623,7 +626,7 @@
   if (NoLaxVectorConversions.getPosition())
       Options.LaxVectorConversions = 0;
   Options.Exceptions = Exceptions;
-  if (EnableBlocks.getPosition() || DisableBlocks.getPosition())
+  if (EnableBlocks.getPosition())
     Options.Blocks = EnableBlocks;
 
   // Override the default runtime if the user requested it.
@@ -1272,6 +1275,9 @@
     case ASTDump:
       return CreateASTDumper();
       
+    case ASTTermDump:
+      return CreateASTTermDumper(InFile, OutputFile, PP);
+      
     case ASTView:
       return CreateASTViewer();   
 
@@ -1329,7 +1335,8 @@
 /// ProcessInputFile - Process a single input file with the specified state.
 ///
 static void ProcessInputFile(Preprocessor &PP, PreprocessorFactory &PPF,
-                             const std::string &InFile, ProgActions PA) {
+                             const std::string &InFile, ProgActions PA,
+                             bool IsFirstFile, bool IsLastFile) {
   llvm::OwningPtr<ASTConsumer> Consumer;
   bool ClearSourceMgr = false;
   
@@ -1433,7 +1440,19 @@
                                            /* FreeMemory = */ false);
       TU = new TranslationUnit(*Context);
     }
+
+    //this allows to dump prolog and epilog for a whole program representation
+    if(IsFirstFile)
+      Consumer->OnFirstFile(InFile.c_str());    
+    else
+      Consumer->OnNewFile(InFile.c_str());
+    
     ParseAST(PP, Consumer.get(), TU, Stats);
+
+    Consumer->OnFileEnd();
+    
+    if(IsLastFile)
+      Consumer->OnLastFile();
   }
 
   if (VerifyDiagnostics)
@@ -1629,7 +1648,7 @@
         Diags.setClient(TextDiagClient);
 
       // Process the source file.
-      ProcessInputFile(*PP, PPFactory, InFile, PCH ? GeneratePCH : ProgAction);
+      ProcessInputFile(*PP, PPFactory, InFile, PCH ? GeneratePCH : ProgAction, i == 0, i == e - 1);
       
       HeaderInfo.ClearFileInfo();      
     }
Index: Driver/minitermite/minitermite.h
===================================================================
--- Driver/minitermite/minitermite.h	(revision 0)
+++ Driver/minitermite/minitermite.h	(revision 0)
@@ -0,0 +1,30 @@
+/* -*- C++ -*-
+ * Copyright 2008 Adrian Prantl <adrian@complang.tuwien.ac.at>
+ *
+ * Configures the TERMITE term representation.
+ */
+
+#ifndef __TERMITE_H__
+#define __TERMITE_H__
+
+// #ifndef HAVE_SWI_PROLOG
+// #define HAVE_SWI_PROLOG 1
+// #endif
+
+#define DEBUG_TERMITE 0
+
+#include "PrologTerm.h"
+#include "PrologCompTerm.h"
+#include "PrologList.h"
+#include "PrologAtom.h"
+#include "PrologInt.h"
+#include "PrologVariable.h"
+
+// Defines wether Terms start with "Sg"
+#define SG_PREFIX ""
+//#define SG_PREFIX "Sg"
+
+// if enabled, use int_val(...) instead of unary_node(intval, ...)
+#define COMPACT_TERM_NOTATION
+
+#endif
Index: Driver/minitermite/PrologCompTerm.h
===================================================================
--- Driver/minitermite/PrologCompTerm.h	(revision 0)
+++ Driver/minitermite/PrologCompTerm.h	(revision 0)
@@ -0,0 +1,203 @@
+/* -*- C++ -*-
+Copyright 2006 Christoph Bonitz <christoph.bonitz@gmail.com>
+     2007-2008 Adrian Prantl <adrian@complang.tuwien.ac.at>
+*/
+#ifndef PROLOGCOMPTERM_H_
+#define PROLOGCOMPTERM_H_
+#include "PrologTerm.h"
+#include <assert.h>
+#include <stdarg.h>
+
+#if !HAVE_SWI_PROLOG
+
+/// Representation of a compound prolog term .
+class PrologCompTerm : public PrologTerm {
+public:
+  ~PrologCompTerm() {};
+  /// Creates a compound term with the given name. no subterms added yet.
+  
+  PrologCompTerm(std::string name) : mName(name) {};
+
+  PrologCompTerm(std::string name, size_t n, ...) : mName(name) {
+    if(n > 0) {
+      va_list params;
+      va_start(params, n);
+      for (size_t i=0; i < n; i++)
+        addSubterm(va_arg(params, PrologTerm *));
+      va_end(params);
+    }
+  }
+  
+  int getArity() { return mSubterms.size(); };
+  bool isGround() {
+    bool ground = true;
+    std::vector<PrologTerm*>::iterator it;
+    it = mSubterms.begin();
+    while (it != mSubterms.end()) {
+      ground = ground && (*it)->isGround();
+      it++;
+    }
+    return ground;
+  };
+
+  /// Get the Functor
+  std::string getName() { return mName; };
+  std::string getRepresentation() {
+    /*Pattern: name(...all subterms separated by commas..) */
+    std::string rep = getName();
+    rep += "(";
+    std::vector<PrologTerm*>::iterator it;
+    it = mSubterms.begin();
+    // append the representation of all subterms
+    while (it != mSubterms.end()) {
+      rep = rep + (*it)->getRepresentation();
+      // all but the last subterm are followed by a comma
+      if(++it != mSubterms.end()) rep += ",";
+    }
+    rep += ")";
+    return rep;
+  };
+
+  std::vector<PrologTerm *> getSubTerms() { return mSubterms; };
+
+
+  /// Add a subterm at the first position
+  void addFirstSubTerm(PrologTerm* t) {mSubterms.insert(mSubterms.begin(),t);};
+
+  /// Add a subterm at the last position
+  void addSubterm(PrologTerm* t) {mSubterms.push_back(t);};
+
+  /// the i-th subterm
+  PrologTerm* at(int i) {return mSubterms.at(i);};
+protected:
+  /// the name of the terms
+  std::string mName;
+  /// list of the subterms
+  std::vector<PrologTerm *> mSubterms;
+};
+
+class PrologInfixOperator : public PrologCompTerm {
+public:
+  ~PrologInfixOperator() {};
+  /// Creates a compound term with the given name. no subterms added yet.
+  PrologInfixOperator(std::string name) : PrologCompTerm(name) {};
+  std::string getRepresentation() {
+    assert(mSubterms.size() == 2);
+    return mSubterms[0]->getRepresentation() + getName() + mSubterms[1]->getRepresentation();
+  }
+};
+
+#else
+
+// The SWI Prolog implementation generates the term_t delayed, on the
+// first read. Afterwards addSubTerms will fail!
+class PrologCompTerm : public PrologTerm {
+public:
+  ~PrologCompTerm() {
+    //PL_unregister_atom(term);
+  }
+
+  PrologCompTerm(term_t t) : PrologTerm(t) {
+  };
+
+  /// Creates a compound term with the given name. no subterms added yet.
+  PrologCompTerm(std::string functor) {
+    term = PL_new_term_ref();
+    PL_put_atom_chars(term, functor.c_str());
+#   if DEBUG_TERMITE
+      std::cerr<<"CompTerm: PL_new_atom('"<<functor<<"') ="<<term<<std::endl;
+#   endif
+  }
+
+  /// return a list of successors
+  std::vector<PrologTerm*> getSubTerms()  {
+    std::vector<PrologTerm *> mSubterms;
+    int arity = getArity();
+    for(int n = 1; n <= arity; n++) { 
+      term_t arg = PL_new_term_ref();
+      PL_get_arg(n, term, arg);
+      mSubterms.push_back(newPrologTerm(arg));
+    }
+    return mSubterms;
+  }
+
+  /// Add a subterm at the first position
+  void addFirstSubTerm(PrologTerm* t) {
+#   if DEBUG_TERMITE
+      std::cerr<<display(term)<<" . addFirstSubTerm("
+	       <<t->getRepresentation()<<");"<<std::endl;
+#   endif
+
+    term_t old_term = term;
+    int arity;
+    atom_t name;
+    if (PL_get_atom(old_term, &name)) { // still arity 0
+      arity = 0;
+    } else {
+	PL_get_name_arity(old_term, &name, &arity);
+    }
+
+    // Construct a new, bigger term
+    term_t args = PL_new_term_refs(arity+1);
+    PL_put_variable(args);
+    for(int n = 1; n <= arity; n++)
+      assert(PL_get_arg(n, old_term, args+n));
+
+    term = PL_new_term_ref();
+    PL_cons_functor_v(term, PL_new_functor(name, arity+1), args); 
+    assert(PL_unify_arg(1, term, t->getTerm()));
+
+#   if DEBUG_TERMITE
+      std::cerr<<" --> "<<display(term)<<" !"<<std::endl;
+#   endif
+  }
+
+  /// Add a subterm at the last position
+  void addSubterm(PrologTerm* t) {
+#   if DEBUG_TERMITE
+      std::cerr<<display(term)<<"  addSubterm("<<t->getRepresentation()<<");"
+	       <<std::endl;
+#   endif
+
+    term_t old_term = term;
+    int arity;
+    term_t name;
+    if (PL_get_atom(old_term, &name)) { // still arity 0
+      arity = 0;
+    } else {
+      PL_get_name_arity(old_term, &name, &arity);
+    }
+
+    // Construct a new, bigger term
+    term_t args = PL_new_term_refs(arity+1);
+    for(int n = 0; n < arity; n++)
+      assert(PL_get_arg(n+1, old_term, args+n));
+    PL_put_variable(args+arity);
+
+    term = PL_new_term_ref();
+    PL_cons_functor_v(term, PL_new_functor(name, arity+1), args); 
+
+    assert(PL_unify_arg(arity+1, term, t->getTerm()));
+
+#   if DEBUG_TERMITE
+      std::cerr<<" --> "<<display(term)<<" !"<<std::endl;
+#   endif
+  }
+
+  /// the i-th subterm
+  PrologTerm* at(int i) {      
+    term_t arg = PL_new_term_ref();
+    PL_get_arg(i+1, term, arg);
+    return newPrologTerm(arg);
+  }
+};
+
+class PrologInfixOperator : public PrologCompTerm {
+public:
+  PrologInfixOperator(std::string name) : PrologCompTerm(name) {};
+};
+
+
+#endif
+
+#endif
Index: Driver/minitermite/PrologTerm.h
===================================================================
--- Driver/minitermite/PrologTerm.h	(revision 0)
+++ Driver/minitermite/PrologTerm.h	(revision 0)
@@ -0,0 +1,259 @@
+/* -*- C++ -*-
+Copyright 2006 Christoph Bonitz <christoph.bonitz@gmail.com>
+          2008 Adrian Prantl <adrian@complang.tuwien.ac.at>
+*/
+#ifndef PROLOGTERM_H_
+#define PROLOGTERM_H_
+#include <vector>
+#include <string>
+#include <memory>
+#include <iostream>
+#include <ctype.h>
+#include <assert.h>
+
+#ifndef __TERMITE_H__
+#  error "Please do not include this file directly. Use minitermite.h instead."
+#endif
+
+bool init_termite(int argc, char **argv, bool interactive=false);
+
+#if !HAVE_SWI_PROLOG
+
+#include <iomanip>
+#include <string>
+#include <sstream>
+
+/// Representation of a prolog term
+class PrologTerm {
+ public:
+  virtual ~PrologTerm() {};
+  /// returns the arity of the term
+  virtual int getArity() = 0;
+  /// returns whether or not the term is a ground term, i.e. contains
+  /// no variables.
+  /** Note that this is the case iff all the subterms are ground. */
+  virtual bool isGround() = 0;
+  /// Gets the name (functor/variable/constant) of the term. 
+  /* numbers are represented as strings and therefore returned as such */
+  virtual std::string getName() = 0;
+  /// the actual prolog term that is represented by this object
+  virtual std::string getRepresentation() = 0;
+
+  /// Properly quote and escape an atom if necessary
+  static std::string quote(const std::string atom, bool force_quote=false) {
+    std::string s = escape(atom);
+    if (atom.length() == 0) return "''";
+    if (((atom.length() > 0) && (!islower(atom[0])) && (!isdigit(atom[0])))
+	|| needs_quotes(atom) || force_quote) {
+      s = "'" + s + "'";
+      return s;
+    } else if (is_reserved_operator(atom)) {
+      s = "(" + s + ")";
+      return s;
+    }
+    return s;
+  }
+
+protected:
+
+  static bool is_reserved_operator(const std::string s) {
+    return s == "volatile";
+  }
+
+  static bool needs_quotes(const std::string s) {
+    if (s.length() == 0) 
+      return true;
+
+    bool alldigits = isdigit(s[0]);
+    for (std::string::const_iterator c = s.begin();
+	 c != s.end(); ++c) {
+
+      if (alldigits) {
+	if (!isdigit(*c))
+	  return true;
+	else continue;
+      }
+
+      if (!islower(*c) && !isupper(*c) && 
+	  !(*c == '_'))
+	return true;
+    }
+    return false;
+  }
+
+  // Escape non-printable characters
+  static std::string escape(std::string s) {
+    std::string r;
+    for (unsigned int i = 0; i < s.length(); ++i) {
+      unsigned char c = s[i];
+      switch (c) {
+      case '\\': r += "\\\\"; break; // Literal backslash
+      case '\"': r += "\\\""; break; // Double quote
+      case '\'': r += "\\'"; break;  // Single quote
+      case '\n': r += "\\n"; break;  // Newline (line feed)
+      case '\r': r += "\\r"; break;  // Carriage return
+      case '\b': r += "\\b"; break;  // Backspace
+      case '\t': r += "\\t"; break;  // Horizontal tab
+      case '\f': r += "\\f"; break;  // Form feed
+      case '\a': r += "\\a"; break;  // Alert (bell)
+      case '\v': r += "\\v"; break;  // Vertical tab
+      default:
+	if (c < 32 || c > 127) {
+	  std::stringstream strm;
+	  strm << '\\' 
+	       << std::oct 
+	       << std::setfill('0') 
+	       << std::setw(3) 
+	       << (unsigned int)c // \nnn Character with octal value nnn
+	       << '\\'; // Prolog expects this weird syntax with a
+			// trailing backslash
+	  r += strm.str();
+	} else {
+	  r += c;
+	}
+      }
+    }
+    //cerr<<"escape("<<s<<") = "<< r <<endl;
+    return r;
+  }
+
+
+};
+
+#else
+
+# include <SWI-Prolog.h>
+# ifdef NORETURN
+#   undef NORETURN // incompatability with the PAG headers
+# endif
+# ifdef TRUE
+#   undef TRUE // incompatability with the ROSE headers
+# endif
+# ifdef FALSE
+#   undef FALSE // incompatability with the ROSE headers
+# endif
+
+# include <deque>
+# include <sstream>
+
+
+/// Representation of a prolog term
+class PrologTerm {
+ public:
+  PrologTerm() :term(PL_new_term_ref()) {
+#   if DEBUG_TERMITE
+      std::cerr<<"UNINIT"<<std::endl;
+#   endif
+  }
+  PrologTerm(term_t t) : term(PL_copy_term_ref(t)) { 
+#   if DEBUG_TERMITE
+      std::cerr<<"new PrologTerm("<<display(t)<<")"<<std::endl;
+#   endif
+  }
+
+  virtual ~PrologTerm() {
+    // Free all children that were generated on-the-fly
+    // TODO: replace this with some sorrt of smart pointer
+    for (std::deque<PrologTerm*>::iterator p = garbage_bin.begin(); 
+	 p != garbage_bin.end(); ++p)
+      delete *p;
+  }
+  /// returns the arity of the term
+  virtual int getArity() { 
+    int arity = 0;
+    if (PL_term_type(term) == PL_TERM) {
+      term_t name;
+      PL_get_name_arity(term, &name, &arity);
+    }
+    return arity;
+  }
+  /// returns whether or not the term is a ground term, i.e. contains
+  /// no variables.
+  virtual bool isGround() { return PL_is_ground(term); }
+
+  /// Gets the name (functor/variable/constant) of the term. 
+  /* numbers are represented as strings and therefore returned as such */
+  virtual std::string getName() {
+    char *s;
+    if (PL_get_atom_chars(term, &s))
+      return std::string(s);
+
+    int arity;
+    atom_t name;
+    PL_get_name_arity(term, &name, &arity);
+    return std::string(PL_atom_chars(name));
+  }
+  /// the actual prolog term that is represented by this object
+  virtual std::string getRepresentation() { return display(term); }
+
+  /// Properly quote an atom if necessary
+  static std::string quote(const char* s) {
+    return std::string(PL_quote('\'', s));
+  }
+
+  /// return the SWI-Prolog term
+  term_t getTerm() { return term; }
+
+  // Create a new PrologTerm from a real Prolog Atom
+  static PrologTerm *wrap_PL_Term(term_t t);
+
+protected:
+
+  term_t term; // The "real" prolog term
+
+  static std::string display(term_t t)
+  { 
+    // this should be more efficient than 
+    // chars_to_term("with_output_to(string(S),write_term(T,[quoted(true)]))",X)
+    fid_t fid = PL_open_foreign_frame();
+    term_t T		  = PL_copy_term_ref(t);
+    term_t a0 = PL_new_term_refs(7);
+    term_t S		  = a0 + 0;
+    term_t True		  = a0 + 1;
+    term_t quoted	  = a0 + 2;
+    term_t list           = a0 + 3;
+    term_t write_term	  = a0 + 4;
+    term_t string	  = a0 + 5;
+    term_t with_output_to = a0 + 6;
+
+    PL_put_variable(S);
+    PL_cons_functor(string, PL_new_functor(PL_new_atom("string"), 1), S);
+
+    PL_put_atom_chars(True, "true");
+    PL_cons_functor(quoted, PL_new_functor(PL_new_atom("quoted"), 1), True);
+
+    PL_put_nil(list);
+    PL_cons_list(list, quoted, list);
+    
+    PL_cons_functor(write_term, 
+		    PL_new_functor(PL_new_atom("write_term"), 2), 
+		    T, list);
+    PL_cons_functor(with_output_to, 
+		    PL_new_functor(PL_new_atom("with_output_to"), 2), 
+		    string, write_term);
+    assert(PL_call(with_output_to, NULL));
+    
+    char *s;
+    size_t len;
+    assert(PL_get_string_chars(S, &s, &len));
+
+    std::string r = std::string(s);
+    PL_discard_foreign_frame(fid);
+    return r;
+  }
+
+  std::deque<PrologTerm*> garbage_bin;
+
+  // Create a new PrologTerm from a real Prolog Atom
+  // it will automatically be freed at the end of this object's lifetime
+  // calls wrap_PL_Term internally
+  PrologTerm *newPrologTerm(term_t t);
+
+  // Create a real Prolog term from a PrologTerm
+  // it will be garbage-collected by SWI-Prolog
+  term_t newTerm_t(PrologTerm* pt);
+};
+
+#endif // SWI
+
+#endif
Index: Driver/minitermite/PrologInt.h
===================================================================
--- Driver/minitermite/PrologInt.h	(revision 0)
+++ Driver/minitermite/PrologInt.h	(revision 0)
@@ -0,0 +1,151 @@
+/* -*- C++ -*-
+Copyright 2006 Christoph Bonitz <christoph.bonitz@gmail.com>
+          2008 Adrian Prantl <adrian@complang.tuwien.ac.at>
+*/
+#ifndef PROLOGINT_H_
+#define PROLOGINT_H_
+#include "PrologTerm.h"
+
+#include <sstream>
+
+#if !HAVE_SWI_PROLOG
+
+///class representing a prolog integer
+class PrologInt : public PrologTerm {
+public:
+  /// constructor sets the value
+  PrologInt(int value) : mValue(value) {}
+  ///the arity is 0
+  int getArity() {return 0;}
+  /// an integer is always ground
+  bool isGround() {return true;}
+  /// return "Integer"
+  std::string getName() {return "Integer";}
+
+  /// return string representation of integer
+  std::string getRepresentation() {
+    std::stringstream ss;
+    std::string s;
+    ss << mValue;
+    ss >> s;
+    return s;
+  }
+
+  /// return value
+  int getValue() {return mValue;}
+ private:
+  /// the value
+  int mValue;
+};
+
+///class representing a prolog integer
+class PrologFloat : public PrologTerm {
+public:
+  /// constructor sets the value
+  PrologFloat(double value) : mValue(value) {}
+  ///the arity is 0
+  int getArity() {return 0;}
+  /// an integer is always ground
+  bool isGround() {return true;}
+  /// return "Integer"
+  std::string getName() {return "Float";}
+
+  /// return string representation of integer
+  std::string getRepresentation() {
+    std::stringstream ss;
+    std::string s;
+    ss << mValue;
+    ss >> s;
+    return s;
+  }
+
+  /// return value
+  double getValue() {return mValue;}
+ private:
+  /// the value
+  double mValue;
+};
+
+#else
+
+///class representing a prolog integer
+class PrologInt : public PrologTerm {
+public:
+  // CAREFUL: we can't use the default "copy constructor" 
+  // because term_t and int64_t are equivalent
+  PrologInt() : PrologTerm() {};
+  void createFromTerm(term_t t) { term = PL_copy_term_ref(t); }
+
+  /// constructor sets the value
+  PrologInt(int64_t value) { 
+    //std::stringstream s;
+    //s << value;
+    //PL_put_atom_chars(term, s.str().c_str());
+    //#   if DEBUG_TERMITE
+    //  std::cerr<<"PrologInt: PL_new_atom("<<s.str()<<") = "<<term<<std::endl;
+    //#   endif
+
+    term = PL_new_term_ref();
+    PL_put_int64(term, value);
+
+#   if DEBUG_TERMITE
+      std::cerr<<"PrologInt: "<<value<<") = "<<term<<std::endl;
+#   endif
+  }
+  ///the arity is 0
+  int getArity() { return 0; }
+  /// an integer is always ground
+  bool isGround() { return true; }
+  /// return "Integer"
+  std::string getName() { return "Integer"; }
+
+  /// return value
+  int64_t getValue() {
+    int64_t i;
+    assert(PL_get_int64(term, &i));
+    return i;
+  }
+};
+
+///class representing a prolog float
+class PrologFloat : public PrologTerm {
+public:
+  // CAREFUL: we can't use the default "copy constructor" 
+  // because term_t and int64_t are equivalent
+  PrologFloat() : PrologTerm() {};
+  void createFromTerm(term_t t) { term = PL_copy_term_ref(t); }
+
+  /// constructor sets the value
+  PrologFloat(double value) { 
+    //std::stringstream s;
+    //s << value;
+    //PL_put_atom_chars(term, s.str().c_str());
+    //#   if DEBUG_TERMITE
+    //  std::cerr<<"PrologInt: PL_new_atom("<<s.str()<<") = "<<term<<std::endl;
+    //#   endif
+
+    term = PL_new_term_ref();
+    PL_put_float(term, value);
+
+#   if DEBUG_TERMITE
+      std::cerr<<"PrologFloat: "<<value<<") = "<<term<<std::endl;
+#   endif
+  }
+  ///the arity is 0
+  int getArity() { return 0; }
+  /// an integer is always ground
+  bool isGround() { return true; }
+  /// return "Integer"
+  std::string getName() { return "Float"; }
+
+  /// return value
+  double getValue() {
+    double i;
+    assert(PL_get_float(term, &i));
+    return i;
+  }
+};
+
+#endif
+
+#endif
Index: Driver/minitermite/PrologList.h
===================================================================
--- Driver/minitermite/PrologList.h	(revision 0)
+++ Driver/minitermite/PrologList.h	(revision 0)
@@ -0,0 +1,189 @@
+/* -*- C++ -*-
+Copyright 2006 Christoph Bonitz <christoph.bonitz@gmail.com>
+          2008 Adrian Prantl <adrian@complang.tuwien.ac.at>
+*/
+#ifndef PROLOGLIST_H_
+#define PROLOGLIST_H_
+#include "PrologTerm.h"
+#include <deque>
+
+#if !HAVE_SWI_PROLOG
+
+/**
+ * class representing a prolog list*/
+class PrologList : public PrologTerm {
+ public:
+  /**default constructor*/
+  PrologList() {}
+  /** construct from vector*/
+  PrologList(std::deque<PrologTerm*> v) : mTerms(v) {}
+  PrologList(std::vector<PrologTerm*> v) :mTerms(v.begin(), v.end()) {}
+  
+  /// return size of the list
+  int getArity() {return mTerms.size();}
+  /// are all the members ground?
+  bool isGround() {
+    bool ground = true;
+    //List is ground if all elements are.
+    std::deque<PrologTerm*>::iterator it = mTerms.begin();
+    while(it != mTerms.end()) {
+      ground = ground && (*it)->isGround();
+      it++;
+    }
+    return ground;
+  }
+
+  /// the predicate name of a list in prolog is .
+  std::string getName() {return ".";}
+  /// output the representation
+  std::string getRepresentation() {
+    /*Pattern: name(...all subterms separated by commas..) */
+    std::string rep = "[";
+    std::deque<PrologTerm*>::iterator it;
+    it = mTerms.begin();
+    // append the representation of all subterms
+    while (it != mTerms.end()) {
+      rep = rep + (*it)->getRepresentation();
+      // all but the last subterm are followed by a comma
+      if(++it != mTerms.end()) rep += ",";
+    }
+    rep += "]";
+    return rep;
+  }
+
+  /// add a list element
+  void addElement(PrologTerm* t) {mTerms.push_back(t);}
+
+  /// add a list element at the beginning
+  void addFirstElement(PrologTerm* t) {mTerms.push_front(t);}
+
+  /// get the i-th element
+  PrologTerm* at(int i) {return mTerms.at(i);}
+  /// return a list of successors
+  std::deque<PrologTerm*>* getSuccs() {return &mTerms;}
+ private:
+  /// the successors
+  std::deque<PrologTerm*> mTerms;
+};
+
+# else
+
+
+/**
+ * class representing a prolog list*/
+class PrologList : public PrologTerm {
+ public:
+  /** empty list */
+  PrologList() {
+    term = PL_new_term_ref();
+    PL_put_nil(term);
+#   if DEBUG_TERMITE
+      std::cerr<<"new PrologList: "<<display(term)<<std::endl;
+#   endif
+  }
+
+  PrologList(term_t t) : PrologTerm(t) {}
+
+  /** construct from vector*/
+  PrologList(std::vector<PrologTerm*> v) {
+    term = PL_new_term_ref();
+    PL_put_nil(term);
+    for (std::vector<PrologTerm*>::reverse_iterator i = v.rbegin();
+	 i != v.rend(); ++i) { 
+      PL_cons_list(term, (*i)->getTerm(), term);
+    }
+#   if DEBUG_TERMITE
+      std::cerr<<"new PrologList: "<<display(term)<<std::endl;
+#   endif
+  }
+
+  PrologList(std::deque<PrologTerm*> v) {
+    term = PL_new_term_ref();
+    PL_put_nil(term);
+    for (std::deque<PrologTerm*>::reverse_iterator i = v.rbegin();
+	 i != v.rend(); ++i) { 
+      PL_cons_list(term, (*i)->getTerm(), term);
+    }
+#   if DEBUG_TERMITE
+      std::cerr<<"new PrologList: "<<display(term)<<std::endl;
+#   endif
+  }
+  
+  /// return size of the list
+  int getArity() { 
+    int l = 0;
+    fid_t fid = PL_open_foreign_frame();
+    // FIXME: cache predicate
+    term_t a0 = PL_new_term_refs(2);
+    assert(PL_unify(a0, term));
+    PL_put_variable(a0+2);
+    qid_t qid = PL_open_query(NULL, PL_Q_NORMAL, 
+			      PL_predicate("length", 2, ""), a0);
+    assert(PL_next_solution(qid) && 
+	   PL_get_integer(a0+1, &l));
+    //PL_close_query(qid);
+    PL_cut_query(qid);
+    PL_discard_foreign_frame(fid);
+    return l;
+  }
+
+  /// add a list element
+  void addElement(PrologTerm* t) {
+#   if DEBUG_TERMITE
+      std::cerr<<"  addElement("<<display(term)<<" + " 
+	       <<t->getRepresentation()<<")"<<std::endl;
+#   endif
+
+    term_t a0 = PL_new_term_refs(3);
+    assert(PL_unify(a0, term));
+    PL_put_nil(a0+1);
+    PL_cons_list(a0+1, t->getTerm(), a0+1);
+    PL_put_variable(a0+2);
+    // TODO: cache the predicates
+    assert(PL_call_predicate(NULL, PL_Q_NORMAL, 
+			     PL_predicate("append", 3, "library(lists)"), a0));
+    term = a0 + 2;
+
+#   if DEBUG_TERMITE
+      for (int i = 0; i < 3; ++i)
+	std::cerr<<display(a0+i)<<std::endl;
+      std::cerr<<"-> "<<display(term)<<std::endl;
+#   endif
+  }
+
+  /// add the first list element
+  void addFirstElement(PrologTerm* t) {
+    PL_cons_list(term, t->getTerm(), term);
+  }
+
+  /// get the i-th element
+  PrologTerm* at(int i) {
+    term_t t = PL_copy_term_ref(term);
+
+    for (int c = 0; c < i; c++)
+      assert(PL_get_tail(t, t));
+    PL_get_head(t, t);
+    return newPrologTerm(t);
+  }
+
+  /// return a list of successors
+  std::deque<PrologTerm*>* getSuccs()  {
+    if (mTerms.size() == 0) {
+      term_t tail = PL_copy_term_ref(term);
+      term_t head = PL_new_term_ref();
+      while (PL_get_list(tail, head, tail))
+	mTerms.push_back(newPrologTerm(head));
+    }
+
+    return &mTerms;
+  }
+
+ private:
+  /// the successors
+  std::deque<PrologTerm*> mTerms;
+};
+
+
+#endif
+
+#endif
Index: Driver/minitermite/PrologAtom.h
===================================================================
--- Driver/minitermite/PrologAtom.h	(revision 0)
+++ Driver/minitermite/PrologAtom.h	(revision 0)
@@ -0,0 +1,62 @@
+/* -*- C++ -*-
+Copyright 2006 Christoph Bonitz <christoph.bonitz@gmail.com>
+          2008 Adrian Prantl <adrian@complang.tuwien.ac.at>
+*/
+#ifndef PROLOGATOM_H_
+#define PROLOGATOM_H_
+#include "PrologTerm.h"
+
+/**class representing a prolog atom*/
+
+#if !HAVE_SWI_PROLOG
+
+class PrologAtom : public PrologTerm {
+public:
+  ///the destructor
+  ~PrologAtom() {};
+  ///constructor setting the string
+  PrologAtom(std::string name, bool _force_quote=false) {
+      mName = name;
+      force_quote = _force_quote;
+  };
+  ///the arity is always 0
+  int getArity() {return 0;};
+  ///an atom is always ground
+  bool isGround() {return true;};
+  ///return the string
+  std::string getName() {return mName;};
+  /// return the string
+  std::string getRepresentation() { return quote(mName, force_quote); };
+private:
+  bool force_quote;
+  
+  /// the string
+  std::string mName;
+};
+
+
+#else
+
+
+class PrologAtom : public PrologTerm {
+public:
+  PrologAtom(term_t t) : PrologTerm(t) {};
+
+  ///the destructor
+  ~PrologAtom() {
+    // Decrement the reference count of the atom.
+    //PL_unregister(term);
+  }
+  ///constructor setting the string
+  PrologAtom(std::string name) {
+    term = PL_new_term_ref();
+    PL_put_atom_chars(term, name.c_str());
+#   if DEBUG_TERMITE
+      std::cerr<<"PL_new_atom("<<getRepresentation()<<") = "<<term<<std::endl;
+#   endif
+  }
+};
+
+#endif
+
+#endif
Index: Driver/minitermite/PrologVariable.h
===================================================================
--- Driver/minitermite/PrologVariable.h	(revision 0)
+++ Driver/minitermite/PrologVariable.h	(revision 0)
@@ -0,0 +1,28 @@
+/* -*- C++ -*-
+Copyright 2006 Christoph Bonitz <christoph.bonitz@gmail.com>
+          2008 Adrian Prantl <adrian@complang.tuwien.ac.at>
+*/
+#ifndef PROLOGVARIABLE_H_
+#define PROLOGVARIABLE_H_
+#include "PrologTerm.h"
+
+///class representing a prolog variable
+class PrologVariable : public PrologTerm {
+	public:
+		///constructor setting the name
+  PrologVariable(std::string name) : mName(name) { assert(false); };
+		/// arity is always zero
+		int getArity() {return 0;};
+		/// a variable isn't ground
+		bool isGround() {return false;};
+		/// return the name
+		std::string getName() {return mName;};
+		/// output the name
+		std::string getRepresentation() {return mName;};
+		
+	private:
+		/// the name
+		std::string mName;
+};
+
+#endif
Index: Driver/ASTConsumers.h
===================================================================
--- Driver/ASTConsumers.h	(revision 63505)
+++ Driver/ASTConsumers.h	(working copy)
@@ -36,6 +36,10 @@
 
 ASTConsumer *CreateASTDumper();
 
+ASTConsumer *CreateASTTermDumper(const std::string &infile,
+                                 const std::string &outfile,
+                                 Preprocessor *PP);
+
 ASTConsumer *CreateASTViewer();
 
 ASTConsumer *CreateDeclContextPrinter();
Index: tools/ccc/ccclib/HostInfo.py
===================================================================
--- tools/ccc/ccclib/HostInfo.py	(revision 63505)
+++ tools/ccc/ccclib/HostInfo.py	(working copy)
@@ -89,6 +89,45 @@
             
     raise RuntimeError,'Unrecognized Darwin platform: %r:%r' % (machine, bits)
 
+# Linux
+
+class LinuxHostInfo(HostInfo):
+    def __init__(self, driver):
+        super(LinuxHostInfo, self).__init__(driver)
+        self.gccVersion = (4,2,1)
+
+    def useDriverDriver(self):
+        return False
+
+    def getToolChain(self):
+        return self.getToolChainForArch(self.getArchName(None))
+
+    def getToolChainForArch(self, arch):
+        return ToolChain.Generic_GCC_ToolChain(self.driver)
+
+class LinuxX86HostInfo(LinuxHostInfo):
+    def getArchName(self, args):
+        if args and args.getLastArg(args.parser.m_64Option):
+            return 'x86_64'
+        return 'i386'
+
+class LinuxX86_64HostInfo(LinuxHostInfo):
+    def getArchName(self, args):
+        if args and args.getLastArg(args.parser.m_32Option):
+            return 'i386'
+        return 'x86_64'
+
+def getLinuxHostInfo(driver):
+    machine = driver.getHostMachine()
+    bits = driver.getHostBits()
+    if machine == 'i386':
+        if bits == '32':
+            return LinuxX86HostInfo(driver)
+        if bits == '64':
+            return LinuxX86_64HostInfo(driver)
+
+    raise RuntimeError,'Unrecognized Linux platform: %r:%r' % (machine, bits)
+
 # Unknown
 
 class UnknownHostInfo(HostInfo):
@@ -107,7 +146,8 @@
 ####
 
 kSystems = {
-    'darwin' : getDarwinHostInfo,
+    'darwin'  : getDarwinHostInfo,
+    'linux'   : getLinuxHostInfo,
     'unknown' : getUnknownHostInfo,
     }
 
Index: tools/ccc/ccclib/Tools.py
===================================================================
--- tools/ccc/ccclib/Tools.py	(revision 63505)
+++ tools/ccc/ccclib/Tools.py	(working copy)
@@ -178,6 +178,12 @@
 
         patchOutputNameForPTH = False
 
+        cmd_args.append('-arch')
+        if arch:
+            cmd_args.append(arch)
+        else:
+            cmd_args.append(self.toolChain.driver.hostInfo.getArchName(arglist))
+
         if isinstance(phase.phase, Phases.AnalyzePhase):
             assert outputType is Types.PlistType
             cmd_args.append('-analyze')
Index: lib/Lex/PPDirectives.cpp
===================================================================
--- lib/Lex/PPDirectives.cpp	(revision 63505)
+++ lib/Lex/PPDirectives.cpp	(working copy)
@@ -18,6 +18,7 @@
 #include "clang/Lex/LexDiagnostic.h"
 #include "clang/Basic/SourceManager.h"
 #include "llvm/ADT/APInt.h"
+#include <iostream>
 using namespace clang;
 
 //===----------------------------------------------------------------------===//
@@ -959,6 +960,9 @@
     DiscardUntilEndOfDirective();
     return;
   }
+
+  if (Callbacks)
+    Callbacks->IncludeDirective(FilenameTok.getLocation(), std::string(FilenameStart, FilenameEnd));
   
   bool isAngled = GetIncludeFilenameSpelling(FilenameTok.getLocation(),
                                              FilenameStart, FilenameEnd);
@@ -1320,6 +1324,10 @@
   // If the macro is not defined, this is a noop undef, just return.
   if (MI == 0) return;
 
+  if (Callbacks)
+    Callbacks->UndefDirective(UndefTok.getLocation(),
+                              std::string(MacroNameTok.getIdentifierInfo()->getName()));
+  
   if (!MI->isUsed())
     Diag(MI->getDefinitionLoc(), diag::pp_macro_not_used);
   
