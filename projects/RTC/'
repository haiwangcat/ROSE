#ifndef ARITHCHECK_C
#define ARITHCHECK_C
#include "ArithCheck.h"
#include "sageGeneric.h"
#include <string>
#include <boost/lexical_cast.hpp>

#define STRUCT_ARRAY 7




using namespace SageInterface;
using namespace SageBuilder;

SgType* ArithCheck::created_struct_type;
unsigned int ArithCheck::VarCounter = 0;
TypeMap_t ArithCheck::UnderlyingType;
TypeMap_t ArithCheck::RelevantStructType;
NodeContainer ArithCheck::NodesToInstrument;
VariableSymbolMap_t ArithCheck::varRemap;
VariableSymbolMap_t ArithCheck::ReverseMap;
SgFunctionDeclaration* ArithCheck::MallocWrapFnDecl;
FuncInfoList ArithCheck::ForwardDecls;
uint64_t ArithCheck::TravCtr = 0;
StringClassMap_t ArithCheck::TransClassDecls;
TypeMap_t ArithCheck::RelevantArgStructType;
NameVarMap_t ArithCheck::VarDeclForName;

SgInitializedName* getNameForDecl(SgVariableDeclaration* decl);


void printInfo(SgBinaryOp* Parent, SgExpression* LHS, SgExpression* RHS) {
  Sg_File_Info* ParentFile = isSgNode(Parent)->get_file_info();
  printf("----------------------------------------\n");
  printf("BinaryOp: (%s, %d, %d) %s = %s\n", ParentFile->get_filenameString().c_str(),
                      ParentFile->get_line(),
                      ParentFile->get_col(),
                      isSgNode(Parent)->sage_class_name(),
                      isSgNode(Parent)->unparseToString().c_str());


  printf("Operand: LHS: %s = %s\n", isSgNode(LHS)->sage_class_name(), isSgNode(LHS)->unparseToString().c_str());
  printf("Operand: RHS: %s = %s\n", isSgNode(RHS)->sage_class_name(), isSgNode(RHS)->unparseToString().c_str());
  printf("----------------------------------------\n");
}


char* getStringForVariantT(VariantT var) {
  char* output = (char*)malloc(50*sizeof(char));

  switch(var) {
  case V_SgAddOp: sprintf(output, "Add"); break;
  case V_SgSubtractOp: sprintf(output, "Sub"); break;
  case V_SgMultAssignOp: //printf("MultAssignOp\n");
  case V_SgMultiplyOp: sprintf(output, "Mult"); break;
  case V_SgDivAssignOp: //printf("DivAssignOp\n");
  case V_SgDivideOp: sprintf(output, "Div"); break;
  case V_SgLessThanOp: sprintf(output, "LessThan"); break;
  case V_SgGreaterThanOp: sprintf(output, "GreaterThan"); break;
  case V_SgNotEqualOp: sprintf(output, "NotEqual"); break;
  case V_SgLessOrEqualOp: sprintf(output, "LessOrEqual"); break;
  case V_SgGreaterOrEqualOp: sprintf(output, "GreaterOrEqual"); break;
  case V_SgEqualityOp: sprintf(output, "Equality"); break;
  case V_SgModOp: sprintf(output, "Mod"); break;
  case V_SgIntegerDivideOp: sprintf(output, "IntDiv"); break;
  case V_SgTypeInt: sprintf(output, "Int"); break;
  case V_SgIntVal: sprintf(output, "Int"); break;
  case V_SgTypeUnsignedInt: sprintf(output, "UInt"); break;
  case V_SgUnsignedIntVal: sprintf(output, "UInt"); break;
  case V_SgTypeUnsignedLong: sprintf(output, "ULong"); break;
  case V_SgUnsignedLongVal: sprintf(output, "ULong"); break;
  case V_SgTypeUnsignedLongLong: sprintf(output, "ULongLong"); break;
  case V_SgUnsignedLongLongIntVal: sprintf(output, "ULongLong"); break;
  case V_SgTypeLongLong: sprintf(output, "LongLong"); break;
  case V_SgLongLongIntVal: sprintf(output, "LongLong"); break;
  case V_SgTypeLong: sprintf(output, "Long"); break;
  case V_SgLongIntVal: sprintf(output, "Long"); break;
  case V_SgTypeShort: sprintf(output, "Short"); break;
  case V_SgShortVal: sprintf(output, "Short"); break;
  case V_SgTypeChar: sprintf(output, "Char"); break;
  case V_SgTypeVoid: sprintf(output, "Void"); break;
  case V_SgFloatVal:
  case V_SgTypeFloat: sprintf(output, "Float"); break;
  case V_SgDoubleVal:
  case V_SgTypeDouble: sprintf(output, "Double"); break;
  case V_SgPlusPlusOp: sprintf(output, "Increment"); break;
  case V_SgMinusMinusOp: sprintf(output, "Decrement"); break;
  case V_SgPlusAssignOp: sprintf(output, "PlusAssign"); break;
  case V_SgMinusAssignOp: sprintf(output, "MinusAssign"); break;
  case V_SgAssignOp: sprintf(output, "Assign"); break;
  case V_SgAddressOfOp: sprintf(output, "AddressOf"); break;
  case V_SgCastExp: sprintf(output, "Cast"); break;
  case V_SgPntrArrRefExp: sprintf(output, "PntrArrRef"); break;
  default: sprintf(output, "IDK_%u", var);
  }

  return output;
}

char* ArithCheck::getStringFor(enum OVL_TYPE op) {
  char* output = (char*)malloc(50*sizeof(char));
  switch(op) {
  case DEREF: sprintf(output, "Deref"); break;
  case CAST: sprintf(output, "Cast"); break;
  case SPECIAL_CAST: sprintf(output, "SpecialCast"); break;
  case STRUCT: sprintf(output, "Struct"); break;
  case NORMAL: sprintf(output, "Normal"); break;
  default: sprintf(output, "DontKnow"); break;
  }

  return output;
}


char* getString(VariantT Res, VariantT Op, VariantT LHS, VariantT RHS) {

  char* ResString = getStringForVariantT(Res);
  char* OpString = getStringForVariantT(Op);
  char* LHSString = getStringForVariantT(LHS);
  char* RHSString = getStringForVariantT(RHS);

  char* FunctionBuf = (char*)malloc(50*sizeof(char));
  sprintf(FunctionBuf, "%s_%s_%s_%s", ResString, OpString, LHSString, RHSString);
  //printf("FunctionBuf: %s\n", FunctionBuf);
  return FunctionBuf;
}

#if 0
nodeType getNodeType(SgNode* node) {

  if(isSgExpression(node)) {
    nodeType temp(isSgExpression(node)->get_type(), node);
    return temp;
  }
  else {
    nodeType temp(node);
    return temp;
  }
}
#endif

bool OverloadOp(SgNode* node) {

  switch(node->variantT()) {
  case V_SgAddOp:
  case V_SgSubtractOp:
  case V_SgPlusPlusOp:
  case V_SgMinusMinusOp:
  case V_SgGreaterThanOp:
  case V_SgLessThanOp:
  case V_SgGreaterOrEqualOp:
  case V_SgLessOrEqualOp:
  case V_SgEqualityOp:
  case V_SgCastExp:
  case V_SgNotEqualOp: return true;
  default: return false;
  }

}

bool isPointerDeref(SgNode* node) {
  return isSgPointerDerefExp(node);
}

bool isConditionalOp(SgNode* node) {
  // Conditional ops are binary ops
  if(!isSgBinaryOp(node)) {
    return false;
  }
  else  {
    SgBinaryOp* bop = isSgBinaryOp(node);

    switch(bop->variantT()) {
    case V_SgGreaterOrEqualOp:
    case V_SgLessOrEqualOp:
    case V_SgLessThanOp:
    case V_SgGreaterThanOp:
    case V_SgNotEqualOp:
    case V_SgEqualityOp: return true;
    default: return false;
    }
  }
  ROSE_ASSERT(0);
}


nodeType TopBotTracking::evaluateSynthesizedAttribute(SgNode* node,
        nodeType inh, SynthesizedAttributesList synList) {

  printf("Ev-Synth-Attr\n");
  printf("Counter: %llu\n", ArithCheck::TravCtr++);
  printf("Current: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());

  // NOT CLASS DEFINITIONS. DEFINING CLASS DECLARATIONS
  // Here, we catch class definitions -- we need to create structed versions
  // of these classes so that we can store pointer tracking information for pointer
  // members of structures and classes
  #if 0
  if(isSgClassDefinition(node)) {
    NodesToInstrument.push_back(node);
  }
  #endif
  if(isSgClassDeclaration(node)) {
    if(isSgClassDeclaration(node)->get_definition() != NULL) {
      printf("Found a defining class declaration\n");
      ArithCheck::NodesToInstrument.push_back(node);
    }
  }

  // Here, we catch variable declarations -- of the following types:
  // 1. WITHIN_FN_DEF -- these will replaced by structed versions later
  // 2. WITHIN_PARAMLIST -- these will be replaced by pairs consisting of original pointer and
  // corresponding structed version
  // Instead of using SgInitializedName, we'll use variable declarations, since we'll be
  // creating new variables anyway
  #if 0
  if(isSgInitializedName(node) && (inh.inhattr == WITHIN_FN_DEF || inh.inhattr == WITHIN_PARAMLIST)) {
    ArithCheck::NodesToInstrument.push_back(node);
  }
  #endif
  if(isSgVariableDeclaration(node) &&
    (inh.inhattr == WITHIN_FN_DEF || inh.inhattr == WITHIN_PARAMLIST || inh.inhattr == WITHIN_GLOBAL)) {
    ArithCheck::NodesToInstrument.push_back(node);
  }

  // These are the variable within the parameter list.
  // Parameters don't have a var decl, above initialized name
  if(isSgInitializedName(node) && isSgFunctionParameterList(node->get_parent())) {
    ArithCheck::NodesToInstrument.push_back(node);
  }


  // FIXME: This is just a filler. Not really using the synthesized attribute for
  // any purpose right now.
  nodeType synattr(UNKNOWN, INH_UNKNOWN);
  return synattr;

  #if 0
  // Just checking -- no relevance to current code
  if(isSgPointerDerefExp(node)) {
    printf("Found Pointer Deref - TopBot\n");
    printf("Type: %s\n", isSgPointerDerefExp(node)->get_type()->class_name().c_str());
  }

  // Filler -- just for testing
  if(isSgInitializedName(node) && inh.inhattr != PAR_CLASS_DEF) {
    printf("Found candidate initialized name\n");
    return nodeType(STR_TYPE);
  }
  else {
    return nodeType(NOT_STR_TYPE);
  }
  #endif

}


nodeType TopBotTracking::evaluateInheritedAttribute(SgNode* node,
        nodeType inh) {

  printf("Ev-Inh-Attr\n");
  printf("Counter: %llu\n", ArithCheck::TravCtr++);
  printf("Current: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());

  if(isSgFunctionDefinition(node)) {
    printf("Found function definition\n");
    nodeType inhres(UNKNOWN, WITHIN_FN_DEF);
    return inhres;
  }

  if(isSgClassDefinition(node)) {
    printf("Found class definition\n");
    nodeType inhres(UNKNOWN, WITHIN_CLASS_DEF);
    return inhres;
  }

  if(isSgGlobal(node)) {
    printf("Found Global\n");
    nodeType inhres(UNKNOWN, WITHIN_GLOBAL);
    return inhres;
  }

  if(isSgFunctionParameterList(node)) {
    printf("Found Parameter List\n");
    nodeType inhres(UNKNOWN, WITHIN_PARAMLIST);
    return inhres;
  }

  return inh;

  #if 0
  if(inh.inhattr == PAR_CLASS_DEF) {
    printf("inh = PAR_CLASS_DEF. Result PAR_CLASS_DEF\n");
    return inh;
  }

  if(isSgClassDefinition(node)) {
    printf("Found class def. Inherting PAR_CLASS_DEF\n");
    nodeType inhres(UNKNOWN, PAR_CLASS_DEF);
    return inhres;
  }
  else {
    printf("Not Class Def\n");
    nodeType inhres(UNKNOWN, NO_CLASS_DEF);
    return inhres;
  }

  ROSE_ASSERT(0);
  #endif
}

// We need to treat variables of ArrayType the same way as we
// treat the PointerType -- i.e. everywhere the ArrayType is in an
// op, we need to overload it. In many cases, we wouldn't catch the
// array type, but the output of V_SgPntrArrRefExp --- which
// is similar to Deref

#if 0
bool NeedsToBeOverloaded(SgNode* node) {

  switch(node->variantT()) {
  case V_SgAddOp:
  case V_SgSubtractOp:
  case V_SgPlusPlusOp:
  case V_SgMinusMinusOp:
  case V_SgPlusAssignOp:
  case V_SgMinusAssignOp:
  case V_SgCastExp:
  case V_SgAddressOfOp:
  case V_SgAssignOp:
    if(isSgPointerType(isSgExpression(node)->get_type())) return true;
    else return false;
  case V_SgPntrArrRefExp: return true;
  default: return false;
  }
}
#endif

bool NeedsToBeOverloaded(SgNode* node) {

  switch(node->variantT()) {
  case V_SgAddOp:
  case V_SgSubtractOp:
  case V_SgPlusPlusOp:
  case V_SgMinusMinusOp:
  case V_SgPlusAssignOp:
  case V_SgMinusAssignOp:
  case V_SgAssignOp: return true;
  default: return false;
  }
}

bool isQualifyingType(SgType* type) {
  printf("QualifyingType: ");
  if(isSgPointerType(type) && isSgArrayType(type)) {
    printf("both pointer and array type!\n");
    ROSE_ASSERT(0);
  }

  if(isSgPointerType(type)) {
    printf("Pointer\n");
    return true;
  }
  else if(isSgArrayType(type)) {
    printf("Array\n");
    return true;
  }
  else {
    printf("Not qual type\n");
    return false;
  }
}

void CheckExprSanity(SgExpression* expr) {

  if(isQualifyingType(expr->get_type())) {
    if(SgBinaryOp* bop = isSgBinaryOp(expr)) {
      ROSE_ASSERT(isQualifyingType(bop->get_lhs_operand()->get_type()) ||
            isQualifyingType(bop->get_rhs_operand()->get_type()));
    }
    else if(SgUnaryOp* uop = isSgUnaryOp(expr)) {
      ROSE_ASSERT(isQualifyingType(uop->get_operand()->get_type()));
    }
    else {
      printf("Can't check sanity for expr:\n");
      printf("expr: %s = %s\n", isSgNode(expr)->sage_class_name(), isSgNode(expr)->unparseToString().c_str());
      ROSE_ASSERT(0);
    }
  }
}

// Not using inherited attribute since we aren't looking at classes and data
// structures for now
nodeType TopBotTrack2::evaluateSynthesizedAttribute(SgNode* node,
        nodeType inh, SynthesizedAttributesList synList) {

  printf("TopBotTrack2: Ev_Synth_Attr\n");
  printf("Current: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());


  printf("Is variable declaration? ");
  if(isSgVariableDeclaration(node)) {
    printf("Yes\n");

    SgVariableDeclaration* var_decl = isSgVariableDeclaration(node);

    SgInitializedName* var_name = getNameForDecl(var_decl);

    SgType* var_type = var_name->get_type();

    // FIXME: We don't do anything to uninitialized variable decls
    // and they could be filtered out here.

    if(isQualifyingType(var_type)) {
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
      return synattr;
    }

    #if 0

    SgType* var_type = var_name->get_type();
    printf("is it a pointer variable?");
    if(isSgPointerType(var_type)) {
      printf("Yes\n");
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      printf("No\n");
    }

    printf("is it an array decl?");
    if(isSgArrayType(var_type)) {
      printf("Yes\n");
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      printf("No\n");
    }


    printf("Neither.. not a candidate for checking\n");
    // This is a variable declaration which isn't pointer type.
    // Return NOT_STR_TYPE
    nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
    return synattr;
    #endif
  }
  else {
    // Not var decl at all. don't do anything
    printf("No\n");
  }


  printf("is variable reference? ");
  if(isSgVarRefExp(node)) {
    printf("Yes\n");

    SgVarRefExp* var_ref = isSgVarRefExp(node);
    SgType* var_type = var_ref->get_type();

    if(isQualifyingType(var_type)) {
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
      return synattr;
    }

    #if 0
    if(isSgArrayType(var_ref->get_type()) && isSgPointerType(var_ref->get_type())) {
      printf("Both array type and pointer type!\n");
      ROSE_ASSERT(0);
    }


    printf("Is pointer variable reference exp? ");
    if(isSgPointerType(var_ref->get_type())) {
      printf("Yes\n");
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      printf("No\n");
    }

    printf("Is array reference exp? ");
    if(isSgArrayType(var_ref->get_type())) {
      printf("Yes\n");
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      printf("No\n");
    }

    printf("Neither .. not a candidate for checking\n");
    // This is a var ref which isn't pointer type.
    // Return NOT_STR_TYPE
    nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
    return synattr;
    #endif
  }
  else {
    // Not var decl at all. don't do anything
    printf("No\n");
  }

  printf("Is it a function call?");
  if(isSgFunctionCallExp(node)) {
    printf("Yes\n");
    SgFunctionCallExp* fncall = isSgFunctionCallExp(node);

    SgType* fncall_type = fncall->get_type();
    if(isQualifyingType(fncall_type)) {
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
      return synattr;
    }

    #if 0
    if(strcmp(fncall->getAssociatedFunctionDeclaration()->get_name().str(), "malloc") == 0) {
      printf("Its a malloc call\n");
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    // Lets find the return type for this function call
    // In fact, this can be merged with malloc call as well
    // FIXME: If the parameters to a function call are of poitner type
    // should we treat them differently than var_ref_exp? and instead
    // rebuild the whole func call exp?
    // Actually, even if the function does return a pointer, we don't
    // have to touch it right?
    else if(isSgPointerType(fncall->get_type())) {
      printf("Its a function call that returns a pointer\n");
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else if(isSgArrayType(fncall->get_type())) {
      printf("Function returns an array?");
      ROSE_ASSERT(0);
    }
    else {
      printf("Its a function call that doesn't return a pointer\n");
      nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    #endif
  }
  else {
    // not a func call exp. don't do anything
    printf("No\n");
  }


  // FIXME: In the case of deref exp, we can't blind move from
  // STR_TYPE to NOT_STR_TYPE since it could be a double pointer
  // in which case, the return type would also be STR_TYPE
  // We might need to investigate how our technique would handle
  // such a case since we shouldn't always return VoidStruct or
  // the POD type for a deref. The return type changes based on
  // the input type... which is not known in VoidStruct
  // But we would know this statically, so, we could use a different
  // Deref_Overload_DoublePtr in that case which would output
  // a VoidStruct

  // In case of a deref_exp we would need to check here if the
  // operand is a single or double pointer, since that defines
  // where we return a STR_TYPE or a NOT_STR_TYPE

  // FIXME: I don't think the code below detects double pointers correctly
  // And, I am not sure, how we would actually handle double pointer cases
  // This piece of code is causing the runs to crash for some reason.
  // Commenting it out
  #if 1
  printf("is it a deref exp?");
  if(isSgPointerDerefExp(node)) {
    printf("Yes\n");

    SgPointerDerefExp* ptr_deref = isSgPointerDerefExp(node);


    // Check that all derefs do in fact, operate on pointers or
    // arrays!
    SgExpression* oper = ptr_deref->get_operand();
    ROSE_ASSERT(isQualifyingType(oper->get_type()));

    // There is always work to do on a deref!
    ArithCheck::NodesToInstrument.push_back(node);

    if(isQualifyingType(ptr_deref->get_type())) {
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
      return synattr;
    }

    #if 0
    if(isSgPointerType(ptr_deref->get_type())) {
      printf("deref exp is returning pointer type. Return: STR_TYPE\n");
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      printf("deref exp is *not* returning pointer type. Return: NOT_STR_TYPE\n");
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    #endif
  }
  else {
    // Not a pointer deref exp. do nothing
    printf("No\n");
  }
  #endif


  printf("is it a pntr arr ref exp? ");
  if(isSgPntrArrRefExp(node)) {
    printf("Yes\n");

    SgPntrArrRefExp* array_ref = isSgPntrArrRefExp(node);

    // Check that all pnts arr refs operate on pointers or
    // arrays
    SgExpression* oper = array_ref->get_lhs_operand();
    ROSE_ASSERT(isQualifyingType(oper->get_type()));

    // There is always work to do on an pntr arr ref!
    ArithCheck::NodesToInstrument.push_back(node);

    if(isQualifyingType(array_ref->get_type())) {
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
      return synattr;
    }

  }
  else {
    // Not a pointer deref exp. do nothing
    printf("No\n");
  }

  printf("is it a dot exp? ");
  if(isSgDotExp(node)) {
    printf("Yes\n");

    SgDotExp* dot_exp = isSgDotExp(node);

    // Technically, only those dot expressions dealing with
    // pointers and arrays matter to us... since the others
    // are dealing with obj.var refs.
    SgType* dot_exp_type = dot_exp->get_type();

    if(isQualifyingType(dot_exp_type)) {
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
  }
  else {
    printf("No\n");
  }

  printf("is it an arrow exp? ");
  if(isSgArrowExp(node)) {
    printf("Yes\n");

    SgArrowExp* arrow_exp = isSgArrowExp(node);

    // Arrow expressions always work on pointers... and maybe
    // array types -- not sure how though. In any case,
    // has to qualifying type. And there's work to do!
    SgExpression* oper = arrow_exp->get_lhs_operand();
    ROSE_ASSERT(isQualifyingType(oper->get_type()));

    // There is always work to do on an arrow exp!
    ArithCheck::NodesToInstrument.push_back(node);

    if(isQualifyingType(arrow_exp->get_type())) {
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
  }
  else {
    printf("No\n");
  }

  // Handle cast exp here itself since it can create a pointer out
  // of nowhere, through arbitrary casts.
  printf("is it a cast exp? ");
  if(isSgCastExp(node)) {
    printf("Yes\n");

    SgCastExp* cast_exp = isSgCastExp(node);

    // If the operand or
    // the return type are of qualifying type, then
    // there is work to do.
    SgExpression* oper = cast_exp->get_operand();

    if(isQualifyingType(cast_exp->get_type()) ||
      isQualifyingType(oper->get_type())) {
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
  }
  else {
    printf("No\n");
  }

  // Address Of Op can also create a qualifying type out of any variable....
  // So, we are definitely looking at a qualifying type here.
  printf("is address of op? ");
  if(isSgAddressOfOp(node)) {
    printf("Yes\n");

    SgAddressOfOp* addr_of = isSgAddressOfOp(node);

    // Assert that we create a qualifying type
    ROSE_ASSERT(isQualifyingType(addr_of->get_type()));
    ArithCheck::NodesToInstrument.push_back(node);
    nodeType synattr(STR_TYPE, INH_UNKNOWN);
    return synattr;
  }
  else {
    printf("No\n");
  }


  // Lets handle the comma op case, where the type is determined
  // by the last expression type
  // No need to add to NodesToInstrument since we don't have to
  // do anything for a comma op
  printf("is comma op?");
  if(isSgCommaOpExp(node)) {
    printf("Yes\n");

    // Find the type we are looking for in the
    // last synthesized attribute
    nodeType nt = synList[synList.size() - 1];
    if(nt.attr == NOT_STR_TYPE) {
      printf("Not returning pointer from comma op\n");
      nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else if(nt.attr == STR_TYPE) {
      printf("Returning pointer from comma op\n");
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      // FIXME: Should we return UNKNOWN?
      printf("FIXME: Unknown type from comma op. Need to look at node type\n");
      ROSE_ASSERT(0);
    }
  }
  else {
    //Not comma op. don't do anything
    printf("No\n");
  }


  // Conditional ops. They might take in structs, but always
  // return bool (NOT_STR_TYPE)
  printf("is it a conditional op?");
  if(isConditionalOp(node)) {
    printf("Yes\n");

    SgBinaryOp* bop = isSgBinaryOp(node);

    SgExpression* LHS = bop->get_lhs_operand();
    SgExpression* RHS = bop->get_rhs_operand();

    if(isQualifyingType(LHS->get_type()) ||
      isQualifyingType(RHS->get_type())) {
      ArithCheck::NodesToInstrument.push_back(node);
    }

    printf("Return NOT_STR_TYPE\n");
    nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
    return synattr;

    #if 0

    // Check if the arguments pointers. If they
    // are, this operation needs to be overloaded
    SgBinaryOp* bop = isSgBinaryOp(node);
    ROSE_ASSERT(bop != NULL);

    SgExpression* LHS = bop->get_lhs_operand();
    SgExpression* RHS = bop->get_rhs_operand();

    ROSE_ASSERT(LHS != NULL);
    ROSE_ASSERT(RHS != NULL);

    printf("got operands\n");

    SgType* LHS_Type = LHS->get_type();
    SgType* RHS_Type = RHS->get_type();

    printf("got types. checking for NULL\n");

    ROSE_ASSERT(LHS_Type != NULL);
    ROSE_ASSERT(RHS_Type != NULL);

    printf("checking if pointer types\n");

    if(isSgPointerType(LHS_Type) ||
      isSgPointerType(RHS_Type)) {
      printf("One or both operands are of pointer type.\n");
      ArithCheck::NodesToInstrument.push_back(node);
    }
    else {
      printf("None of the operands are pointers\n");
    }

    printf("Return NOT_STR_TYPE\n");
    nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
    return synattr;
    #endif
  }
  else {
    // Not a conditional op. Nothing to do
    printf("No\n");
  }




  // FIXME: We already handled var decls above. So, the initialized names that we handle here are
  // those that are in the func param lists. Find a way to handle them, and instrument the body
  // of the function so that the original pointer is recreated, and the struct variable is
  // correctly maintained.
  // We only pick up the initialized names in a func param list. In fact, we could pick up
  // just function declarations or func param lists, instead of looking at these
  // initialized names at all
  // Lets look at function declarations, since if the declaration is not a forward decl, i.e.
  // its a defining decl, we would need to make changes to the body of the function as well
  // We would need to make changes at the level of the function decl if
  // 1. the return type is pointer
  // 2. one or more arguments to the function is a pointer

  // Can't use func decl for parameter replacement
  // since var ref replacement would happen in the body before we reach this
  // stage. So, in order to have changes in parameter lists, to reflect in the body of the function
  // we need to catch the parameter lists, and make all the changes there, before we hit
  // the body, since the varRemap would need to contain the new versions of old variables
  // The highest level we can make this work is by starting with the parameter lists.
  // lets start there

  // So, we do the parameter replacement in the SgFunctionParameterList node
  // The return type change will still happen in the func decl as before

  printf("is it a param list?");
  if(isSgFunctionParameterList(node)) {
    printf("Yes\n");

    SgInitializedNamePtrList& name_list = isSgFunctionParameterList(node)->get_args();

    for(SgInitializedNamePtrList::iterator iter = name_list.begin(); iter != name_list.end(); ++iter) {

      SgInitializedName* name = *iter;


      if(isQualifyingType(name->get_type())) {
        printf("Arg qualifies\n");
        ArithCheck::NodesToInstrument.push_back(node);
        break;
      }

      #if 0
      if(isSgPointerType(name->get_type())) {
        printf("Arg is pointer type\n");
        ArithCheck::NodesToInstrument.push_back(node);
        break;
      }
      else if(isSgArrayType(name->get_type())) {
        printf("Arg is array type?\n");
        ROSE_ASSERT(0);
      }
      #endif
    }
  }
  else {
    // Not a param list. nothing to do
    printf("No\n");
  }





  printf("is it a func decl?");
  if(isSgFunctionDeclaration(node)) {
    printf("Yes\n");


    SgFunctionDeclaration* fn_decl = isSgFunctionDeclaration(node);
    // Find return type
    SgFunctionType* fn_type = fn_decl->get_type();
    SgType* ret_type = fn_type->get_return_type();

    if(isQualifyingType(ret_type)) {
      ArithCheck::NodesToInstrument.push_back(node);
    }

    printf("Always returning NOT_STR_TYPE\n");
    nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
    return synattr;


    #if 0
    // Only checking the return type... not the parameter list
    if(isSgPointerType(ret_type)) {
      printf("Function returns pointer. Added to NodesToInstrument. \n");
      ArithCheck::NodesToInstrument.push_back(node);
    }
    else {
      printf("Function doesn't return pointer. \n");
    }


    #if 0
    if(isSgPointerType(ret_type)) {
      printf("Function returns pointer. Added to NodesToInstrument. \n");
      ArithCheck::NodesToInstrument.push_back(node);
    }
    else {
      printf("Function return type is not a pointer. Checking parameters\n");

      SgFunctionParameterTypeList* param_type_list = fn_type->get_argument_list();

      SgTypePtrList& type_list = param_type_list->get_arguments();

      for(SgTypePtrList::iterator iter = type_list.begin(); iter != type_list.end(); iter++) {

        SgType* arg_type = *iter;
        if(isSgPointerType(arg_type)) {
          printf("Arg is pointer type\n");
          ArithCheck::NodesToInstrument.push_back(node);
          break;
        }
      }
    }
    #endif
    printf("Always returning NOT_STR_TYPE\n");
    nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
    return synattr;
    #endif
  }
  else {
    // Not a func decl, nothing to do
    printf("No\n");
  }


  printf("is it an overloadable op?");
  // Arith ops...
  if(NeedsToBeOverloaded(node)) {
    printf("Yes\n");

    // These are all expressions
    ROSE_ASSERT(isSgBinaryOp(node) || isSgUnaryOp(node));
    SgExpression* expr = isSgExpression(node);
    ROSE_ASSERT(expr != NULL);
    // The result of should be of qualifying type
    // to consider this node.
    if(isQualifyingType(expr->get_type())) {
      CheckExprSanity(expr);
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE, INH_UNKNOWN);
      return synattr;
    }
    else {
      nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
      return synattr;
    }

    #if 0
    printf("Returning STR_TYPE\n");
    nodeType synattr(STR_TYPE, INH_UNKNOWN);
    return synattr;
    #endif
  }
  else {
    // need not be overloaded. Nothing to do.
    printf("No\n");
  }


  // One golden rule which we can apply to figure out the relevant nodes -- i.e. the
  // ones that we need to manipulate -- is to see if a node actually has a get_type()
  // or rather, if a node has an associated type. If it doesn't have a type
  // associated with it, it doesn't return any value, right? this means,
  // it need not be overloaded, or changed in any way.


  //printf("Not propagating attributes upwards\n");
  //nodeType synattr(UNKNOWN, INH_UNKNOWN);

  printf("Propagating NOT_STR_TYPE\n");
  nodeType synattr(NOT_STR_TYPE, INH_UNKNOWN);
  return synattr;


}

nodeType TopBotTrack2::evaluateInheritedAttribute(SgNode* node,
                        nodeType inh) {
  #if 0
  printf("TopBotTrack2: Ev_Inh_Attr\n");
  printf("Current: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());

  printf("Doing nothing right now.\n");
  #endif

  return inh;

}

nodeType BUTracking::evaluateSynthesizedAttribute(SgNode* node,
            SynthesizedAttributesList synList) {


  printf("Current: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());

  // We simply find out if any of the children of the current node are of STR_TYPE
  // If they are, then this node is also of STR_TYPE
  bool found = false;
  bool unknown = false;

  for(SynthesizedAttributesList::iterator sit = synList.begin();
                  sit != synList.end(); ++sit) {
    nodeType nt = *sit;
    if(nt.attr == STR_TYPE) {
      found = true;
      break;
    }
    if(nt.attr == UNKNOWN) {
      unknown = true;
    }
  }
  if(found) {
    // For PointerDerefExp, although child node is STR_TYPE
    // the return is NOT_STR_TYPE
    if(isSgPointerDerefExp(node)) {
      printf("Pointer Deref. Child node is STR_TYPE. Return: NOT_STR_TYPE\n");
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(NOT_STR_TYPE);
      return synattr;
    }
    else if(isSgCommaOpExp(node)) {
    // For comma ops, only the *last* attribute is the one that
    // matters since it is the value returned. So, if the last
    // attribute is NOT_STR_TYPE, then return value is NOT_STR_TYPE
    // If it is STR_TYPE, then return is STR_TYPE
      printf("CommaOpExp. Last attr checked\n");
      nodeType nt = synList[synList.size() - 1];
      if(nt.attr == NOT_STR_TYPE) {
        printf("Return: NOT_STR_TYPE\n");
        nodeType synattr(NOT_STR_TYPE);
        return synattr;
      }
      else {
        printf("Return: STR_TYPE\n");
        ArithCheck::NodesToInstrument.push_back(node);
        nodeType synattr(NOT_STR_TYPE);
        return synattr;
      }
    }
    else if(SgFunctionDeclaration* fndecl = isSgFunctionDeclaration(node)) {

      printf("SgFunctionDeclaration\n");
      if(fndecl->get_type()->get_return_type()->variantT() == V_SgPointerType) {
        printf("Return type is Pointer Type. Added to NodesToInstrument\n");
        ArithCheck::NodesToInstrument.push_back(node);
      }
      nodeType synattr(NOT_STR_TYPE);
      return synattr;
    }
    else if(isConditionalOp(node)) {
      // Conditional ops return bool. so, we return
      // NOT_STR_TYPE
      // But the ops themselves need to be overloaded
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(NOT_STR_TYPE);
      return synattr;
    }
    else {
    // For all other nodes, if child is STR_TYPE, we have to modify
    // the upper level as well, so we return NOT_STR_TYPE
      printf("Child node is STR_TYPE. Return: STR_TYPE\n");
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE);
      return synattr;
    }
  }
  else {

    if(SgExpression* exp = isSgExpression(node)) {
      printf("SgExpression\n");
//      if(exp->get_type() == SgPointerType::createType()) {
//      if(exp->get_type()->variantT() == V_SgPointerType) {
      if(isSgPointerType(exp->get_type())) {
        printf("Found SgPointerType\n");
        ArithCheck::NodesToInstrument.push_back(node);
        nodeType synattr(STR_TYPE);
        return synattr;
      }
      else {
        printf("Not Pointer Type\n");
        nodeType synattr(NOT_STR_TYPE);
        return synattr;
      }
    }
    else if(SgInitializedName* name = isSgInitializedName(node)) {
      printf("SgInitializedName\n");
//      if(name->get_type() == SgPointerType::createType()) {
//      if(name->get_type()->variantT() == V_SgPointerType) {
      if(isSgPointerType(name->get_type())) {
        printf("Found SgPointerType\n");
        ArithCheck::NodesToInstrument.push_back(node);
        nodeType synattr(STR_TYPE);
        return synattr;
      }
      else {
        printf("Not Pointer Type\n");
        nodeType synattr(NOT_STR_TYPE);
        return synattr;
      }
    }
    else if(SgFunctionDeclaration* fndecl = isSgFunctionDeclaration(node)) {

      printf("SgFunctionDeclaration\n");
      if(fndecl->get_type()->get_return_type()->variantT() == V_SgPointerType) {
        printf("Return type is Pointer Type. Added to NodesToInstrument\n");
        ArithCheck::NodesToInstrument.push_back(node);
      }
      nodeType synattr(NOT_STR_TYPE);
      return synattr;
    }
    else if(SgStatement* stmt = isSgStatement(node)) {
      printf("Found SgStatement. Return: NOT_STR_TYPE\n");
      nodeType synattr(NOT_STR_TYPE);
      return synattr;
    }
    else if(isSgSourceFile(node)) {
      nodeType synattr(NOT_STR_TYPE);
      return synattr;
    }


    // If one of the child nodes is of UNKNOWN
    // type, then we need to figure the exact type
    // by finding the child node's type and propagating
    if(unknown) {
      printf("Found UNKNOWN case\n");
      nodeType synattr(UNKNOWN);
      return synattr;
    }

    ROSE_ASSERT(0);
  }

}


nodeType derefTypeTracking::evaluateSynthesizedAttribute(SgNode* node,
            SynthesizedAttributesList synList) {

  printf("Current: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());

  if(isPointerDeref(node)) {
    printf("PointerDeref\n");
    SgPointerDerefExp* ptrderef = isSgPointerDerefExp(node);
    SgUnaryOp* uop = isSgUnaryOp(ptrderef);

    // The # of syn attributes has to be 1
    ROSE_ASSERT(synList.size() == 1);
    // And that attribute has to be of struct_type
    // since we instrument all pointers
    SynthesizedAttributesList::iterator sit = synList.begin();
    nodeType nt = *sit;

    SgExpression* exp = uop->get_operand();
    ROSE_ASSERT(exp->get_type() == ArithCheck::created_struct_type);

    // We don't check the lower nodes in thsi traversal. So, this
    // doesn't hold
    //ROSE_ASSERT(nt.attr == STR_TYPE);
    // Now, the synthesized attribute for this
    // derefexp is NOT_STR_TYPE (since the output
    // of a deref exp is not a struct_type)
    ArithCheck::NodesToInstrument.push_back(node);
    nodeType synattr(NOT_STR_TYPE);
    return synattr;
  }
  // Doesn't matter -- not to be used for
  // sending synthesized attributes. This is just to catch
  // pointer deref expressions
  nodeType synattr(NOT_STR_TYPE);
  return synattr;
}


// The difference between this version of the function and the next is the following:
// This version distinguishes nodes as STR_TYPE and NOT_STR_TYPE nodes.
// The next version tries to propagate types all the way up the tree
// and tries to make decisions based on actual types which get carried
// through using synthesized attributes.
nodeType typeTracking::evaluateSynthesizedAttribute(SgNode* node,
            SynthesizedAttributesList synList) {


  printf("Current: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());

  // If this needs need not be overloaded,
  // then return appropriate attribute
  if(!OverloadOp(node) && !isPointerDeref(node)) {
    printf("Neither\n");
    // WRONG: If current node is a varrefexp *and* its type is struct_type
    // RIGHT: If current node is of struct_type
    // then synthesized attribute for this node is STR_TYPE

    // Since we can't say "node->get_type()" for two reasons
    // 1. node has no get_type()
    // 2. It crashes on certain types on nodes since we are
    // using classes (structs) in place of pointer variables
    #if 0
    if(node->get_type() == ArithCheck::created_struct_type) {
      nodeType synattr(STR_TYPE);
      return synattr;
    }
    else {
      nodeType synattr(NOT_STR_TYPE);
      return synattr;
    }
    #endif
    #if 1
    // we check if (i) is a varrefexp (ii) its of struct_type
    // if (i) and (ii) are true, then synthesized attr is STR_TYPE
    // else it is NOT_STR_TYPE
    ROSE_ASSERT(!isSgPointerDerefExp(node));
    if(isSgExpression(node)) {
    //if(isSgVarRefExp(node)) {
    //  if(isSgVarRefExp(node)->get_type() == ArithCheck::created_struct_type) {
    //  FIXME: This includes the SgDerefExp->get_type() case.
      if(isSgExpression(node)->get_type() == ArithCheck::created_struct_type) {
        nodeType synattr(STR_TYPE);
        return synattr;
      }
      else {
        nodeType synattr(NOT_STR_TYPE);
        return synattr;
      }
    }
    else {
      nodeType synattr(NOT_STR_TYPE);
      return synattr;
    }
    #endif

    #if 0
    for(SynthesizedAttributesList::iterator sit = synList.begin();
                    sit != synList.end(); ++sit) {
      nodeType nt = *sit;
      if(nt.attr == STR_TYPE) {
        found = true;
        break;
      }
    }

    if(found) {
      nodeType synattr(STR_TYPE);
      return synattr;
    }
    else {
      nodeType synattr(NOT_STR_TYPE);
      return synattr;
    }
    #endif
  }


  // If current node is a
  // plus
  // minus
  // plusplus
  // minusminus
  // greaterthan
  // lessthan
  // greaterthanorequal
  // lessthanorequal
  // equality
  // notequal
  // castexp
  // then, check if one if its synthesized attributes is
  // in fact a struct_type. If it is, then mark it for
  // overloading.
  // The synthesized attribute for this node is STR_TYPE
  if(OverloadOp(node)) {
    printf("OverloadOp\n");
    bool found = false;
    for(SynthesizedAttributesList::iterator sit = synList.begin();
                    sit != synList.end(); ++sit) {
      nodeType nt = *sit;
      if(nt.attr == STR_TYPE) {
        found = true;
        break;
      }
    }

    if(found) {
      ArithCheck::NodesToInstrument.push_back(node);
      nodeType synattr(STR_TYPE);
      return synattr;
    }
    else {
      nodeType synattr(NOT_STR_TYPE);
      return synattr;
    }
  }

  #if 1
  // If the current node is a derefexp
  // then, if its child is a node of struct_type
  // then, mark it for struct_type overloading
  // The synthesized attribute for this node is NOT_STR_TYPE
  if(isPointerDeref(node)) {
    printf("PointerDeref\n");
    SgPointerDerefExp* ptrderef = isSgPointerDerefExp(node);
    SgUnaryOp* uop = isSgUnaryOp(ptrderef);

    // The # of syn attributes has to be 1
    ROSE_ASSERT(synList.size() == 1);
    // And that attribute has to be of struct_type
    // since we instrument all pointers
    SynthesizedAttributesList::iterator sit = synList.begin();
    nodeType nt = *sit;
    ROSE_ASSERT(nt.attr == STR_TYPE);
    // Now, the synthesized attribute for this
    // derefexp is NOT_STR_TYPE (since the output
    // of a deref exp is not a struct_type)
    ArithCheck::NodesToInstrument.push_back(node);
    nodeType synattr(NOT_STR_TYPE);
    return synattr;
  }
  #endif
  #if 0
  // Deref'ed pointers cannot be of struct_type.
  if(SgPointerDerefExp* pexp =isSgPointerDerefExp(node)) {
    ROSE_ASSERT(pexp->get_type() != ArithCheck::created_struct_type);

    nodeType synattr(NOT_STR_TYPE);
    return synattr;
  }
  #endif


  ROSE_ASSERT(0);

}

#if 0
nodeType typeTracking::evaluateSynthesizedAttribute(SgNode* node,
            SynthesizedAttributesList synList) {


  printf("Current: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());

  // FIXME: Need to add function call expressions -- not just binary and unary ops
  // If its not a binary/unary op, then we just pass its type along. This part will handle
  // 1. If its a struct_type varrefexp, then its type will be passed to its parent
  // 2. If its an expression, its type will be passed to its parent
  // 3. If its not an expression, type = NULL is passed to its parent -- these are the
  // "don't care" cases
  if(!isSgBinaryOp(node) && !isSgUnaryOp(node)) {
    // Lets only consider the types for SgExpressions for now. Rest will
    // follow as required
    // This node is not useful to us
    printf("not binary/unary op\n");
    return getNodeType(node);
    #if 0
    nodeType currNode(node->get_type());
    return currNode;
    #endif
  }


  printf("Printing Binary Op Info in evaluateSynthesizedAttribute\n");
  if(isSgBinaryOp(node)) {
    printInfo(isSgBinaryOp(node), isSgBinaryOp(node)->get_lhs_operand(),
                  isSgBinaryOp(node)->get_rhs_operand());
  }
  printf("Done Printing\n");


  // We know that its a BinaryOp or a UnaryOp. If the operand(s) are of type struct_type,
  // then the current op will probably need to be converted to a function for C, or use
  // the overloaded operator.
  // So, we check if any of the operand(s) of this op, are actually struct_type
  bool found = false;
  for(SynthesizedAttributesList::iterator sit = synList.begin();
                    sit != synList.end(); ++sit) {

    nodeType nt = *sit;
    // Leaf node have nodeTypes initialized to NULL
    if(!nt.node) {
      continue;
    }
    ROSE_ASSERT(nt.node);
    printf("Node: %s = %s\n", nt.node->sage_class_name(), nt.node->unparseToString().c_str());
    if(nt.type == ArithCheck::created_struct_type) {
      printf("Found struct_type\n");
      found = true;
      break;
    }
  }

  // If none of the operands is of struct type, then the type of this op is passed
  // to its parents -- asserting that type != NULL, since this is a valid binary/unary op
  if(!found) {
    printf("No struct type child nodes found\n");
    // Lets only consider the types for SgExpressions for now. Rest will
    // follow as required
    nodeType temp = getNodeType(node);
    ROSE_ASSERT(temp.type != NULL);
    printf("Not reaching this point\n");
    return getNodeType(node);
    // This node is not useful to us
    //
    #if 0
    nodeType currNode(node->get_type());
    return currNode;
    #endif
  }

  ROSE_ASSERT(found);

  // Now, handle the BinaryOp and UnaryOp cases
  // For some unary ops -- deref -- output is type of the pointer
  // in struct
  // For most cases, output is created_struct_type
  // Add these node to a list. The nodes in the list will be replaced
  // by function calls to their operands

  // At this point, we have established that one or more the operands of this
  // node is a struct_type -- and this would eventually happen when the transformation
  // is performed bottom-up ... assert that this is the case in the transformation.
  // We add this node to the list of nodes which need to be overloaded by the corresponding
  // function

  // FIXED: Special case for unaryop: deref
  // Deref operations need to return the same type as before.
  ArithCheck::NodesToInstrument.push_back(node);
  printf("Found struct type node. Returning current node as struct_type\n");

  // If its a deref exp, then the return type will not be changed to struct_type
  // since its output should the same as before
  if(isSgPointerDerefExp(node)) {
    // FIXME: PointerDerefExp -> get_type() gives a struct type.
    // We need to pass up the original type (type of the ptr2obj in struct) -- since this will be useful for later
    // computations.
    TypeMap_t::iterator ti = ArithCheck::UnderlyingType.find(ArithCheck::created_struct_type);
    SgType* baseType = ti->second;
    nodeType currNode(baseType, node);
    return currNode;
  }
  else {
    nodeType currNode(ArithCheck::created_struct_type, node);
    return currNode;
  }

}
#endif




#if 0
void ArithCheck::process(SgNode*) {
}

void ArithCheck::instrument(SgNode*) {
}
#endif



SgStatement* getSurroundingStatement(SgExpression& n)
{
  return &sg::ancestor<SgStatement>(n);
}

SgStatement* getSurroundingStatement(SgNode& n)
{
  return &sg::ancestor<SgStatement>(n);
}


SgType* skip_PointerType(SgType* t)
{
  SgPointerType* sgptr = isSgPointerType(t);
  if (sgptr != NULL) return sgptr->get_base_type();

  return t;
}

SgType* skip_ReferencesAndTypedefs( SgType* type ) {
     if( isSgTypedefType( type )) {
        return skip_ReferencesAndTypedefs(
            isSgTypedefType( type ) -> get_base_type() );
    } else if( isSgReferenceType( type )) {
        // resolve reference to reference ... to pointer
        return skip_ReferencesAndTypedefs(
            isSgReferenceType( type ) -> get_base_type() );
    }

    return type;
}

SgType* resolveTypedefsAndReferencesToBaseTypes(SgType* type) {
    SgType* baseType = skip_ReferencesAndTypedefs(type);

    SgType* retType;

    if(baseType->class_name() == "SgModifierType") {
        SgModifierType* modType = isSgModifierType(baseType);
        retType = modType->get_base_type();
    }
    else {
        retType = baseType;
    }

    return retType;
}

SgType* skip_RefsPointersAndTypedefs(SgType* type) {
  SgType* retType = type;
  if(isSgPointerType(type)) {
    SgType* baseType = skip_PointerType(type);
    retType = skip_RefsPointersAndTypedefs(baseType);
  }
  else if(isSgTypedefType(type) || isSgReferenceType(type)) {
    SgType* baseType = skip_ReferencesAndTypedefs(type);
    retType = skip_RefsPointersAndTypedefs(baseType);
  }
  else if(isSgModifierType(type)) {
    SgType* baseType = resolveTypedefsAndReferencesToBaseTypes(type);
    retType = skip_RefsPointersAndTypedefs(baseType);
  }

  return retType;
}


void ArithCheck::registerCheck() {
  //printf("ArithCheck:registerCheck\n");
  CheckBase::RegisterBinaryOpCheck(this);
}

void ArithCheck::process(BopContainer& BopCtr) {
  printf("ArithCheck:process BopCtr\n");

    // Can't do a mass copy. Need to figure out which binary ops we need.
  //SelectedBops.insert(SelectedBops.end(), BopCtr.begin(), BopCtr.end());
  for(BopContainer::iterator bpit = BopCtr.begin(); bpit != BopCtr.end();
                                bpit++) {
    SgBinaryOp* Bop = *bpit;
    process(Bop);
    }
}

bool ArithCheck::isUseful(SgBinaryOp* Bop) {

  switch(Bop->variantT()) {
  case V_SgAddOp: return true;
  case V_SgSubtractOp: return true;
  case V_SgMultiplyOp: return true;
  case V_SgDivideOp: return true;
  default: return false;
  }

    assert(0);
}



void ArithCheck::process(SgBinaryOp* Bop) {
  printf("ArithCheck:process Bop\n");

    if(isUseful(Bop)) {
    printInfo(Bop, Bop->get_lhs_operand(), Bop->get_rhs_operand());
    SelectedBops.push_back(Bop);
    }

  #if 0
  switch(Bop->variantT()) {
  case V_SgAddOp: process(isSgAddOp(Bop))
  #endif
}

void ArithCheck::process(SgNode* Node) {
  printf("ArithCheck:process Node. Blank\n");

}


void ArithCheck::insertLibHeader() {

    SgProject* project = CheckBase::CBProject;

    SgFilePtrList file_list = project->get_fileList();
  SgFilePtrList::iterator iter;
  for(iter = file_list.begin(); iter!=file_list.end(); iter++) {
    SgSourceFile* cur_file = isSgSourceFile(*iter);
    SgGlobal* global_scope = cur_file->get_globalScope();
    // Removed Rajesh Sept 11 5PM
    //SageInterface::insertHeader("foo2_c.h", PreprocessingInfo::after,false,global_scope);
    //SageInterface::insertHeader("ptr_hdr.h", PreprocessingInfo::after,false,global_scope);
  }



}

SgStatement* ArithCheck::getSuitablePrevStmt(SgStatement* stmt) {

  SgNode* parent = isSgNode(stmt)->get_parent();
  printf("Parent: %s = %s\n", isSgNode(parent)->sage_class_name(), isSgNode(parent)->unparseToString().c_str());

  if(isSgForInitStatement(parent)) {
    printf("Found forloop case.\n");
    // This is a for loop initialization statement.
    // We can't put just the variable declaration here, without
    // any initialization. So, lets put it prior to the
    // this statement
    SgNode* forloopstmt = parent->get_parent();
    printf("ForInit: %s = %s\n", isSgNode(forloopstmt)->sage_class_name(), isSgNode(forloopstmt)->unparseToString().c_str());
    ROSE_ASSERT(isSgForStatement(isSgStatement(forloopstmt)));
    return isSgStatement(forloopstmt);
  }
  return stmt;

}

void ArithCheck::InstrumentBinaryOp(SgBinaryOp* bop, SgProject* project) {

  char* OpString = getStringForVariantT(bop->variantT());

  SgExpression* LHS = bop->get_lhs_operand();
  SgExpression* RHS = bop->get_rhs_operand();

    printInfo(bop, LHS, RHS);

    SgStatement* stmt = getSurroundingStatement(*isSgExpression(bop));
    SgScopeStatement* scope = stmt->get_scope();

    ROSE_ASSERT(scope);

    SgExpression* LHS_Copy = copyExpression(LHS);
    SgExpression* RHS_Copy = copyExpression(RHS);

  #if 0
    SgType* LHSTy = resolveTypedefsAndReferencesToBaseTypes(LHS->get_type());
    SgType* RHSTy = resolveTypedefsAndReferencesToBaseTypes(RHS->get_type());
    SgType* ParTy = resolveTypedefsAndReferencesToBaseTypes(bop->get_type());

    VariantT ParV = bop->variantT();
    VariantT ParV_Ty = ParTy->variantT();
    VariantT LHSV = LHSTy->variantT();
    VariantT RHSV = RHSTy->variantT();

    ROSE_ASSERT(LHSV != V_SgTypedefType);
    ROSE_ASSERT(RHSV != V_SgTypedefType);
  #endif

//  char* FnName = getString(ParV_Ty, ParV, LHSV, RHSV);

//  SgName s_name(FnName);
  SgName s_name(OpString);
    SgExprListExp* parameter_list = buildExprListExp();

    appendExpression(parameter_list, LHS_Copy);
    appendExpression(parameter_list, RHS_Copy);

  #if 0
    SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(s_name,
                                                                bop->get_type(),
                                                                parameter_list,
                                                                scope);
  #endif
  SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(s_name,
                                                                ArithCheck::created_struct_type,
                                                                parameter_list,
                                                                scope);

    replaceExpression(bop, NewFunction);



}


void ArithCheck::forwardDecl(SgName name, SgType* retType, SgName arg1name, SgType* arg1Type, SgName arg2name, SgType* arg2Type) {

  SgProject* project = CheckBase::CBProject;

  SgFunctionParameterList* ParamList = buildFunctionParameterList();
  ParamList->append_arg(buildInitializedName(arg1name, arg1Type));
  if(arg2Type != NULL) {
    ParamList->append_arg(buildInitializedName(arg2name, arg2Type));
  }

  SgGlobal* globalScope = getFirstGlobalScope(project);
  pushScopeStack(globalScope);

  SgFunctionDeclaration* forwardDecl = buildNondefiningFunctionDeclaration(name,
                                      retType,
                                      ParamList);

  prependStatement(isSgStatement(forwardDecl));
  popScopeStack();
}

void ArithCheck::InstrumentUnaryOp(SgUnaryOp* uop, SgProject* project) {


  // Forward declaration for Deref_Overload
  forwardDecl(SgName("Deref_Overload"), SgTypeUnsignedInt::createType(), SgName("ptr"),
        ArithCheck::created_struct_type, SgName(""), NULL);

  // Forward declaration for Cast_Overload
  forwardDecl(SgName("Cast_Overload"), ArithCheck::created_struct_type, SgName("ptr"),
        ArithCheck::created_struct_type, SgName(""), NULL);

  // Forward declaration for Add
  forwardDecl(SgName("Add"), ArithCheck::created_struct_type, SgName("ptr"),
        ArithCheck::created_struct_type, SgName("val"), SgTypeUnsignedInt::createType());

  // Forward declaration for Sub
  forwardDecl(SgName("Sub"), ArithCheck::created_struct_type, SgName("ptr"),
        ArithCheck::created_struct_type, SgName("val"), SgTypeUnsignedInt::createType());

  // Forward declaration for Mult
  forwardDecl(SgName("Mult"), ArithCheck::created_struct_type, SgName("ptr"),
        ArithCheck::created_struct_type, SgName("val"), SgTypeUnsignedInt::createType());

  // Forward declaration for Div
  forwardDecl(SgName("Div"), ArithCheck::created_struct_type, SgName("ptr"),
        ArithCheck::created_struct_type, SgName("val"), SgTypeUnsignedInt::createType());

  // Forward declaration for GreaterThan
  forwardDecl(SgName("GreaterThan"), SgTypeBool::createType(), SgName("ptr"),
        ArithCheck::created_struct_type, SgName("other_ptr"), ArithCheck::created_struct_type);

  // Forward declaration for LessThan
  forwardDecl(SgName("LessThan"), SgTypeBool::createType(), SgName("ptr"),
        ArithCheck::created_struct_type, SgName("other_ptr"), ArithCheck::created_struct_type);

  // Forward declaration for LessOrEqual
  forwardDecl(SgName("LessOrEqual"), SgTypeBool::createType(), SgName("ptr"),
        ArithCheck::created_struct_type, SgName("other_ptr"), ArithCheck::created_struct_type);

  // Forward declaration for GreaterOrEqual
  forwardDecl(SgName("GreaterOrEqual"), SgTypeBool::createType(), SgName("ptr"),
        ArithCheck::created_struct_type, SgName("other_ptr"), ArithCheck::created_struct_type);

  // Forward declaration for NotEqual
  forwardDecl(SgName("NotEqual"), SgTypeBool::createType(), SgName("ptr"),
        ArithCheck::created_struct_type, SgName("other_ptr"), ArithCheck::created_struct_type);

  // Forward declaration for Equality
  forwardDecl(SgName("Equality"), SgTypeBool::createType(), SgName("ptr"),
        ArithCheck::created_struct_type, SgName("other_ptr"), ArithCheck::created_struct_type);

#if 0
  // Forward declaration for Deref_Overload
  SgFunctionParameterList* DerefOverloadParamList = buildFunctionParameterList();
  DerefOverloadParamList->append_arg(buildInitializedName(SgName("ptr"),ArithCheck::created_struct_type));
  SgGlobal* globalScope = getFirstGlobalScope(project);
  pushScopeStack(globalScope);

  SgFunctionDeclaration* DerefOverloadForwardDecl = buildNondefiningFunctionDeclaration(SgName("Deref_Overload"),
                                          SgTypeUnsignedInt::createType(),
                                          DerefOverloadParamList);
  prependStatement(isSgStatement(DerefOverloadForwardDecl));
  popScopeStack();


  // Forward declaration for Cast_Overload
  SgFunctionParameterList* CastOverloadParamList = buildFunctionParameterList();
  CastOverloadParamList->append_arg(buildInitializedName(SgName("ptr"),ArithCheck::created_struct_type));
  pushScopeStack(globalScope);

  SgFunctionDeclaration* CastOverloadForwardDecl = buildNondefiningFunctionDeclaration(SgName("Cast_Overload"),
                                          ArithCheck::created_struct_type,
                                          CastOverloadParamList);
  prependStatement(isSgStatement(CastOverloadForwardDecl));
  popScopeStack();
#endif

  // The rest of the work -- actually instrumenting the ops
  SgExpression* Operand = uop->get_operand();

  SgStatement* stmt = getSurroundingStatement(*isSgExpression(uop));
    SgScopeStatement* scope = stmt->get_scope();

    ROSE_ASSERT(scope);

  // Deref expression is handled separately
  if(isSgPointerDerefExp(uop)) {
    // Maintain return type. Simply overload operation with a function


    SgName s_name("Deref_Overload");
      SgExprListExp* parameter_list = buildExprListExp();

    SgExpression* Operand_Copy = copyExpression(Operand);

      appendExpression(parameter_list, Operand_Copy);

    SgType* retType = (ArithCheck::UnderlyingType.find(ArithCheck::created_struct_type))->second;

      SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(s_name,
                                                                  retType,
                                                                  parameter_list,
                                                                  scope);

      replaceExpression(uop, NewFunction);
  }
  else if(isSgCastExp(uop)) {

    // Need to overload the cast expression, and turn it into a function call

    SgName s_name("Cast_Overload");
      SgExprListExp* parameter_list = buildExprListExp();

    SgExpression* Operand_Copy = copyExpression(Operand);

      appendExpression(parameter_list, Operand_Copy);

    // FIXED BELOW
    // This return type needs to be the struct_type corresponding to the *casted* type
    // i.e. if we are casting from void pointer to integer pointer using the struct
    // then, by the time we reach this point, the void pointer has been converted to
    // a void type struct already. This function should basically create a struct of
    // integer type, and return that struct variable by value
    // One way to do this, is to maintain a reverse map of the UnderlyingType, and
    // simple find the correct struct type to return

    //SgType* retType = isSgCastExp(uop)->get_type();
    SgType* retType = (ArithCheck::RelevantStructType.find(isSgCastExp(uop)->get_type()))->second;

      SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(s_name,
                                                                  retType,
                                                                  parameter_list,
                                                                  scope);

      replaceExpression(uop, NewFunction);


  }
  else
  {
    // FIXME:We could convert the rest of the unary to binary ops -- just like
    // arithmetic checks

    // Convert ptr++ to ptr = ptr + 1
    SgExpression* LHS = copyExpression(uop->get_operand());
    SgExpression* RHS = isSgExpression(buildUnsignedIntVal(1));
    SgExpression* LVal = copyExpression(LHS);

    SgBinaryOp* BinaryOp;
    SgBinaryOp* AssgOp;

    switch(uop->variantT()) {
      case V_SgPlusPlusOp:
        BinaryOp = buildAddOp(LHS, RHS);
        AssgOp = buildAssignOp(LVal, BinaryOp);
        replaceExpression(isSgExpression(uop), isSgExpression(AssgOp));
        InstrumentBinaryOp(BinaryOp, project);
        break;
      case V_SgMinusMinusOp:
        BinaryOp = buildSubtractOp(LHS, RHS);
        AssgOp = buildAssignOp(LVal, BinaryOp);
        replaceExpression(isSgExpression(uop), isSgExpression(AssgOp));
        InstrumentBinaryOp(BinaryOp, project);
        break;
      default:
        printf("Unary Op not known\n");
        printf("UnaryOp: %s = %s\n", isSgNode(uop)->sage_class_name(),
                      isSgNode(uop)->unparseToString().c_str());
    }

  }

}

void ArithCheck::InstrumentNodes(SgProject* project) {

  printf("InstrumentNodes - begin\n");

  for(NodeContainer::iterator nit = ArithCheck::NodesToInstrument.begin(); nit != ArithCheck::NodesToInstrument.end(); ++nit) {

    SgNode* node = *nit;

    ROSE_ASSERT(isSgBinaryOp(node) || isSgUnaryOp(node));

    printf("Node: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());

    if(isSgBinaryOp(node)) {
      SgBinaryOp* bop = isSgBinaryOp(node);

      ROSE_ASSERT(bop->get_rhs_operand()->get_type()->get_mangled() == ArithCheck::created_struct_type->get_mangled() ||
            bop->get_lhs_operand()->get_type()->get_mangled() == ArithCheck::created_struct_type->get_mangled());

      InstrumentBinaryOp(bop, project);
    }
    else {
      SgUnaryOp* uop = isSgUnaryOp(node);
      // Pointer deref expressions will return the same type as before. They won't return
      // a struct. They are a special case, which we need to overload, but not change the return
      // type for
      ROSE_ASSERT(uop->get_operand()->get_type()->get_mangled() == ArithCheck::created_struct_type->get_mangled() ||
            isSgPointerDerefExp(uop));
      InstrumentUnaryOp(uop, project);
    }
  }

  printf("InstrumentNodes - end\n");
}

SgType* ArithCheck::getStructType(SgType* type, bool create) {

  // Expect a pointer type since RelevantStructType has pointer types
  // within it, and createStruct expects pointer type
  ROSE_ASSERT(isSgPointerType(type));

  TypeMap_t::iterator tm = ArithCheck::RelevantStructType.find(type);

  bool found = (tm != ArithCheck::RelevantStructType.end());

  if(!found) {
    if(!create) {
      printf("Struct type for given type not found.\n");
      ROSE_ASSERT(0);
    }
    else {
      ROSE_ASSERT(!found && create);

      SgType* str_type = createStruct(type);

      // Checking if createStruct did its job
      tm = ArithCheck::RelevantStructType.find(type);
      ROSE_ASSERT(tm != ArithCheck::RelevantStructType.end());

    }
  }

  // Found struct type. return it.
  return tm->second;
}

SgType* ArithCheck::getStructTypeIfPossible(SgType* type) {
  TypeMap_t::iterator tm = ArithCheck::RelevantStructType.find(type);

  return tm->second;
}

bool ArithCheck::isValidStructType(SgType* type) {

  TypeMap_t::iterator tm = ArithCheck::UnderlyingType.find(type);

  return (tm != ArithCheck::UnderlyingType.end());
}


void ArithCheck::handleVarDecls(SgInitializedName* name) {

  printf("handleVarDecls\n");

//  #ifdef OLD_WORKING_VAR_DECL
  #if 1
  ROSE_ASSERT(name);
  // Now, lets collect a few things about the current variable
  // 1. Initializer -- if it exists
  // 2. Symbol -- to refer to the symbol table
  if(!isSgVariableDeclaration(name->get_declaration())) {
    printf("Not Var Decl: %s = %s\n", isSgNode(name->get_declaration())->sage_class_name(), isSgNode(name->get_declaration())->unparseToString().c_str());
    return;
  }
  SgInitializer* init = name->get_initializer();
  printf("var: %s\n", name->get_qualified_name().str());
  SgSymbol* symbol = name->get_symbol_from_symbol_table();
  SgVariableSymbol *varsymbol = isSgVariableSymbol(symbol);

  // Lets start creating the new variable, which will be a struct variable
  std::string newname_string = name->get_qualified_name().getString() + "_structed" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++);
  SgName newName(newname_string);
  printf("created new name: %s\n", newname_string.c_str());
  // Before we replace anything, lets check what the initializer is. If it is NULL, we'll replace the *current* variable declaration itself!
  // If the initializer is not NULL, we create a statement for it, and then replace the *current* variable declaration
  //SgStatement* prevStmt = getSuitablePrevStmt(varDecl);

  SgVariableDeclaration* newvar;


  printf("name->get_type(): %s", name->get_type()->class_name().c_str());

  SgType* struct_type = getStructType(name->get_type());
  #if 0
  TypeMap_t::iterator tm = ArithCheck::RelevantStructType.find(name->get_type());
  printf("Done 1\n");

  ROSE_ASSERT(tm != ArithCheck::RelevantStructType.end());

  SgType* struct_type = tm->second;
  #endif

  printf("Done 2\n");
  if(init != NULL) {
    // There is a valid initializer. Make a new var decl using it
    SgExpression* cur_init_value = isSgAssignInitializer(init)->get_operand();
    SgExpression* new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
    printf("copied initialization\n");
    SgAssignInitializer* new_init = buildAssignInitializer(new_init_value, new_init_value->get_type());
    //newvar->reset_initializer(new_init);
    newvar = buildVariableDeclaration(newName, struct_type, new_init, name->get_declaration()->get_scope());
  }
  else {
    newvar = buildVariableDeclaration(newName, struct_type, NULL, name->get_declaration()->get_scope());
  }
  printf("Done 3\n");
  // printf("created new decl\n");
  // In some cases, inserting the new variable just before the previous one doesn't do.
  // so... we have multiple cases
  //printf("varDecl: %s = %s\n", isSgNode(name->get_declaration())->sage_class_name(), isSgNode(name->get_declaration())->unparseToString().c_str());
  SgInitializedNamePtrList& newvarList = newvar->get_variables();
  assert(newvarList.size() == 1);
  SgInitializedName* newname = *(newvarList.begin());
  printf("Done 4\n");
  SgSymbol* newsymbol = newname->get_symbol_from_symbol_table();
  replaceStatement(name->get_declaration(), isSgStatement(newvar));
  varRemap.insert(VariableSymbolMap_t::value_type(varsymbol, isSgVariableSymbol(newsymbol)));
  printf("All done\n");
  #else


  SgNode* parent = isSgNode(name)->get_parent();

  SgVariableDeclaration* vardecl = isSgVariableDeclaration(isSgNode(name)->get_parent());


  SgInitializer* init = name->get_initializer();
  printf("var: %s\n", name->get_name().str());

    // Lets start creating the new variable, which will be a struct variable

  std::string newname_string;

  if(strcmp(name->get_name().getString().c_str(), "") == 0) {
    newname_string = "";
  }
  else {
    newname_string = name->get_name().getString() + "_structed" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++);
  }

  SgName newName(newname_string);
  printf("created new name: %s\n", newname_string.c_str());
  // Before we replace anything, lets check what the initializer is. If it is NULL, we'll replace the *current* variable declaration itself!
  // If the initializer is not NULL, we create a statement for it, and then replace the *current* variable declaration
  SgInitializedName *new_name = NULL;
  SgExpression* new_init_value = NULL;
  SgAssignInitializer* new_init = NULL;

  SgType* struct_type = getStructType(name->get_type());
  if(init != NULL) {
    // There is a valid initializer. Make a new var decl using it
    SgExpression* cur_init_value = isSgAssignInitializer(init)->get_operand();
    //SgExpression* new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
    new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
    printf("copied initialization\n");
    //SgAssignInitializer* new_init = buildAssignInitializer(new_init_value, new_init_value->get_type());
    new_init = buildAssignInitializer(new_init_value, new_init_value->get_type());
    //newvar->reset_initializer(new_init);
    //newvar = buildVariableDeclaration(newName, struct_type, new_init, name->get_declaration()->get_scope());
    new_name = buildInitializedName(newName, struct_type, new_init);
  }
  else {
    new_name = buildInitializedName(newName, struct_type, NULL);
    //newvar = buildVariableDeclaration(newName, struct_type, NULL, name->get_declaration()->get_scope());
  }
  ROSE_ASSERT(new_name != NULL);

  SgScopeStatement* scopestmt = vardecl->get_scope();
  new_name->set_scope(scopestmt);

  ROSE_ASSERT(isSgVariableDefinition(new_name->get_declptr()));

  SgVariableDefinition* var_def = isSgVariableDefinition(new_name->get_declptr());


  ROSE_ASSERT(var_def != NULL);
  var_def->set_parent(new_name);
  var_def->set_vardefn(new_name);
  new_name->set_declptr(var_def);

  #if 0
  new_name->set_definition(vardecl->get_definition(name));
//  new_name->set_definition(name->get_definition());

  new_name->set_declptr(name->get_declptr());
  #endif

  printf("Function Parameter List\n");
  SgInitializedNamePtrList& vars = vardecl->get_variables();

  unsigned int index;
  unsigned int orig_size = vars.size();
  for(index = 0; index < vars.size(); index++) {
    SgInitializedName* curr_name = vars[index];
    if(curr_name == name) {
      break;
    }
  }
  ROSE_ASSERT(index != vars.size());

  // We remove the contents at index, and place the new_name there.

  SgInitializedNamePtrList::iterator iter;
  iter = vars.begin() + index;

  vars.insert(iter, new_name);
  isSgNode(new_name)->set_parent(vardecl);

  ROSE_ASSERT(vars[index] == new_name);

  ROSE_ASSERT(vars[index+1] == name);

  iter = vars.begin() + index + 1;
  vars.erase(iter);

  ROSE_ASSERT(vars.size() == orig_size);

  SgSymbol* symbol = name->get_symbol_from_symbol_table();
  SgVariableSymbol *varsymbol = isSgVariableSymbol(symbol);


  printf("Got scope. Now, symbolTable\n");
  SgSymbolTable* symbolTable = scopestmt->get_symbol_table();

  SgVariableSymbol* newsymbol = new SgVariableSymbol(new_name);
  isSgNode(newsymbol)->set_parent(isSgNode(varsymbol)->get_parent());
  SgSymbolTable* currSymbolTable = isSgSymbolTable(isSgNode(varsymbol)->get_parent());
  currSymbolTable->insert(new_name->get_name(), newsymbol);
  varRemap.insert(VariableSymbolMap_t::value_type(varsymbol, isSgVariableSymbol(newsymbol)));

  deepDelete(isSgNode(name));
  #endif
}

void ArithCheck::handleFuncParamLists(SgInitializedName* name, SgProject* project)
{

  printf("handleFuncParamLists\n");

  SgNode* parent = isSgNode(name)->get_parent();

  SgFunctionParameterList* oldParamList = isSgFunctionParameterList(isSgNode(name)->get_parent());
  SgFunctionDeclaration* fndecl = isSgFunctionDeclaration(isSgNode(oldParamList)->get_parent());

  // Function def is NULL for forward declaration of functions
  // No symbol table change is necessary when there is no definition
  #if 0
  SgFunctionDefinition* def = fndecl->get_definition();
  if(def == NULL) {
    printf("Looks like an external function call. vardecl->def = NULL\n");
    return;
  }
  #endif

  // Adding global scope to ScopeStack -- this will be the
  // default scope for now
  SgGlobal* globalScope = getFirstGlobalScope(project);
  pushScopeStack(isSgScopeStatement(globalScope));

    //
  SgInitializer* init = name->get_initializer();
  printf("var: %s\n", name->get_name().str());

    // Lets start creating the new variable, which will be a struct variable

  std::string newname_string;

  if(strcmp(name->get_name().getString().c_str(), "") == 0) {
    newname_string = "";
  }
  else {
    newname_string = name->get_name().getString() + "_structed" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++);
  }

  SgName newName(newname_string);
  printf("created new name: %s\n", newname_string.c_str());
  // Before we replace anything, lets check what the initializer is. If it is NULL, we'll replace the *current* variable declaration itself!
  // If the initializer is not NULL, we create a statement for it, and then replace the *current* variable declaration
  SgInitializedName *new_name = NULL;
  SgExpression* new_init_value = NULL;
  SgAssignInitializer* new_init = NULL;

  SgType* struct_type = getStructType(name->get_type());
  if(init != NULL) {
    // There is a valid initializer. Make a new var decl using it
    SgExpression* cur_init_value = isSgAssignInitializer(init)->get_operand();
    //SgExpression* new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
    new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
    printf("copied initialization\n");
    //SgAssignInitializer* new_init = buildAssignInitializer(new_init_value, new_init_value->get_type());
    new_init = buildAssignInitializer(new_init_value, new_init_value->get_type());
    //newvar->reset_initializer(new_init);
    //newvar = buildVariableDeclaration(newName, struct_type, new_init, name->get_declaration()->get_scope());
    new_name = buildInitializedName(newName, struct_type, new_init);
  }
  else {
    new_name = buildInitializedName(newName, struct_type, NULL);
    //newvar = buildVariableDeclaration(newName, struct_type, NULL, name->get_declaration()->get_scope());
  }
  ROSE_ASSERT(new_name != NULL);

  SgScopeStatement* scopestmt = fndecl->get_scope();
  new_name->set_scope(scopestmt);

  printf("Function Parameter List\n");
  SgInitializedNamePtrList& args = oldParamList->get_args();

  #if 0
  ROSE_ASSERT(def != NULL);
  SgScopeStatement* scopestmt = isSgScopeStatement(def);
  #endif

  #if OLD_WORKING_PARAM_LIST
  oldParamList->append_arg(new_name);
  isSgNode(new_name)->set_parent(oldParamList);
  #else
  #if 0
  for(SgInitializedNamePtrList::iterator iter = args.begin(); iter != args.end();
                          iter++) {

    SgInitializedName* curr_param = *iter;
    if(curr_param == name) {
  #endif

  unsigned int index;
  unsigned int orig_size = args.size();
  for(index = 0; index < args.size(); index++) {
    SgInitializedName* curr_name = args[index];
    if(curr_name == name) {
      break;
    }
  }
  ROSE_ASSERT(index != args.size());

  // We remove the contents at index, and place the new_name there.

//  SgInitializedNamePtrList::iterator iter = &args[index];
  SgInitializedNamePtrList::iterator iter;
  iter = args.begin() + index;
//  iter = &args[index];

//  args.insert(index, new_name);
  args.insert(iter, new_name);
  isSgNode(new_name)->set_parent(oldParamList);

  ROSE_ASSERT(args[index] == new_name);

  ROSE_ASSERT(args[index+1] == name);

//  iter = &args[index+1];
  iter = args.begin() + index + 1;
//  args.erase(index+1);
  args.erase(iter);

  ROSE_ASSERT(args.size() == orig_size);



  #endif

  // Check if this has a def. If it doesn't, no symbol table work.
  // If it has a def, modify symbol table
  SgFunctionDefinition* def = fndecl->get_definition();
  if(def == NULL) {
    printf("Nondefining Function Decl. No symbol table work\n");
    #ifndef OLD_WORKING_PARAM_LIST
    deepDelete(isSgNode(name));
    #endif
    return;
  }

  SgSymbol* symbol = name->get_symbol_from_symbol_table();
  SgVariableSymbol *varsymbol = isSgVariableSymbol(symbol);


  printf("Got scope. Now, symbolTable\n");
  SgSymbolTable* symbolTable = scopestmt->get_symbol_table();

  SgVariableSymbol* newsymbol = new SgVariableSymbol(new_name);
  isSgNode(newsymbol)->set_parent(isSgNode(varsymbol)->get_parent());
  SgSymbolTable* currSymbolTable = isSgSymbolTable(isSgNode(varsymbol)->get_parent());
  currSymbolTable->insert(new_name->get_name(), newsymbol);
  varRemap.insert(VariableSymbolMap_t::value_type(varsymbol, isSgVariableSymbol(newsymbol)));

  #ifndef OLD_WORKING_PARAM_LIST
  deepDelete(isSgNode(name));
  #endif


// FIXME: Figure out a way to remove the old parameter from the list

#if 0
    SgFunctionParameterList* newParamList = buildFunctionParameterList();
    SgInitializedNamePtrList::iterator it;
    bool found = false;

    SgVariableSymbol* newsymbol;
    for(it = args.begin(); it != args.end(); it++) {
      SgInitializedName* paramname = *it;
      SgInitializedName* new_paramname = NULL;
      if(paramname == name) {
        new_paramname = new_name;

        newsymbol = new SgVariableSymbol(new_name);
        isSgNode(newsymbol)->set_parent(isSgNode(varsymbol)->get_parent());
        SgSymbolTable* currSymbolTable = isSgSymbolTable(isSgNode(varsymbol)->get_parent());
        currSymbolTable->insert(new_name->get_name(), newsymbol);

        found = true;
      }
      else {
        new_paramname = isSgInitializedName(deepCopy(isSgNode(paramname)));
      }
      ROSE_ASSERT(new_paramname != NULL);

      newParamList->append_arg(new_paramname);
    }

    replaceStatement(oldParamList, newParamList);

    varRemap.insert(VariableSymbolMap_t::value_type(varsymbol, isSgVariableSymbol(newsymbol)));
#endif

    #if 0
    // FIXME: This isn't working --- the return type doesn't seem to be changing
    // If return_type is an unsigned int pointer, need to change that to struct_type as well
    SgType* retType = fndecl->get_type()->get_return_type();
    SgType* baseType = skip_RefsPointersAndTypedefs(retType);

    if(retType->variantT() == V_SgPointerType) {
      SgType*

    if(retType->variantT() == V_SgPointerType && baseType->variantT() == V_SgTypeUnsignedInt) {
      printf("Setting return type to struct_type\n");
      fndecl->get_type()->set_return_type(struct_type);
      // FIXME: Not sure why I am inserting this here..
      fndecl->get_type()->set_orig_return_type(struct_type);
    }
    #endif

  popScopeStack();

    // Add the symbol to the varRefList
}

void ArithCheck::handleVarRefExp(SgVarRefExp* old_ref) {

  printf("handleVarRefExp\n");

  SgVariableSymbol* old_symbol = old_ref->get_symbol();
  //SgSymbol* old_symbol = old_ref->get_symbol();
  ROSE_ASSERT(old_symbol != NULL);
  VariableSymbolMap_t::iterator iter = ArithCheck::varRemap.find(old_ref->get_symbol());
  ROSE_ASSERT(iter != ArithCheck::varRemap.end());
  SgVariableSymbol* newsymbol = iter->second;

  ROSE_ASSERT(newsymbol != NULL);
  SgVarRefExp* structref = buildVarRefExp(isSgVariableSymbol(newsymbol));
  ROSE_ASSERT(structref != NULL);
  replaceExpression(old_ref, structref);
  printf("Done\n");
}

#if 0
char* ArithCheck::getStringFor(enum OVL_TYPE op) {

  char* opstring = (char*)malloc(50*sizeof(char));

  switch(op) {
  case DEREF: sprintf(opstring, "Deref"); break;
  case CAST:  sprintf(opstring, "Cast"); break;
  case STRUCT: sprintf(opstring, "Struct"); break;
  case NORMAL: sprintf(opstring, "Normal"); break;
  default: ROSE_ASSERT(0);
  }
}
#endif

char* ArithCheck::getStringFor(SgBinaryOp* bop, enum OVL_TYPE op) {

  char* BString = getStringForVariantT(bop->variantT());
  char* OpString = getStringFor(op);

  char* output = (char*)malloc(50*sizeof(char));
  sprintf(output, "%s_%s", OpString, BString);

  return output;

}

void ArithCheck::handleBinaryOp(SgBinaryOp* bop, SgProject* project) {
  printf("handleBinaryOp\n");

  if(isSgAssignOp(bop)) {
    printf("Discarding assign ops\n");
    return;
  }

  char* OpString = getStringForVariantT(bop->variantT());

  SgExpression* LHS = bop->get_lhs_operand();
  SgExpression* RHS = bop->get_rhs_operand();


  // Some cases to handle here... if both operands are
  // of struct type, then we create a Struct<OP>
  // which adds both together
  // If one is struct_type and other isn't, then
  // we use a normal <OP> operation

  unsigned int optype = isValidStructType(LHS->get_type()) + isValidStructType(RHS->get_type());

  char* opOutput;

  switch(optype) {
  case 0: ROSE_ASSERT(0);
  case 1: opOutput = getStringFor(bop, NORMAL); break;
  case 2: opOutput = getStringFor(bop, STRUCT); break;
  default: ROSE_ASSERT(0);
  }


  SgType* LHSType;
  if(isValidStructType(LHS->get_type())) {
    LHSType = (ArithCheck::UnderlyingType.find(LHS->get_type()))->second;
  }
  else {
    LHSType = LHS->get_type();
  }

  LHSType = skip_RefsPointersAndTypedefs(LHSType);

  SgType* RHSType;
  if(isValidStructType(RHS->get_type())) {
    RHSType = (ArithCheck::UnderlyingType.find(RHS->get_type()))->second;
  }
  else {
    RHSType = RHS->get_type();
  }

  RHSType = skip_RefsPointersAndTypedefs(RHSType);

  char* fn_name = (char*)malloc(50*sizeof(char));

  sprintf(fn_name, "%s_%s_%s", getStringForVariantT(LHSType->variantT()),
                 getStringForVariantT(RHSType->variantT()),
                 opOutput);

  SgName s_name(fn_name);



  #if 0

  if(isValidStruct(LHS->get_type()) && isValidStructType(RHS->getType())) {
    getStringFor(bop, STRUCT);
  }
  else if(is

  if(isValidStructType(LHS->get_type())) {
    inputType = (ArithCheck::UnderlyingType.find(LHS->get_type()))->second;
  }
  else {
    inputType =
  #endif

    printInfo(bop, LHS, RHS);

    SgStatement* stmt = getSurroundingStatement(*isSgExpression(bop));
    SgScopeStatement* scope = stmt->get_scope();

    ROSE_ASSERT(scope);

    SgExpression* LHS_Copy = copyExpression(LHS);
    SgExpression* RHS_Copy = copyExpression(RHS);

  #if 0
    SgType* LHSTy = resolveTypedefsAndReferencesToBaseTypes(LHS->get_type());
    SgType* RHSTy = resolveTypedefsAndReferencesToBaseTypes(RHS->get_type());
    SgType* ParTy = resolveTypedefsAndReferencesToBaseTypes(bop->get_type());

    VariantT ParV = bop->variantT();
    VariantT ParV_Ty = ParTy->variantT();
    VariantT LHSV = LHSTy->variantT();
    VariantT RHSV = RHSTy->variantT();

    ROSE_ASSERT(LHSV != V_SgTypedefType);
    ROSE_ASSERT(RHSV != V_SgTypedefType);
  #endif

//  char* FnName = getString(ParV_Ty, ParV, LHSV, RHSV);

//  SgName s_name(FnName);
//  SgName s_name(OpString);
    SgExprListExp* parameter_list = buildExprListExp();

    appendExpression(parameter_list, LHS_Copy);
    appendExpression(parameter_list, RHS_Copy);

  #if 0
    SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(s_name,
                                                                bop->get_type(),
                                                                parameter_list,
                                                                scope);
  #endif

  printf("bop: %s\n", bop->get_type()->class_name().c_str());

  SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(s_name,
                                                                bop->get_type(),
                                                                parameter_list,
                                                                scope);

  createForwardDeclIfNotAvailable(s_name, bop->get_type(), parameter_list, scope, project);

    replaceExpression(bop, NewFunction);

  printf("BinaryOp - Done\n");
}



SgName ArithCheck::getOverloadingFunction(SgType* inputType, enum OVL_TYPE op ) {

//  std::string newname_string = getStringFor(retType) + getStringFor(inputType) + getStringFor(uop);

//  char* RetString = getStringForVariantT(retType->variantT());
  char* InpString = getStringForVariantT(inputType->variantT());
//  char* UopString = getStringForVariantT(uop->variantT());
  char* UopString = getStringFor(op);

  char* FunctionBuf = (char*)malloc(50*sizeof(char));
//  sprintf(FunctionBuf, "%s_%s_%s", RetString, InpString, UopString);
  sprintf(FunctionBuf, "%s_%s", InpString, UopString);
  SgName s_name(FunctionBuf);
  return s_name;

}

SgName ArithCheck::getOverloadingFunction(SgType* retType, SgType* inputType, enum OVL_TYPE op ) {

//  std::string newname_string = getStringFor(retType) + getStringFor(inputType) + getStringFor(uop);

  char* RetString = getStringForVariantT(retType->variantT());
  char* InpString = getStringForVariantT(inputType->variantT());
//  char* UopString = getStringForVariantT(uop->variantT());
  char* UopString = getStringFor(op);

  char* FunctionBuf = (char*)malloc(50*sizeof(char));
  sprintf(FunctionBuf, "%s_%s_%s", RetString, InpString, UopString);
//  sprintf(FunctionBuf, "%s_%s", InpString, UopString);
  SgName s_name(FunctionBuf);
  return s_name;

}

bool ArithCheck::compareNames(SgName first, SgName second) {

  return (first == second);

}

bool ArithCheck::compareTypes(SgType* first, SgType* second) {

  return (first->get_mangled() == second->get_mangled());

}


void ArithCheck::printNode(SgNode* node) {
  printf("node: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());
}

void ArithCheck::printNodeExt(SgNode* node) {
  Sg_File_Info* File = isSgNode(node)->get_file_info();
  printNode(node);
  printf("File: (%s, %d, %d) %s = %s\n", File->get_filenameString().c_str(),
                    File->get_line(),
                    File->get_col(),
                    isSgNode(node)->sage_class_name(),
                    isSgNode(node)->unparseToString().c_str());

}

void ArithCheck::createFuncInfo(SgName s_name, SgType* retType, SgExprListExp* parameter_list) {

  class FuncInfo* fi = new class FuncInfo;
  fi->fn_name = s_name;
  fi->retType = isSgType(deepCopyNode(isSgNode(retType)));
  printf("retType\n");
  printNode(isSgNode(retType));
  printf("fi->retType\n");
  printNode(isSgNode(fi->retType));
  fi->ParamTypes = new SgTypeList;

  SgExpressionPtrList& expr_list = parameter_list->get_expressions();

  SgExpressionPtrList::iterator iter = expr_list.begin();

  for(iter = expr_list.begin(); iter != expr_list.end(); iter++) {

    SgType* expr_type = (*iter)->get_type();
    SgType* expr_type_copy = isSgType(deepCopyNode(isSgNode(expr_type)));
    fi->ParamTypes->push_back(expr_type_copy);
    printf("expr_type\n");
    printNode(isSgNode(expr_type));
    printf("expr_type_copy\n");
    printNode(isSgNode(expr_type_copy));
  }

  // A few checks
  ROSE_ASSERT(fi->fn_name == s_name);
  // Using get_mangled to compare types
  ROSE_ASSERT(fi->retType->get_mangled() == retType->get_mangled());
  ROSE_ASSERT(fi->ParamTypes->size() == expr_list.size());

  // Add this to the ForwardDecls list
  ForwardDecls.push_back(fi);

}



bool ArithCheck::checkIfDeclExists(SgName s_name, SgType* retType, SgExprListExp* parameter_list) {
  printf("checkIfDeclExists\n");

  FuncInfoList::iterator iter;

  for(iter = ForwardDecls.begin(); iter != ForwardDecls.end(); iter++) {

    class FuncInfo* fi = *iter;

    bool name_check = compareNames(s_name, fi->fn_name);

    // This name doesn't match... try the next one in ForwardDecls
    if(!name_check) {
      printf("name doesn't match\n");
      continue;
    }

    bool ret_type_check = compareTypes(retType, fi->retType);

    // The ret type doesn't match... try the next one in ForwardDecls
    if(!ret_type_check) {
      continue;
    }

    // Check params

    SgTypeList* paramTypes = fi->ParamTypes;

    SgExpressionPtrList& expr_list = parameter_list->get_expressions();

    // Size mismatch -- can't be the same function -- try next one
    if(paramTypes->size() != expr_list.size()) {
      continue;
    }

    SgTypeList::iterator iter2;
    SgExpressionPtrList::iterator iter3 = expr_list.begin();

    bool param_match = true;

    for(iter2 = paramTypes->begin(); iter2 != paramTypes->end(); iter2++, iter3++) {

      SgType* stored_type = *iter2;
      SgType* expr_type = (*iter3)->get_type();

      // Type mismatch
      if(!compareTypes(stored_type, expr_type)) {
        param_match = false;
        break;
      }
    }

    if(param_match) {
      // name, ret_type and params matched. must be correct
      return true;
    }
  }

  printf("Can't find the decl. Creating one\n");
  // None of the decls matched. lets create a new one here.
  createFuncInfo(s_name, retType, parameter_list);

  // Recursive call to check if the createFuncInfo worked
  ROSE_ASSERT(checkIfDeclExists(s_name, retType, parameter_list));

  return false;


  #if 0

  for(unsigned int index = 0; index < ArithCheck::ForwardDecls.size(); index++) {
    // Also check here for the return type --- we might be using the same
    // function with different return types and parameters -- do a full
    // check... before going either way
    bool name_check = compareNames(s_name, ArithCheck::ForwardDecls[index]);

    // If they have different names, then new decl required
    if(!name_check) {
      return false;
    }

    bool ret_type_check = compareRetTypes(


    bool param_check =


    if(s_name == ArithCheck::ForwardDecls[index]) {
      return true;
    }
  }

  // Add to list
  ArithCheck::ForwardDecls.push_back(s_name);
  return false;
  #endif
}


void ArithCheck::createForwardDeclIfNotAvailable(SgName s_name, SgType* retType,
                        SgExprListExp* parameter_list,
                        SgScopeStatement* scope, SgProject* project) {
  printf("createForwardDecl\n");
  if(checkIfDeclExists(s_name, retType, parameter_list)) {
    return;
  }

  printf("Creating new forward decl\n");

  SgGlobal* globalScope = getFirstGlobalScope(project);
  pushScopeStack(globalScope);

  SgFunctionParameterList* new_param_list = buildFunctionParameterList();

  SgExpressionPtrList& exprs = parameter_list->get_expressions();

  printf("creating param_list\n");

  for(SgExpressionPtrList::iterator iter = exprs.begin(); iter != exprs.end();
                              iter++) {

    SgExpression* ce = *iter;
    printf("ce: %s = %s\n", isSgNode(ce)->sage_class_name(), isSgNode(ce)->unparseToString().c_str());
    SgInitializedName* new_name = buildInitializedName(SgName(""),ce->get_type(), NULL);
    printf("created new_name\n");
    new_name->set_scope(globalScope);
    new_param_list->append_arg(new_name);
    new_name->set_parent(new_param_list);
  }

  printf("creating fwddecl\n");
  SgFunctionDeclaration* fwddecl = buildNondefiningFunctionDeclaration(s_name,
                                    retType,
                                    new_param_list);



  prependStatement(isSgStatement(fwddecl));
  popScopeStack();
  printf("createForwardDecl - Done\n");
}

void ArithCheck::handleUnaryOp(SgUnaryOp* uop, SgProject* project) {

  printf("handleUnaryOp\n");

  SgExpression* Operand = uop->get_operand();

  SgStatement* stmt = getSurroundingStatement(*isSgExpression(uop));
    SgScopeStatement* scope = stmt->get_scope();

    ROSE_ASSERT(scope);

  // Deref expression is handled separately
  if(isSgPointerDerefExp(uop)) {


    // For a deref expression, we have to change the operand
    // below so that its now a function call, and we deref
    // the return value from the function call

    printf("DerefExp\n");





    SgExprListExp* parameter_list = buildExprListExp();

    SgExpression* Operand_Copy = copyExpression(Operand);

      appendExpression(parameter_list, Operand_Copy);

    printf("Operand: %s\n", Operand->get_type()->class_name().c_str());

    SgType* retType = (ArithCheck::UnderlyingType.find(Operand->get_type()))->second;
    printf("retType: %s\n", retType->class_name().c_str());
    ROSE_ASSERT(retType);
    SgType* baseType = skip_RefsPointersAndTypedefs(retType);
    printf("baseType: %s\n", baseType->class_name().c_str());




    //SgName s_name("Deref_Overload");
    SgName s_name = getOverloadingFunction(baseType, DEREF);


    SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(s_name,
                                                                  retType,
                                                                  parameter_list,
                                                                  scope);


    createForwardDeclIfNotAvailable(s_name, retType, parameter_list, scope, project);

    replaceExpression(Operand, NewFunction);

    #if 0

    // Maintain return type. Simply overload operation with a function

    SgName s_name("Deref_Overload");
      SgExprListExp* parameter_list = buildExprListExp();

    SgExpression* Operand_Copy = copyExpression(Operand);

      appendExpression(parameter_list, Operand_Copy);

    SgType* retType = (ArithCheck::UnderlyingType.find(ArithCheck::created_struct_type))->second;

      SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(s_name,
                                                                  retType,
                                                                  parameter_list,
                                                                  scope);

      replaceExpression(uop, NewFunction);
    #endif
  }
  else if(isSgCastExp(uop)) {

    printf("Cast Expression\n");

    if(isSgClassType(skip_RefsPointersAndTypedefs(uop->get_type()))) {
      printf("Return type for Cast Exp is class type. \n");
      printf("Either struct pointer or something weird (fflush(NULL))\n");
      printf("Skipping op\n");
      return;
    }


    // Need to overload the cast expression, and turn it into a function call

//    SgName s_name("Cast_Overload");

    // Input Type
    SgType* baseType;
    enum OVL_TYPE op;
    if(!isValidStructType(Operand->get_type())) {
      // Input type is not a valid struct type
      printf("Operand not struct type\n");
      baseType = Operand->get_type();
      op = SPECIAL_CAST;
    }
    else {
      printf("Operand is of struct type\n");
      SgType* inputType = (ArithCheck::UnderlyingType.find(Operand->get_type()))->second;
      printf("inputType: %s\n", inputType->class_name().c_str());
      ROSE_ASSERT(inputType);
      baseType = skip_RefsPointersAndTypedefs(inputType);
      printf("baseType: %s\n", baseType->class_name().c_str());
      op = CAST;
    }
    printf("baseType: %s\n", baseType->class_name().c_str());


    // *****IMPORTANT***** it might be possible that the expression is
    // ptr = NULL --- in this case, the NULL is an unsigned int pointer.
    // Its not a struct type, so we first find out its base type... unsigned int
    // ... and then find the correct name of the function. BUT>>>>>>>
    // the function itself will still have an unsigned int pointer type since
    // thats the original type
    // Therefore, we *SHOULDN'T* modify the origRetType -- leaving it
    // as it is means that the function prototype will use unsigned int*
    // and not unsigned int
    // Ret Type
    SgType* origRetType = uop->get_type();
    printf("origRetType: %s\n", origRetType->class_name().c_str());

    SgType* baseRetType = skip_RefsPointersAndTypedefs(origRetType);
    printf("baseRetType: %s\n", baseRetType->class_name().c_str());


    printf("Cast uop: %s\n", baseRetType->class_name().c_str());

    SgName s_name = getOverloadingFunction(baseRetType, baseType, op);
    printf("s_name: %s\n", s_name.getString().c_str());

      SgExprListExp* parameter_list = buildExprListExp();

    SgExpression* Operand_Copy = copyExpression(Operand);
    printf("Operand_Copy: %s\n", Operand_Copy->get_type()->class_name().c_str());

      appendExpression(parameter_list, Operand_Copy);

    // FIXED BELOW
    // This return type needs to be the struct_type corresponding to the *casted* type
    // i.e. if we are casting from void pointer to integer pointer using the struct
    // then, by the time we reach this point, the void pointer has been converted to
    // a void type struct already. This function should basically create a struct of
    // integer type, and return that struct variable by value
    // One way to do this, is to maintain a reverse map of the UnderlyingType, and
    // simple find the correct struct type to return

    //SgType* retType = isSgCastExp(uop)->get_type();
    SgType* retType = (ArithCheck::RelevantStructType.find(isSgCastExp(uop)->get_type()))->second;
    printf("before ROSE_ASSERT retType\n");
    ROSE_ASSERT(retType);
    printf("after ROSE_ASSERT retType\n");

      SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(s_name,
                                                                  retType,
                                                                  parameter_list,
                                                                  scope);

    createForwardDeclIfNotAvailable(s_name, retType, parameter_list, scope, project);

    // If the parent is an assign initializer, then we do set_operand before removing
    // the uop
    SgNode* parent = isSgNode(uop)->get_parent();


      replaceExpression(uop, NewFunction);

    if(isSgAssignInitializer(parent)) {
      printf("Found Assign Initializer\n");
      isSgAssignInitializer(parent)->set_operand(NewFunction);
    }


  }
  else
  {
    // FIXME:We could convert the rest of the unary to binary ops -- just like
    // arithmetic checks
    printf("Converting Unary to Binary Op\n");
    // Convert ptr++ to ptr = ptr + 1
    SgExpression* LHS = copyExpression(uop->get_operand());
    SgExpression* RHS = isSgExpression(buildUnsignedIntVal(1));
    SgExpression* LVal = copyExpression(LHS);

    SgBinaryOp* BinaryOp;
    SgBinaryOp* AssgOp;

    switch(uop->variantT()) {
      case V_SgPlusPlusOp:
        BinaryOp = buildAddOp(LHS, RHS);
        AssgOp = buildAssignOp(LVal, BinaryOp);
        replaceExpression(isSgExpression(uop), isSgExpression(AssgOp));
        handleBinaryOp(BinaryOp, project);
        break;
      case V_SgMinusMinusOp:
        BinaryOp = buildSubtractOp(LHS, RHS);
        AssgOp = buildAssignOp(LVal, BinaryOp);
        replaceExpression(isSgExpression(uop), isSgExpression(AssgOp));
        handleBinaryOp(BinaryOp, project);
        break;
      default:
        printf("Unary Op not known\n");
        printf("UnaryOp: %s = %s\n", isSgNode(uop)->sage_class_name(),
                      isSgNode(uop)->unparseToString().c_str());
        ROSE_ASSERT(0);
    }

  }
  printf("Done with UnaryOp\n");

}

bool isFreeOrFlush(SgFunctionCallExp* fncall) {

  if(strcmp(fncall->getAssociatedFunctionDeclaration()->get_name().str(), "free") == 0) {
    return true;
  }
  else if(strcmp(fncall->getAssociatedFunctionDeclaration()->get_name().str(), "fflush") == 0) {
    return true;
  }
  return false;
}



void ArithCheck::handleFuncCallExp(SgFunctionCallExp* fncall, SgProject* project) {

  printf("handleFuncCallExp\n");
  printf("Function: %s\n", fncall->getAssociatedFunctionDeclaration()->get_name().str());

  // Replace malloc calls with malloc_wrap
  if(strcmp(fncall->getAssociatedFunctionDeclaration()->get_name().str(), "malloc") == 0) {
    printf("Found malloc\n");
    SgStatement* stmt = getSurroundingStatement(*isSgExpression(fncall));
      SgScopeStatement* scope = stmt->get_scope();

    SgExprListExp* args = fncall->get_args();

    // Now that we have the function ref exp (ref) and the args (args), lets create a
    // new function call expression, and substitute that, in this one's place

    SgExprListExp* new_args = isSgExprListExp(deepCopyNode(isSgNode(args)));

    SgName s_name("malloc_wrap");

    // Since mallocs return void pointers, we have to find the relevant structure
    // for the void pointer
    SgType* baseType = SgPointerType::createType(SgTypeVoid::createType());
    SgType* retType = (ArithCheck::RelevantStructType.find(baseType))->second;
//    SgType* retType = ArithCheck::MallocWrapFnDecl->get_type()->get_return_type();

      SgExpression* new_callexp = SageBuilder::buildFunctionCallExp(ArithCheck::MallocWrapFnDecl->get_name(),
                                  //struct_type, //callexp->get_type(), -- malloc wrap returns a struct_type variable
                                  //ArithCheck::MallocWrapFnDecl->get_type()->get_return_type(),
                                  retType,
                                                                  new_args,
                                                                  scope);


    createForwardDeclIfNotAvailable(s_name, retType, new_args, scope, project);


      replaceExpression(fncall, new_callexp);
  }
  else if(isFreeOrFlush(fncall)) {

  //else if(strcmp(fncall->getAssociatedFunctionDeclaration()->get_name().str(), "free") == 0) {
    printf("Found free\n");
    SgStatement* stmt = getSurroundingStatement(*isSgExpression(fncall));
      SgScopeStatement* scope = stmt->get_scope();

    SgExprListExp* args = fncall->get_args();

    // Now that we have the function ref exp (ref) and the args (args), lets create a
    // new function call expression, and substitute that, in this one's place

    SgExprListExp* new_args = isSgExprListExp(deepCopyNode(isSgNode(args)));

    //SgName s_name("free_wrap");
    std::string newname = fncall->getAssociatedFunctionDeclaration()->get_name() + "_wrap";
    SgName s_name(newname);

    SgType* retType = SgTypeVoid::createType();

      SgExpression* new_callexp = SageBuilder::buildFunctionCallExp(s_name,
                                  //struct_type, //callexp->get_type(), -- malloc wrap returns a struct_type variable
                                  //ArithCheck::MallocWrapFnDecl->get_type()->get_return_type(),
                                  //SgTypeVoid::createType(),
                                  retType,
                                                                  new_args,
                                                                  scope);

    createForwardDeclIfNotAvailable(s_name, retType, new_args, scope, project);

      replaceExpression(fncall, new_callexp);


  }
  else {
  // All other functions, change return type -- so the type of
  // the node will change



    SgStatement* stmt = getSurroundingStatement(*isSgExpression(fncall));
      SgScopeStatement* scope = stmt->get_scope();

    SgExprListExp* args = fncall->get_args();

    // Now that we have the function ref exp (ref) and the args (args), lets create a
    // new function call expression, and substitute that, in this one's place

    SgExprListExp* new_args = isSgExprListExp(deepCopyNode(isSgNode(args)));

    SgFunctionDeclaration* fndecl = fncall->getAssociatedFunctionDeclaration();

    SgFunctionType* fndecl_type = fndecl->get_type();

    SgType* retType = fndecl_type->get_return_type();


    if(isValidStructType(retType)) {
      return;
    }

    SgType* struct_type = getStructType(retType);

      SgExpression* new_callexp = SageBuilder::buildFunctionCallExp(fndecl->get_name(),
                                  struct_type,
                                                                  new_args,
                                                                  scope);

      replaceExpression(fncall, new_callexp);

    ROSE_ASSERT(isValidStructType(new_callexp->get_type()));

  }
  printf("Done with handleFuncCallExp\n");

}

void ArithCheck::handleFuncDecl(SgFunctionDeclaration* fndecl) {

  SgScopeStatement* scope = fndecl->get_scope();
  printf("Got scope\n");

  SgFunctionParameterList* paramList = fndecl->get_parameterList();

  printf("Got paramList\n");


  SgFunctionParameterList* newList = isSgFunctionParameterList(deepCopyNode(isSgNode(paramList)));
  printf("copied paramlist\n");


  SgName name = fndecl->get_name();

  printf("Got name, copied paramlists. Now for decoratorList\n");
  SgExprListExp* decoratorList = fndecl->get_decoratorList();
  SgExprListExp* new_decList = isSgExprListExp(deepCopyNode(isSgNode(decoratorList)));

  SgType* retType = getStructType(fndecl->get_type()->get_return_type());
  ROSE_ASSERT(isValidStructType(retType));

  SgFunctionDefinition* fndef = fndecl->get_definition();
  printf("Choosing between nondef and def\n");
  if(fndef) {
    printf("Defining fn decl\n");
    // This is a defining func decl.
    SgFunctionDeclaration* new_fndecl = buildDefiningFunctionDeclaration(name,
                                      retType,
                                      newList,
                                      scope,
                                      new_decList);

    SgFunctionDefinition* newdef = isSgFunctionDefinition(deepCopyNode(isSgNode(fndef)));

    new_fndecl->set_definition(newdef);
    isSgNode(newdef)->set_parent(new_fndecl);

    replaceStatement(fndecl, new_fndecl);

    ROSE_ASSERT(isValidStructType(new_fndecl->get_type()->get_return_type()));
  }
  else {
    printf("Nondefining fn decl\n");
    // Nondefining fn decl
    SgFunctionDeclaration* new_fndecl = buildNondefiningFunctionDeclaration(name,
                                      retType,
                                      newList,
                                      scope,
                                      new_decList);

    replaceStatement(fndecl, new_fndecl);

    ROSE_ASSERT(isValidStructType(new_fndecl->get_type()->get_return_type()));
  }

}

void ArithCheck::handleIntVal(SgIntVal* intval) {

  SgIntVal* new_intval = buildIntVal(intval->get_value());

  replaceExpression(isSgExpression(intval), isSgExpression(new_intval));

}

void ArithCheck::handleLongIntVal(SgLongIntVal* longintval) {

  SgIntVal* new_longintval = buildIntVal(longintval->get_value());

  replaceExpression(isSgExpression(longintval), isSgExpression(new_longintval));
}


void ArithCheck::InstrumentNodes2(SgProject* project) {

  printf("InstrumentNodes2 - begin\n");
  for(NodeContainer::iterator nit = ArithCheck::NodesToInstrument.begin(); nit != ArithCheck::NodesToInstrument.end(); ++nit) {

    SgNode* node = *nit;
    Sg_File_Info* File = isSgNode(node)->get_file_info();
    printf("Current: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());
    printf("File: (%s, %d, %d) %s = %s\n", File->get_filenameString().c_str(),
                      File->get_line(),
                      File->get_col(),
                      isSgNode(node)->sage_class_name(),
                      isSgNode(node)->unparseToString().c_str());


    if(SgInitializedName* name = isSgInitializedName(node)) {
      if(isSgVariableDeclaration(isSgNode(node)->get_parent())) {
        handleVarDecls(name);
      }
      #if 0
      if(isSgVariableDeclaration(name->get_declaration())) {
        handleVarDecls(name);
      }
      #endif
      else if(isSgFunctionParameterList(isSgNode(name)->get_parent())) {
        handleFuncParamLists(name, project);
      }
    }

    if(SgVarRefExp* varref = isSgVarRefExp(node)) {
      handleVarRefExp(varref);
    }

    if(SgBinaryOp* bop = isSgBinaryOp(node)) {
      handleBinaryOp(bop, project);
    }

    if(SgUnaryOp* uop = isSgUnaryOp(node)) {
      handleUnaryOp(uop, project);
    }

    if(SgFunctionCallExp* fncall = isSgFunctionCallExp(node)) {
      handleFuncCallExp(fncall, project);
    }

    if(SgFunctionDeclaration* fndecl = isSgFunctionDeclaration(node)) {
      printf("SgFunctionDeclaration: %s\n", fndecl->get_name().getString().c_str());
      handleFuncDecl(fndecl);
    }
    // Required to handle NULL assignemnts to pointers
    // In these cases, the AST gets a bit messy with a cast from
    // long int to pointer long int. This pointer long int is set in the expressionTree
    // of the intval (this one) and then cast to unsigned int* which is the final
    // type. Here, we cut the expressionTree part for this intval, so that
    // the AST simplifies to Cast(unsigned int) ... and we use a function to
    // apply this to structures.
    if(SgIntVal *intval = isSgIntVal(node)) {
      printf("SgIntVal found\n");
      handleIntVal(intval);
    }
    if(SgLongIntVal *longintval = isSgLongIntVal(node)) {
      printf("SgLongIntVal found\n");
      handleLongIntVal(longintval);
    }

  }
  printf("InstrumentNodes2 - end\n");

}

void ArithCheck::createStructs(SgProject* project) {

  SgNode* TopNode = isSgNode(project);

  SgFilePtrList file_list = project->get_fileList();
  SgFilePtrList::iterator iter;

  for(iter = file_list.begin(); iter != file_list.end(); iter++) {



    // Create different types of structs
    std::string Structs[STRUCT_ARRAY] = {"UIntStruct", "IntStruct", "FloatStruct", "DoubleStruct", "CharStruct", "VoidStruct", "LongIntStruct"};
    SgType* Types[STRUCT_ARRAY] = {SgTypeUnsignedInt::createType(),
            SgTypeInt::createType(),
            SgTypeFloat::createType(),
            SgTypeDouble::createType(),
            SgTypeChar::createType(),
            SgTypeVoid::createType(),
            SgTypeLong::createType()};


    // Getting current file and scope for it
    SgSourceFile* cur_file = isSgSourceFile(*iter);
    SgGlobal* global_scope = cur_file->get_globalScope();

    // Get the top node for this file. Struct will be inserted at this scope
    // FIXME: May want to do this at the "project" level instead, but not sure yet.
    // The problem with this approach is that there might re-definitions, since each file
    // has its version of struct
    SgNode* fileTop = isSgNode(cur_file);

    // Create a struct declaration. Variables on this struct will replace the current pointer
    // variables
    // STOPPED HERE

    for(unsigned int index = 0; index < STRUCT_ARRAY; index++) {

      SgClassDeclaration* structdecl = SageBuilder::buildStructDeclaration(Structs[index], global_scope);
      SgType* struct_type = structdecl->get_type();

      ArithCheck::created_struct_type = struct_type;

      // To get this structure into ROSE's symbol table, and access its members, the struct/class
      // needs to be defined here.
      SgClassDefinition* classdef = buildClassDefinition(structdecl);

      // Adding the ptr2obj variable to the struct (struct and class mean the same within ROSE)
      // struct IntStruct {
      //  unsigned int* ptr2obj;
      //  unsigned int* L;
      //  unsigned int* H;
      // };

      #if 1
      SgType* ptr2objvarType = SgPointerType::createType(Types[index]);
      SgVariableDeclaration* ptr2objvar = SageBuilder::buildVariableDeclaration("ptr2obj", ptr2objvarType , NULL, global_scope);
      classdef->append_member(ptr2objvar);
      SgVariableDeclaration* lowervar = SageBuilder::buildVariableDeclaration("L", ptr2objvarType, NULL, global_scope);
      classdef->append_member(lowervar);
      SgVariableDeclaration* uppervar = SageBuilder::buildVariableDeclaration("H", ptr2objvarType, NULL, global_scope);
      classdef->append_member(uppervar);
      #endif
      // FIXME: This needs to be done at the file level -- i.e. There has to be another level of indirection
      // so that we do this at the file, or -- we could do the traversal and instrumentation on one file
      // after another -- this might be better...
      ArithCheck::UnderlyingType.insert(TypeMap_t::value_type(struct_type, ptr2objvarType));
      ArithCheck::RelevantStructType.insert(TypeMap_t::value_type(ptr2objvarType, struct_type));

      // insert the struct declaration, so that ROSE knows that it exists
      isSgScopeStatement(global_scope)->insertStatementInScope(structdecl, true);
    }
  }
}

void ArithCheck::createMallocWrapForwardDecl(SgProject* project) {

  // Malloc wrap forward declaration
  SgFunctionParameterList* MallocWrapParamList = buildFunctionParameterList();
  MallocWrapParamList->append_arg(buildInitializedName(SgName("size"),SgTypeUnsignedInt::createType()));

  SgGlobal* globalScope = getFirstGlobalScope(project);
  pushScopeStack(globalScope);

  SgType* retType = getStructType(SgPointerType::createType(SgTypeVoid::createType()));

  SgFunctionDeclaration* MallocWrapForwardDecl = buildNondefiningFunctionDeclaration(SgName("malloc_wrap"),
                                            retType,
                                            MallocWrapParamList);

  ArithCheck::MallocWrapFnDecl = MallocWrapForwardDecl;

  prependStatement(isSgStatement(MallocWrapForwardDecl));

  popScopeStack();
}

void ArithCheck::HackyPtrCheck5() {

  printf("HackyPtrCheck5\n");

  // Get the top level project
  SgProject* project = CheckBase::CBProject;

  BUTracking but;
  but.traverseInputFiles(project);
//  InstrumentNodes(project);

  printf("Done with traversing. Now for the changes\n");

  createStructs(project);
  createMallocWrapForwardDecl(project);

  InstrumentNodes2(project);
  printf("Done with HackyPtrCheck5\n");
}


void ArithCheck::HackyPtrCheck4() {

  // Get the top level project
  SgProject* project = CheckBase::CBProject;

  // Convert project to node
  SgNode* TopNode = isSgNode(project);
  // Get file_list. These are the files that constitute the input
  // We iterate over these files, and replace pointers with
  // struct variables, and accesses to struct variables
  SgFilePtrList file_list = project->get_fileList();
  SgFilePtrList::iterator iter;
  // FIXME: It is highly likely that we will run into scope problems since the struct_type and struct_decl
  // here are declared for each file, where as the instrumentation below for VarNames and MallocRefs happens
  // for all the files. We are using the struct_decl from one file (the last one traversed), and applying it
  // to every other file below. --- NEEDS TO BE FIXED
  SgType* struct_type = NULL;
  SgClassDeclaration* structdecl = NULL;
  for(iter = file_list.begin(); iter != file_list.end(); iter++) {


    // Getting current file and scope for it
    SgSourceFile* cur_file = isSgSourceFile(*iter);
    SgGlobal* global_scope = cur_file->get_globalScope();

    // Get the top node for this file. Struct will be inserted at this scope
    // FIXME: May want to do this at the "project" level instead, but not sure yet.
    // The problem with this approach is that there might re-definitions, since each file
    // has its version of struct
    SgNode* fileTop = isSgNode(cur_file);

    // FIXME: **ALWAYS DO THE QUERYSUBTREE BEFORE THE STRUCT DECLARATION. OTHERWISE, THE POINTER IN THE
    // STRUCT WILL ALSO BE REPLACED, AND TRANSFORMED, LIKE EVERY OTHER POINTER
    // Getting variable declarations in the current file
    Rose_STL_Container<SgNode*> varDeclList;
    varDeclList=NodeQuery::querySubTree(fileTop,V_SgVariableDeclaration);


    // Create a struct declaration. Variables on this struct will replace the current pointer
    // variables
    //SgClassDeclaration* structdecl = SageBuilder::buildStructDeclaration("IntStruct", global_scope);
    structdecl = SageBuilder::buildStructDeclaration("IntStruct", global_scope);
    //SgType* struct_type = structdecl->get_type();
    struct_type = structdecl->get_type();

    ArithCheck::created_struct_type = struct_type;

    // To get this structure into ROSE's symbol table, and access its members, the struct/class
    // needs to be defined here.
    SgClassDefinition* classdef = buildClassDefinition(structdecl);

    // Adding the ptr2obj variable to the struct (struct and class mean the same within ROSE)
    // struct IntStruct {
    //  unsigned int* ptr2obj;
    //  unsigned int* L;
    //  unsigned int* H;
    // };
    #if 1
    SgType* ptr2objvarType = SgPointerType::createType(SgTypeUnsignedInt::createType());
    SgVariableDeclaration* ptr2objvar = SageBuilder::buildVariableDeclaration("ptr2obj", ptr2objvarType , NULL, global_scope);
    classdef->append_member(ptr2objvar);
    SgVariableDeclaration* lowervar = SageBuilder::buildVariableDeclaration("L", ptr2objvarType, NULL, global_scope);
    classdef->append_member(lowervar);
    SgVariableDeclaration* uppervar = SageBuilder::buildVariableDeclaration("H", ptr2objvarType, NULL, global_scope);
    classdef->append_member(uppervar);
    #endif
    ArithCheck::UnderlyingType.insert(TypeMap_t::value_type(struct_type, ptr2objvarType));
    ArithCheck::RelevantStructType.insert(TypeMap_t::value_type(ptr2objvarType, struct_type));

    // insert the struct declaration, so that ROSE knows that it exists
    isSgScopeStatement(global_scope)->insertStatementInScope(structdecl, true);
  }

  ROSE_ASSERT(structdecl != NULL);
  ROSE_ASSERT(struct_type != NULL);


  ROSE_ASSERT(!TraversalBase::MallocRefs.empty());


  // Malloc wrap forward declaration
  SgFunctionParameterList* MallocWrapParamList = buildFunctionParameterList();
  MallocWrapParamList->append_arg(buildInitializedName(SgName("size"),SgTypeUnsignedInt::createType()));

  SgGlobal* globalScope = getFirstGlobalScope(project);
  pushScopeStack(globalScope);

  SgFunctionDeclaration* MallocWrapForwardDecl = buildNondefiningFunctionDeclaration(SgName("malloc_wrap"),
                                            struct_type,
                                            MallocWrapParamList);
  prependStatement(isSgStatement(MallocWrapForwardDecl));

  popScopeStack();




  // Do this one first since the malloc refs will be replaced below with their copies -- once the variable initializations
  // are copied, and the old ones are removed
  // FIXME: Need to remove any casts which exists between the malloc return call, and the rest of expression. These casts
  // are typically done to convert the malloc return type (which I presume is void*) to the correct pointer type
  for(NodeContainer::iterator nit = TraversalBase::MallocRefs.begin(); nit != TraversalBase::MallocRefs.end(); ++nit) {

    SgFunctionRefExp* ref = isSgFunctionRefExp(*nit);

    ROSE_ASSERT(strcmp(ref->getAssociatedFunctionDeclaration()->get_name().str(), "malloc") == 0);

    SgNode* parent = (*nit)->get_parent();

    printf("parent: %s = %s\n", parent->sage_class_name(), parent->unparseToString().c_str());

    ROSE_ASSERT(isSgFunctionCallExp(parent));

    SgCallExpression* callexp = isSgCallExpression(parent);

    SgStatement* stmt = getSurroundingStatement(*isSgExpression(callexp));
      SgScopeStatement* scope = stmt->get_scope();

    SgExprListExp* args = callexp->get_args();

    // Now that we have the function ref exp (ref) and the args (args), lets create a
    // new function call expression, and substitute that, in this one's place

    SgExprListExp* new_args = isSgExprListExp(deepCopyNode(isSgNode(args)));

    SgName s_name("malloc_wrap");

      SgExpression* new_callexp = SageBuilder::buildFunctionCallExp(s_name,
                                  struct_type, //callexp->get_type(), -- malloc wrap returns a struct_type variable
                                                                  new_args,
                                                                  scope);

      replaceExpression(callexp, new_callexp);
  }

  //SymbolMap_t varRemap;
  VariableSymbolMap_t varRemap;

  ROSE_ASSERT(!TraversalBase::VarNames.empty());


  #if 0
  for(NodeContainer::iterator nit = TraversalBase::VarNames.begin(); nit != TraversalBase::VarNames.end(); ++nit) {

    SgInitializedName* name = isSgInitializedName(*nit);
    ROSE_ASSERT(name);
    // Now, lets collect a few things about the current variable
    // 1. Initializer -- if it exists
    // 2. Symbol -- to refer to the symbol table
    SgInitializer* init = name->get_initializer();
    printf("var: %s\n", name->get_name().str());
    SgSymbol* symbol = name->get_symbol_from_symbol_table();
    SgVariableSymbol *varsymbol = isSgVariableSymbol(symbol);

    // Lets start creating the new variable, which will be a struct variable
    std::string newname_string = name->get_qualified_name().getString() + "_structed" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++);
    SgName newName(newname_string);
    printf("created new name: %s\n", newname_string.c_str());
            // Before we replace anything, lets check what the initializer is. If it is NULL, we'll replace the *current* variable declaration itself!
    // If the initializer is not NULL, we create a statement for it, and then replace the *current* variable declaration
    //SgStatement* prevStmt = getSuitablePrevStmt(varDecl);


    //SgVariableDeclaration* newvar;
    SgInitializedName *new_name = NULL;
    SgExpression* new_init_value = NULL;
    SgAssignInitializer* new_init = NULL;
    if(init != NULL) {
      // There is a valid initializer. Make a new var decl using it
      SgExpression* cur_init_value = isSgAssignInitializer(init)->get_operand();
      //SgExpression* new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
      new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
      printf("copied initialization\n");
      //SgAssignInitializer* new_init = buildAssignInitializer(new_init_value, new_init_value->get_type());
      new_init = buildAssignInitializer(new_init_value, new_init_value->get_type());
      //newvar->reset_initializer(new_init);
      //newvar = buildVariableDeclaration(newName, struct_type, new_init, name->get_declaration()->get_scope());
      new_name = buildInitializedName(newName, struct_type, new_init);
    }
    else {
      new_name = buildInitializedName(newName, struct_type, NULL);
      //newvar = buildVariableDeclaration(newName, struct_type, NULL, name->get_declaration()->get_scope());
    }
    ROSE_ASSERT(new_name != NULL);

    // FIXME: This might be the wrong scope setting --- The scope setting should be correct when it is done below
    // in the respective cases -- vardecl, fnparam
    #if 0
    SgStatement* stmt = getSurroundingStatement(*isSgNode(name));
      SgScopeStatement* scope = stmt->get_scope();
    new_name->set_scope(scope);
    #else
    // Trying the function definition scope setting
    new_name->set_scope(name->get_scope());
    #endif

    // printf("created new decl\n");
    // In some cases, inserting the new variable just before the previous one doesn't do.
    // so... we have multiple cases
    //printf("varDecl: %s = %s\n", isSgNode(name->get_declaration())->sage_class_name(), isSgNode(name->get_declaration())->unparseToString().c_str());
    //replaceStatement(name->get_declaration(), isSgStatement(newvar));

    SgScopeStatement* newvar_scope = NULL;

    #if 1
    // Might want to figure out what the parent is, in this case -- because the substitution would be dependent on the parent node.
    printf("Finding parent type, to perform suitable replacement\n");
    printf("parent: %s = %s\n", isSgNode(name)->get_parent()->sage_class_name(), isSgNode(name)->get_parent()->unparseToString().c_str());
    if(isSgVariableDeclaration(isSgNode(name)->get_parent())) {
      // Its part of a variable declaration
      printf("Variable Decl\n");
      SgVariableDeclaration* newvar;
      // Unfortunately, variable declaration cannot be built from initialized name. It has to be built from the Sgname, type, initializer
      // and scope info.
      newvar_scope = name->get_declaration()->get_scope();
      newvar = buildVariableDeclaration(new_name->get_name(), struct_type, new_init, name->get_declaration()->get_scope());
      replaceStatement(name->get_declaration(), isSgStatement(newvar));
    }
    else if(isSgFunctionParameterList(isSgNode(name)->get_parent())) {

      SgFunctionParameterList* oldParamList = isSgFunctionParameterList(isSgNode(name)->get_parent());
      SgFunctionDeclaration* fndecl = isSgFunctionDeclaration(isSgNode(oldParamList)->get_parent());
      SgFunctionParameterList* newParamList = buildFunctionParameterList();

      printf("Function Parameter List\n");
      SgInitializedNamePtrList& args = oldParamList->get_args();

      SgInitializedNamePtrList::iterator it;
      bool found = false;
      for(it = args.begin(); it != args.end(); it++) {
        SgInitializedName* paramname = *it;
        SgInitializedName* new_paramname = NULL;
        if(paramname == name) {
          new_paramname = new_name;
          found = true;
        }
        else {
          new_paramname = isSgInitializedName(deepCopy(isSgNode(paramname)));
        }
        ROSE_ASSERT(new_paramname != NULL);

        newParamList->append_arg(new_paramname);
      }

      ROSE_ASSERT(found);

      newvar_scope = oldParamList->get_scope();

      printf("Before replace\n");
      outputLocalSymbolTables(isSgNode(fndecl));

      //replaceStatement(oldParamList, newParamList);
      isSgNode(newParamList)->set_parent(fndecl);
      fndecl->set_parameterList(newParamList);

      SgInitializedNamePtrList& newargs = newParamList->get_args();
      for(it = newargs.begin(); it != newargs.end(); it++) {
        SgInitializedName* paramname = *it;
        printf("newparamlist: %s = %s\n", isSgNode(paramname)->sage_class_name(), isSgNode(paramname)->unparseToString().c_str());
      }

      printf("after replace\n");
      outputLocalSymbolTables(isSgNode(fndecl));




      //SgVariableSymbol* newvar_symbol = lookupVariableSymbolInParentScopes(new_name->get_name(), newvar_scope);
      SgClassSymbol* newvar_symbol = lookupClassSymbolInParentScopes(new_name->get_name(), newvar_scope);
      ROSE_ASSERT(newvar_symbol != NULL);



      ROSE_ASSERT(newParamList == fndecl->get_parameterList());

      #if 0
      // Its part of a function parameter list
      printf("Function Parameter List\n");
      SgInitializedNamePtrList& args = isSgFunctionParameterList(isSgNode(name)->get_parent())->get_args();

      bool found = false;
      SgInitializedNamePtrList::iterator it;
      for(it = args.begin(); it != args.end(); it++) {
        if(*it == name) {
          printf("Found initialized name\n");
          found = true;
          break;
        }
      }

      ROSE_ASSERT(found);

      args.erase(it);
      //args.push_back(new_name);

      isSgFunctionParameterList(isSgNode(name)->get_parent())->append_arg(new_name);

      #if 0
      SgInitializedNamePtrList::iterator it = args.find(name);
      if(it != args.end()) {
        // Found the initialized name
        printf("Found initialized name\n");
        args.remove(it);
      }
      else {
        ROSE_ASSERT(0);
      }
      args.push_back(new_name);
      #endif
      printf("Added new args\n");
      #endif
    }
    else {
      printf("Unknown type\n");
      ROSE_ASSERT(0);
    }
    #endif

    ROSE_ASSERT(newvar_scope != NULL);

    rebuildSymbolTable(newvar_scope);
    SgVariableSymbol* newvar_symbol = lookupVariableSymbolInParentScopes(new_name->get_name(), newvar_scope);
    ROSE_ASSERT(newvar_symbol != NULL);
    varRemap.insert(SymbolMap_t::value_type(isSgSymbol(varsymbol), newvar_symbol));
    //varRemap.insert(SymbolMap_t::value_type(isSgSymbol(varsymbol), isSgSymbol(new_name->get_symbol_from_symbol_table())));

  }
  #endif


  // This one works -- handles variable declarations, not function parameter lists
  #if 1
  for(NodeContainer::iterator nit = TraversalBase::VarNames.begin(); nit != TraversalBase::VarNames.end(); ++nit) {

    SgInitializedName* name = isSgInitializedName(*nit);
    ROSE_ASSERT(name);
    // Now, lets collect a few things about the current variable
    // 1. Initializer -- if it exists
    // 2. Symbol -- to refer to the symbol table
    if(!isSgVariableDeclaration(name->get_declaration())) {
      printf("Not Var Decl: %s = %s\n", isSgNode(name->get_declaration())->sage_class_name(), isSgNode(name->get_declaration())->unparseToString().c_str());
      continue;
    }
    SgInitializer* init = name->get_initializer();
    printf("var: %s\n", name->get_qualified_name().str());
    SgSymbol* symbol = name->get_symbol_from_symbol_table();
    SgVariableSymbol *varsymbol = isSgVariableSymbol(symbol);

    // Lets start creating the new variable, which will be a struct variable
    std::string newname_string = name->get_qualified_name().getString() + "_structed" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++);
    SgName newName(newname_string);
    printf("created new name: %s\n", newname_string.c_str());
            // Before we replace anything, lets check what the initializer is. If it is NULL, we'll replace the *current* variable declaration itself!
    // If the initializer is not NULL, we create a statement for it, and then replace the *current* variable declaration
    //SgStatement* prevStmt = getSuitablePrevStmt(varDecl);

    SgVariableDeclaration* newvar;

    if(init != NULL) {
      // There is a valid initializer. Make a new var decl using it
      SgExpression* cur_init_value = isSgAssignInitializer(init)->get_operand();
      SgExpression* new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
      printf("copied initialization\n");
      SgAssignInitializer* new_init = buildAssignInitializer(new_init_value, new_init_value->get_type());
      //newvar->reset_initializer(new_init);
      newvar = buildVariableDeclaration(newName, struct_type, new_init, name->get_declaration()->get_scope());
    }
    else {
      newvar = buildVariableDeclaration(newName, struct_type, NULL, name->get_declaration()->get_scope());
    }
    // printf("created new decl\n");
    // In some cases, inserting the new variable just before the previous one doesn't do.
    // so... we have multiple cases
    //printf("varDecl: %s = %s\n", isSgNode(name->get_declaration())->sage_class_name(), isSgNode(name->get_declaration())->unparseToString().c_str());
    SgInitializedNamePtrList& newvarList = newvar->get_variables();
    assert(newvarList.size() == 1);
    SgInitializedName* newname = *(newvarList.begin());
    SgSymbol* newsymbol = newname->get_symbol_from_symbol_table();

    replaceStatement(name->get_declaration(), isSgStatement(newvar));
    varRemap.insert(VariableSymbolMap_t::value_type(varsymbol, isSgVariableSymbol(newsymbol)));
  }
  #endif

  // Not using VarRefs... since the uses might have been removed while copying the initialization over from
  // the old variable declaration, to the new one.
  #if 0
  ROSE_ASSERT(!TraversalBase::VarRefs.empty());

  for(NodeContainer::iterator nit = TraversalBase::VarRefs.begin(); nit != TraversalBase::VarRefs.end(); nit++) {

    SgVarRefExp* old_ref = isSgVarRefExp(*nit);
    SgVariableSymbol* old_symbol = old_ref->get_symbol();
    //SgSymbol* old_symbol = old_ref->get_symbol();
    ROSE_ASSERT(old_symbol != NULL);
    VariableSymbolMap_t::iterator iter = varRemap.find(old_ref->get_symbol());

    if(iter != varRemap.end()) {
      SgVariableSymbol* newsymbol = iter->second;
      //SgSymbol* newsymbol = iter->second;

      ROSE_ASSERT(newsymbol != NULL);

      SgVarRefExp* structref = buildVarRefExp(isSgVariableSymbol(newsymbol));

      ROSE_ASSERT(structref != NULL);
      //SgVarRefExp* objref = buildVarRefExp(ptr2objvar);
      //SgDotExp* newdotexp = buildDotExp(structref, objref);
      //replaceExpression(old_ref, newdotexp);
      replaceExpression(old_ref, structref);
    }
  }
  #endif


  // Here, we will handle the parameter list variables, in the VarNames list. This needs to be done after
  // the variable declarations since this part will rewrite function definitions like nobody's business, and
  // that means we will be invalidating the "names" on the VarNames list, which are variable declarations.
  // Building a new function definition means that we will be copying the body over. The body contains variable
  // declarations, stored in VarNames. The older version of that body will be deleted, hence VarNames pointers
  // will become useless

  for(NodeContainer::iterator nit = TraversalBase::VarNames.begin(); nit != TraversalBase::VarNames.end(); ++nit) {

    SgInitializedName* name = isSgInitializedName(*nit);
    ROSE_ASSERT(name);

    SgNode* parent = isSgNode(name)->get_parent();

    if(!isSgFunctionParameterList(parent)) {
      // Only handle SgFunctionParameterList work here
      continue;
    }

    SgFunctionParameterList* oldParamList = isSgFunctionParameterList(isSgNode(name)->get_parent());
    SgFunctionDeclaration* fndecl = isSgFunctionDeclaration(isSgNode(oldParamList)->get_parent());
    SgFunctionDefinition* def = fndecl->get_definition();

    if(def == NULL) {
      printf("Looks like an external function call. vardecl->def = NULL\n");
      continue;
    }

    // Adding global scope to ScopeStack -- this will be the
    // default scope for now
    SgGlobal* globalScope = getFirstGlobalScope(project);
    pushScopeStack(isSgScopeStatement(globalScope));

    //
    SgInitializer* init = name->get_initializer();
    printf("var: %s\n", name->get_name().str());
    SgSymbol* symbol = name->get_symbol_from_symbol_table();
    SgVariableSymbol *varsymbol = isSgVariableSymbol(symbol);

    // Lets start creating the new variable, which will be a struct variable
    std::string newname_string = name->get_name().getString() + "_structed" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++);
    SgName newName(newname_string);
    printf("created new name: %s\n", newname_string.c_str());
    // Before we replace anything, lets check what the initializer is. If it is NULL, we'll replace the *current* variable declaration itself!
    // If the initializer is not NULL, we create a statement for it, and then replace the *current* variable declaration
    SgInitializedName *new_name = NULL;
    SgExpression* new_init_value = NULL;
    SgAssignInitializer* new_init = NULL;
    if(init != NULL) {
      // There is a valid initializer. Make a new var decl using it
      SgExpression* cur_init_value = isSgAssignInitializer(init)->get_operand();
      //SgExpression* new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
      new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
      printf("copied initialization\n");
      //SgAssignInitializer* new_init = buildAssignInitializer(new_init_value, new_init_value->get_type());
      new_init = buildAssignInitializer(new_init_value, new_init_value->get_type());
      //newvar->reset_initializer(new_init);
      //newvar = buildVariableDeclaration(newName, struct_type, new_init, name->get_declaration()->get_scope());
      new_name = buildInitializedName(newName, struct_type, new_init);
    }
    else {
      new_name = buildInitializedName(newName, struct_type, NULL);
      //newvar = buildVariableDeclaration(newName, struct_type, NULL, name->get_declaration()->get_scope());
    }
    ROSE_ASSERT(new_name != NULL);


    SgFunctionParameterList* newParamList = buildFunctionParameterList();

    printf("Function Parameter List\n");
    SgInitializedNamePtrList& args = oldParamList->get_args();

    ROSE_ASSERT(def != NULL);

    SgScopeStatement* scopestmt = isSgScopeStatement(def);
    new_name->set_scope(scopestmt);

    SgSymbolTable* symbolTable = scopestmt->get_symbol_table();

    SgInitializedNamePtrList::iterator it;
    bool found = false;

    SgVariableSymbol* newsymbol;
    for(it = args.begin(); it != args.end(); it++) {
      SgInitializedName* paramname = *it;
      SgInitializedName* new_paramname = NULL;
      if(paramname == name) {
        new_paramname = new_name;

        newsymbol = new SgVariableSymbol(new_name);
        isSgNode(newsymbol)->set_parent(isSgNode(varsymbol)->get_parent());
        SgSymbolTable* currSymbolTable = isSgSymbolTable(isSgNode(varsymbol)->get_parent());
        currSymbolTable->insert(new_name->get_name(), newsymbol);

        found = true;
      }
      else {
        new_paramname = isSgInitializedName(deepCopy(isSgNode(paramname)));
      }
      ROSE_ASSERT(new_paramname != NULL);

      newParamList->append_arg(new_paramname);
    }

    replaceStatement(oldParamList, newParamList);

    varRemap.insert(VariableSymbolMap_t::value_type(varsymbol, isSgVariableSymbol(newsymbol)));

    // FIXME: This isn't working --- the return type doesn't seem to be changing
    // If return_type is an unsigned int pointer, need to change that to struct_type as well
    SgType* retType = fndecl->get_type()->get_return_type();
    SgType* baseType = skip_RefsPointersAndTypedefs(retType);
    if(retType->variantT() == V_SgPointerType && baseType->variantT() == V_SgTypeUnsignedInt) {
      printf("Setting return type to struct_type\n");
      fndecl->get_type()->set_return_type(struct_type);
      // FIXME: Not sure why I am inserting this here..
      fndecl->get_type()->set_orig_return_type(struct_type);
    }


    #if 0


    SgBasicBlock* body = def->get_body();

    ROSE_ASSERT(body != NULL);

    SgBasicBlock* new_body = isSgBasicBlock(deepCopy(isSgNode(body)));

    // If the return type of the original function is an unsigned int pointer type -- we
    // change it to struct_type, else we leave it as it is
    SgType* retType = fndecl->get_type()->get_return_type();
    SgType* baseType = skip_RefsPointersAndTypedefs(retType);
    if(retType->variantT() == V_SgPointerType && baseType->variantT() == V_SgTypeUnsignedInt) {
      retType = struct_type;
    }

    SgFunctionDeclaration* new_fndecl = buildDefiningFunctionDeclaration(
                fndecl->get_name(), retType, newParamList);

    SgFunctionDefinition* newdef = new_fndecl->get_definition();

    newdef->set_body(new_body);

    isSgNode(new_body)->set_parent(newdef);

    //appendStatement(new_fndecl);
    replaceStatement(fndecl, new_fndecl);

    #endif

    popScopeStack();

    // Add the symbol to the varRefList
  }



  Rose_STL_Container<SgNode*> varRefList;
  // Using the project as the top node, instead of fileTop (top node of the current file)
  varRefList=NodeQuery::querySubTree(project,V_SgVarRefExp);
  for(NodeContainer::iterator nit = varRefList.begin(); nit != varRefList.end(); nit++) {

    SgVarRefExp* old_ref = isSgVarRefExp(*nit);
    SgVariableSymbol* old_symbol = old_ref->get_symbol();
    //SgSymbol* old_symbol = old_ref->get_symbol();
    ROSE_ASSERT(old_symbol != NULL);
    VariableSymbolMap_t::iterator iter = varRemap.find(old_ref->get_symbol());

    if(iter != varRemap.end()) {
      SgVariableSymbol* newsymbol = iter->second;
      //SgSymbol* newsymbol = iter->second;

      ROSE_ASSERT(newsymbol != NULL);

      SgVarRefExp* structref = buildVarRefExp(isSgVariableSymbol(newsymbol));

      ROSE_ASSERT(structref != NULL);
      //SgVarRefExp* objref = buildVarRefExp(ptr2objvar);
      //SgDotExp* newdotexp = buildDotExp(structref, objref);
      //replaceExpression(old_ref, newdotexp);
      replaceExpression(old_ref, structref);
    }
  }


  // Now that we have
  // 1. Replaced malloc calls with malloc_wrap
  // 2. Replaced variable declarations with structed versions
  // 3. Replaced parameter list declarations with their structed versions
  // 4. Replaced uses of pointers with their structed versions
  // We can proceed to actually modifying each of the operations on pointers (now struct variables)
  // into function calls which operate on structs, and in most cases, return struct. For a deref
  // function call, the returned type is the pointer type. For all other calls, the returned type
  // would be struct type.
  // FIXME: What about address of (&) operator?


  derefTypeTracking dtt;
  dtt.traverseInputFiles(project);
  InstrumentNodes(project);

  ArithCheck::NodesToInstrument.clear();

  typeTracking tt;
  tt.traverseInputFiles(project);
  //InstrumentNodes(project);


  // Commented this out at 5PM Sep 23 2011 ---
  //InstrumentNodes(project);
}

void ArithCheck::YetAnotherHackyPtrCheck() {

  // Get the top level project
  SgProject* project = CheckBase::CBProject;

  // Convert project to node
  SgNode* TopNode = isSgNode(project);
  // Get file_list. These are the files that constitute the input
  // We iterate over these files, and replace pointers with
  // struct variables, and accesses to struct variables
  SgFilePtrList file_list = project->get_fileList();
  SgFilePtrList::iterator iter;
  for(iter = file_list.begin(); iter != file_list.end(); iter++) {


    VariableSymbolMap_t varRemap;

    // Getting current file and scope for it
    SgSourceFile* cur_file = isSgSourceFile(*iter);
    SgGlobal* global_scope = cur_file->get_globalScope();

    // Get the top node for this file. Struct will be inserted at this scope
    // FIXME: May want to do this at the "project" level instead, but not sure yet.
    // The problem with this approach is that there might re-definitions, since each file
    // has its version of struct
    SgNode* fileTop = isSgNode(cur_file);

    // FIXME: **ALWAYS DO THE QUERYSUBTREE BEFORE THE STRUCT DECLARATION. OTHERWISE, THE POINTER IN THE
    // STRUCT WILL ALSO BE REPLACED, AND TRANSFORMED, LIKE EVERY OTHER POINTER
    // Getting variable declarations in the current file
    Rose_STL_Container<SgNode*> varDeclList;
    varDeclList=NodeQuery::querySubTree(fileTop,V_SgVariableDeclaration);


    // Create a struct declaration. Variables on this struct will replace the current pointer
    // variables
    SgClassDeclaration* structdecl = SageBuilder::buildStructDeclaration("IntStruct", global_scope);
    SgType* struct_type = structdecl->get_type();

    // To get this structure into ROSE's symbol table, and access its members, the struct/class
    // needs to be defined here.
    SgClassDefinition* classdef = buildClassDefinition(structdecl);

    // Adding the ptr2obj variable to the struct (struct and class mean the same within ROSE)
    #if 1
    SgVariableDeclaration* ptr2objvar = SageBuilder::buildVariableDeclaration("ptr2obj", SgPointerType::createType(SgTypeUnsignedInt::createType()), NULL, global_scope);
    classdef->append_member(ptr2objvar);
    #endif

    // insert the struct declaration, so that ROSE knows that it exists
    isSgScopeStatement(global_scope)->insertStatementInScope(structdecl, true);


    for(Rose_STL_Container<SgNode*>::iterator lit = varDeclList.begin(); lit != varDeclList.end(); lit++) {
      // Go through each variable decl, and iterate over its variables
      // FIXME: It might be possible to filter out the non-pointer var decls here itself.
      // Haven't figured out a way to do it yet
      SgVariableDeclaration* varDecl = isSgVariableDeclaration(*lit);
      printf("VarDecl: %s = %s\n", isSgNode(varDecl)->sage_class_name(), isSgNode(varDecl)->unparseToString().c_str());
      SgInitializedNamePtrList& varList = varDecl->get_variables();
      for(SgInitializedNamePtrList::iterator sgit = varList.begin(); sgit != varList.end(); ++sgit) {

        // Now, we down to each variable. We get the name for it, and check
        // (i) if its a pointer
        // (ii) if its a pointer of the type that we want
        SgInitializedName* name = *sgit;

        // If its a pointer, get its base type
        SgType* baseType;

        if(name->get_type()->variantT() == V_SgPointerType) {
          printf("Found pointer.\n");
          printf("var: %s\n", name->get_qualified_name().str());

          baseType = resolveTypedefsAndReferencesToBaseTypes(name->get_type());
          baseType = skip_RefsPointersAndTypedefs(name->get_type());
          printf("baseType: %s\n", baseType->class_name().c_str());
        }
        else {
          printf("Not a pointer\n");
          printf("var: %s\n", name->get_qualified_name().str());
          continue;
        }

        // Currently, we only support unsigned int type pointers
        if(baseType->variantT() != V_SgTypeUnsignedInt) {
          printf("Not Unsigned Int\n");
          continue;
        }

        // Now, lets collect a few things about the current variable
        // 1. Initializer -- if it exists
        // 2. Symbol -- to refer to the symbol table
        SgInitializer* init = name->get_initializer();
        printf("var: %s\n", name->get_qualified_name().str());
        SgSymbol* symbol = name->get_symbol_from_symbol_table();
        SgVariableSymbol *varsymbol = isSgVariableSymbol(symbol);

        // Lets start creating the new variable, which will be a struct variable
          std::string newname_string = name->get_qualified_name().getString() + "_structed" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++);
        SgName newName(newname_string);
        printf("created new name: %s\n", newname_string.c_str());
        SgVariableDeclaration* newvar = buildVariableDeclaration(newName, struct_type);
        printf("creted new decl\n");

        // In some cases, inserting the new variable just before the previous one doesn't do.
        // so... we have multiple cases
        printf("varDecl: %s = %s\n", isSgNode(varDecl)->sage_class_name(), isSgNode(varDecl)->unparseToString().c_str());
        SgStatement* prevStmt = getSuitablePrevStmt(varDecl);

        // This one works by just inserting before the current var decl
        // Insert this variable just before the variable it is replacing. This will ensure
        // that it stays in the same scope as the previous one
        //SageInterface::insertStatementBefore(varDecl, newvar);


        SageInterface::insertStatementBefore(prevStmt, newvar);
        printf("inserted new decl\n");

        #if 1
        // Need the newsymbol for the varRemap. Inefficient way of doing it, I think, but
        // it works
        SgInitializedNamePtrList& newvarList = newvar->get_variables();
        assert(newvarList.size() == 1);
        SgInitializedName* newname = *(newvarList.begin());
        SgSymbol* newsymbol = newname->get_symbol_from_symbol_table();
        #endif

        // If the current variable is initialized at the declaration itself (i.e. int* ptr = malloc())
        // we should copy over the initialization and create a new statement to assign to it
        // to the ptr2obj variable in the structure. The ptr2obj is the one which holds, what was being
        // held by the ptr previously.
        // **ASSUMING THAT POINTERS ONLY USE ASSIGN INITIALIZER (vs CONSTRUCTOR INITIALIZER) TO TAKE UP
        // NEW VALUES**
        #if 1
        if(isSgAssignInitializer(init)) {

          // FIXME: The problem with this approach that we would need to call a copy constructor
          // to actually copy over the data from one structure to another.
          // Simply putting *ptr = ptr2 would also limit what we can do at initialization time
          // It might be a good idea to figure a way out of the for loop statement -- by actually
          // putting the variable declaration before the for loop itself
          #if 0
          // Lets try to figure out if we can actually handle various initialization cases like
          // int *ptr = malloc() vs int *ptr = ptr2;
          // First one is an expression, whereas the other one is a pointer
          SgExpression* curr_init_value = isSgAssignInitializer(init)->get_operand();
          if(isSgVarRefExp(curr_init_value)) {
            // This is a pointer on the other side.
          #endif

          // This part works for most cases -- doesn't work for initialization of pointer within for loop
          // initialization statements
          // Sept 2 2011: 12PM
          #if 1
          // Copy over the init_value from the current variable, since we'll be deleting
          // this declaration
          SgExpression* cur_init_value = isSgAssignInitializer(init)->get_operand();
          SgExpression* new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
          printf("copied initialization\n");

          // Create the two sides of the dot expression -- for use like this
          // ptr_structed.ptr2obj = malloc() -- in place of
          // ptr = malloc()
          SgVarRefExp* ptr2objRef = buildVarRefExp(ptr2objvar);
          SgVarRefExp* structptrRef = buildVarRefExp(newvar);


          // buiding the dot expression, then the assign op, and finally
          // two sides of the assign op. Then, insert it just before
          // the current var decl, since we know that the inputs would be
          // available at this point.
          // The order of this dot exp and the var decl above should ensure
          // that the new var is decl, and then initialized
          SgExpression* refexp = buildDotExp(structptrRef, ptr2objRef);

            SgAssignOp* assgop = buildAssignOp(refexp, new_init_value);

          SgExprStatement* newInitStmt = buildExprStatement(isSgExpression(assgop));

          //SageInterface::insertStatementBefore(varDecl, newInitStmt);
          SageInterface::insertStatementBefore(prevStmt, newInitStmt);
          #endif
        }
        #endif

        // Remember to fix all further references to the current variable, with the new one
        // This will be done below, in another loop, which iterates over all the SgVarRefExp
        varRemap.insert(VariableSymbolMap_t::value_type(varsymbol, isSgVariableSymbol(newsymbol)));


        // FIXME: Now, we should remove this variable from the current varDecl. Tricky!
        // In fact, the dead code elimination should pick this up, right?


      }

      // FIXME: We remove the entire variable declaration ***only if*** all the variables
      // have been removed. i.e. if the get_variables is zero!
      // Right now, we are just checking if the dead code elimination will remove the declaration
      // by itself, once it notices we have replaced all references below
      //SageInterface::removeStatement(varDecl);
      // COPIED TILL HERE

    }


    // Lets find the SgVarRefExp, and find those which match the variables replaced above,
    // and change all the references, with access to struct members... i.e. something like
    // *ptr ==>>> *(ptr_structed.ptr2obj)
    // ptr++ ==>>> ptr_structed.ptr2obj++

    // Get all the VarRefExp in the current file (which is the unit that we are dealing
    // with here)
    Rose_STL_Container<SgNode*> varRefList;
    varRefList=NodeQuery::querySubTree(fileTop,V_SgVarRefExp);

    // This part simply checks if the varRemap has the symbol, and if it does, then it means
    // it was replaced with _structed version, so we insert a dot exp in place of varrefexp
    #if 1
    for(Rose_STL_Container<SgNode*>::iterator rit = varRefList.begin(); rit != varRefList.end();
      ++rit) {
      SgVarRefExp* old_ref = isSgVarRefExp(*rit);
      VariableSymbolMap_t::iterator iter = varRemap.find(old_ref->get_symbol());
      if(iter != varRemap.end()) {
        SgVariableSymbol* newsymbol = iter->second;
        SgVarRefExp* structref = buildVarRefExp(newsymbol);
        SgVarRefExp* objref = buildVarRefExp(ptr2objvar);
        SgDotExp* newdotexp = buildDotExp(structref, objref);
        replaceExpression(old_ref, newdotexp);
      }
    }
    #endif
  }

}



void ArithCheck::AnotherHackyPtrCheck() {

    SgProject* project = CheckBase::CBProject;

    SgFilePtrList file_list = project->get_fileList();
  SgFilePtrList::iterator iter;
  for(iter = file_list.begin(); iter!=file_list.end(); iter++) {
    SgSourceFile* cur_file = isSgSourceFile(*iter);
    SgGlobal* global_scope = cur_file->get_globalScope();
    //SageInterface::insertHeader("ptr_hdr.h", PreprocessingInfo::after,false,global_scope);
  }

  SgNode* TopNode = isSgNode(project);

  SgFunctionDeclaration* MainFn = SageInterface::findMain(TopNode);

  SgScopeStatement* scope = MainFn->get_scope();

    SgClassDeclaration* structdecl = SageBuilder::buildStructDeclaration("IntStruct", scope);
    SgType* struct_type = structdecl->get_type();

    SgClassDefinition* classdef = buildClassDefinition(structdecl);

    // SEPT 1, 2011; 10 AM
  #if 1
  SgVariableDeclaration* ptr2objvar = SageBuilder::buildVariableDeclaration("ptr2obj", SgPointerType::createType(SgTypeUnsignedInt::createType()), NULL, scope);
  classdef->append_member(ptr2objvar);
  #endif

  for(iter = file_list.begin(); iter!=file_list.end(); iter++) {
    SgSourceFile* cur_file = isSgSourceFile(*iter);
    SgGlobal* global_scope = cur_file->get_globalScope();
    // works -- inserts before headers
    //prependStatement(structdecl, global_scope);
    // works -- inserts before headers
    //global_scope->prepend_declaration(structdecl);
    // works -- inserts before headers (true -> insertAtTop)
    isSgScopeStatement(global_scope)->insertStatementInScope(structdecl, true);
  }

    SgFunctionDefinition* MainFnDef = MainFn->get_definition();

  SgBasicBlock* FirstBlock = MainFnDef->get_body();

  SgStatementPtrList& Stmts = FirstBlock->get_statements();

  SgStatementPtrList::iterator FirstStmt = Stmts.begin();
  // Equivalent to above, I guess
//  SgStatement* FirstStmt = SageInterface::getFirstStatement(scope);

    Rose_STL_Container<SgNode*> varDeclList;
    varDeclList=NodeQuery::querySubTree(MainFnDef,V_SgVariableDeclaration);

  VariableSymbolMap_t varRemap;

    for(Rose_STL_Container<SgNode*>::iterator lit = varDeclList.begin(); lit != varDeclList.end(); lit++) {
      SgVariableDeclaration* varDecl = isSgVariableDeclaration(*lit);
    printf("VarDecl: %s = %s\n", isSgNode(varDecl)->sage_class_name(), isSgNode(varDecl)->unparseToString().c_str());
    SgInitializedNamePtrList& varList = varDecl->get_variables();
    for(SgInitializedNamePtrList::iterator sgit = varList.begin(); sgit != varList.end(); ++sgit) {
        SgInitializedName* name = *sgit;

      SgInitializer* init = name->get_initializer();
        printf("var: %s\n", name->get_qualified_name().str());
      SgSymbol* symbol = name->get_symbol_from_symbol_table();
      SgVariableSymbol *varsymbol = isSgVariableSymbol(symbol);
      //SgName newName(generateUniqueName(isSgNode(varsymbol), false));


        std::string newname_string = name->get_qualified_name().getString() + "_structed";
      SgName newName(newname_string);
      printf("creted new name\n");
//        SgInitializer* newinit = isSgInitializer(SageInterface::deepCopyNode(isSgNode(init)));


      printf("copied over initialization\n");
      SgVariableDeclaration* newvar = buildVariableDeclaration(newName, struct_type);
      printf("creted new decl\n");
      SageInterface::insertStatementBefore(varDecl, newvar);
      printf("inserted new decl\n");


      SgInitializedNamePtrList& newvarList = newvar->get_variables();
      assert(newvarList.size() == 1);
      SgInitializedName* newname = *(newvarList.begin());
      SgSymbol* newsymbol = newname->get_symbol_from_symbol_table();

        if(!isSgAssignInitializer(init)) {
        OmpSupport::replaceVariableReferences(TopNode, varsymbol, isSgVariableSymbol(newsymbol));
        printf("replaced references\n");
        continue;
        }

        SgExpression* actual_init_value = isSgAssignInitializer(init)->get_operand();
        SgExpression* copied_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(actual_init_value)));

        // SEPT 1, 2011; 10 AM
        #if 1
        SgVarRefExp* ptr2objRef = buildVarRefExp(ptr2objvar);

      SgVarRefExp* structptrRef = buildVarRefExp(newvar);

      SgExpression* refexp = buildDotExp(structptrRef, ptr2objRef);

        SgAssignOp* assgop = buildAssignOp(refexp, copied_init_value);

      SgExprStatement* newInitStmt = buildExprStatement(isSgExpression(assgop));

      SageInterface::insertStatementBefore(varDecl, newInitStmt);
        #endif

      varRemap.insert(VariableSymbolMap_t::value_type(varsymbol, isSgVariableSymbol(newsymbol)));

      //OmpSupport::replaceVariableReferences(TopNode, varsymbol, isSgVariableSymbol(newsymbol));
      //printf("replaced references\n");

    }
    SageInterface::removeStatement(varDecl);
    #if 0
    SgVariableDefinition* varDef = varDecl->get_definition();
    printf("got def\n");
    SgName varName = varDef->get_name();
    printf("got name\n");
    SgVariableSymbol* symbol = SageInterface::lookupVariableSymbolInParentScopes(varName, scope);
    printf("got symbol\n");

    SgName newName(generateUniqueName(isSgNode(varDecl), false));
    printf("creted new name\n");
    SgVariableDeclaration* newvar = buildVariableDeclaration(newName, struct_type);
    printf("creted new decl\n");
    SageInterface::insertStatementBefore(*(MainFnDef->get_body()->get_statements().begin()), newvar);
    printf("inserted new decl\n");
    SgVariableDefinition* newvarDef = newvar->get_definition();
    printf("got new def\n");
    SgVariableSymbol* newsymbol = SageInterface::lookupVariableSymbolInParentScopes(newName, scope);
    printf("got new symbol\n");

    OmpSupport::replaceVariableReferences(TopNode, symbol, newsymbol);
    printf("replaced references\n");
    #endif
    #if 0
    SgInitializedNamePtrList& varNames = varDecl->get_variables();
    for(SgInitializedNamePtrList::iterator sit = varNames.begin(); sit != varNames.end(); sit++) {
        SgInitializedName* name = *sit;
      SgVariableSymbol* symbol = SageInterface::lookupVariableSymbolInParentScopes(name,
    #endif
    //setBaseTypeDefiningDeclaration(varDecl, structdecl);
    }

    Rose_STL_Container<SgNode*> varRefList;
    varRefList=NodeQuery::querySubTree(MainFnDef,V_SgVarRefExp);

    // SEPT 1, 2011; 10 AM
    #if 1
  for(Rose_STL_Container<SgNode*>::iterator rit = varRefList.begin(); rit != varRefList.end();
    ++rit) {
    SgVarRefExp* old_ref = isSgVarRefExp(*rit);
    VariableSymbolMap_t::iterator iter = varRemap.find(old_ref->get_symbol());
    if(iter != varRemap.end()) {
      SgVariableSymbol* newsymbol = iter->second;
      //SgName newname = newsymbol->get_name();
      //SgVarRefExp* structref = buildVarRefExp(newname, scope);
      SgVarRefExp* structref = buildVarRefExp(newsymbol);
      SgVarRefExp* objref = buildVarRefExp(ptr2objvar);
      SgDotExp* newdotexp = buildDotExp(structref, objref);
      replaceExpression(old_ref, newdotexp);
    }
  }
  #endif


}



void ArithCheck::hackyPtrCheck() {

    SgProject* project = CheckBase::CBProject;

    SgFilePtrList file_list = project->get_fileList();
  SgFilePtrList::iterator iter;
  for(iter = file_list.begin(); iter!=file_list.end(); iter++) {
    SgSourceFile* cur_file = isSgSourceFile(*iter);
    SgGlobal* global_scope = cur_file->get_globalScope();
    SageInterface::insertHeader("ptr_hdr.h", PreprocessingInfo::after,false,global_scope);
  }

  SgNode* TopNode = isSgNode(project);

  SgFunctionDeclaration* MainFn = SageInterface::findMain(TopNode);

  SgScopeStatement* scope = MainFn->get_scope();

    SgClassDeclaration* structdecl = SageBuilder::buildStructDeclaration("IntStruct", scope);
    SgType* struct_type = structdecl->get_type();

  // Declare two variables
//  SgVariableDeclaration* varS1 = buildVariableDeclaration("S1", struct_type);
//  SgVariableDeclaration* varS2 = buildVariableDeclaration("S2", struct_type);

    SgFunctionDefinition* MainFnDef = MainFn->get_definition();

  SgBasicBlock* FirstBlock = MainFnDef->get_body();

  SgStatementPtrList& Stmts = FirstBlock->get_statements();

  SgStatementPtrList::iterator FirstStmt = Stmts.begin();
  // Equivalent to above, I guess
//  SgStatement* FirstStmt = SageInterface::getFirstStatement(scope);

//  SageInterface::insertStatementBefore(*FirstStmt, varS1);
//  SageInterface::insertStatementBefore(*FirstStmt, varS2);

    Rose_STL_Container<SgNode*> varDeclList;
    varDeclList=NodeQuery::querySubTree(MainFnDef,V_SgVariableDeclaration);

    for(Rose_STL_Container<SgNode*>::iterator lit = varDeclList.begin(); lit != varDeclList.end(); lit++) {
      SgVariableDeclaration* varDecl = isSgVariableDeclaration(*lit);
    printf("VarDecl: %s = %s\n", isSgNode(varDecl)->sage_class_name(), isSgNode(varDecl)->unparseToString().c_str());
    SgInitializedNamePtrList& varList = varDecl->get_variables();
    for(SgInitializedNamePtrList::iterator sgit = varList.begin(); sgit != varList.end(); ++sgit) {
        SgInitializedName* name = *sgit;
        printf("var: %s\n", name->get_qualified_name().str());
        SgSymbol* symbol = name->get_symbol_from_symbol_table();
      SgVariableSymbol *varsymbol = isSgVariableSymbol(symbol);
        //SgName newName(generateUniqueName(isSgNode(varsymbol), false));
      std::string newname_string = name->get_qualified_name().getString() + "_structed";
        SgName newName(newname_string);
        printf("creted new name\n");
        SgVariableDeclaration* newvar = buildVariableDeclaration(newName, struct_type);
        printf("creted new decl\n");
        SageInterface::insertStatementBefore(*(MainFnDef->get_body()->get_statements().begin()), newvar);
        printf("inserted new decl\n");
        SgInitializedNamePtrList& newvarList = newvar->get_variables();
      assert(newvarList.size() == 1);
      SgInitializedName* newname = *(newvarList.begin());
      SgSymbol* newsymbol = newname->get_symbol_from_symbol_table();

        OmpSupport::replaceVariableReferences(TopNode, varsymbol, isSgVariableSymbol(newsymbol));
        printf("replaced references\n");

    }
    SageInterface::removeStatement(varDecl);
    #if 0
    SgVariableDefinition* varDef = varDecl->get_definition();
    printf("got def\n");
    SgName varName = varDef->get_name();
    printf("got name\n");
    SgVariableSymbol* symbol = SageInterface::lookupVariableSymbolInParentScopes(varName, scope);
    printf("got symbol\n");

    SgName newName(generateUniqueName(isSgNode(varDecl), false));
    printf("creted new name\n");
    SgVariableDeclaration* newvar = buildVariableDeclaration(newName, struct_type);
    printf("creted new decl\n");
    SageInterface::insertStatementBefore(*(MainFnDef->get_body()->get_statements().begin()), newvar);
    printf("inserted new decl\n");
    SgVariableDefinition* newvarDef = newvar->get_definition();
    printf("got new def\n");
    SgVariableSymbol* newsymbol = SageInterface::lookupVariableSymbolInParentScopes(newName, scope);
    printf("got new symbol\n");

    OmpSupport::replaceVariableReferences(TopNode, symbol, newsymbol);
    printf("replaced references\n");
    #endif
    #if 0
    SgInitializedNamePtrList& varNames = varDecl->get_variables();
    for(SgInitializedNamePtrList::iterator sit = varNames.begin(); sit != varNames.end(); sit++) {
        SgInitializedName* name = *sit;
      SgVariableSymbol* symbol = SageInterface::lookupVariableSymbolInParentScopes(name,
    #endif
    //setBaseTypeDefiningDeclaration(varDecl, structdecl);
    }

    Rose_STL_Container<SgNode*> varRefList;
    varRefList=NodeQuery::querySubTree(MainFnDef,V_SgVarRefExp);


}

#if 0
void ArithCheck::insertTimingSupport() {

    //hackyPtrCheck();
  //AnotherHackyPtrCheck();
  //YetAnotherHackyPtrCheck();
  //HackyPtrCheck4();

    SgProject* project = CheckBase::CBProject;

  SgNode* TopNode = isSgNode(project);

  SgFunctionDeclaration* MainFn = SageInterface::findMain(TopNode);

  SgScopeStatement* scope = MainFn->get_scope();

  SgFunctionDefinition* MainFnDef = MainFn->get_definition();

  SgBasicBlock* FirstBlock = MainFnDef->get_body();

  SgStatementPtrList& Stmts = FirstBlock->get_statements();

  SgName s_name ("StartClock");
  SgExprListExp* parameter_list = SageBuilder::buildExprListExp();

  SgExprStatement* NewFunction = SageBuilder::buildFunctionCallStmt(s_name,
                          SgTypeVoid::createType(),
                          parameter_list,
                          scope);



  SgStatementPtrList::iterator FirstStmt = Stmts.begin();
  // Equivalent to above, I guess
//  SgStatement* FirstStmt = SageInterface::getFirstStatement(scope);

  SageInterface::insertStatementBefore(*FirstStmt,
                    NewFunction);



  #if 1
  SgName s_name2 ("EndClock");
  SgExprListExp* parameter_list2 = SageBuilder::buildExprListExp();

  SgExprStatement* NewFunction2 = SageBuilder::buildFunctionCallStmt(s_name2,
                          SgTypeVoid::createType(),
                          parameter_list2,
                          scope);



  //SgStatementPtrList::iterator sit2 = Stmts.begin();
  //SgStatement* LastStatement = SageInterface::getLastStatement(scope);
  // FIXME: This is a dirty hack which uses the fact that the StatementPtrList
  // is an ROSE_STL_Container, which is a standard STL vector
  //SgStatement* LastStmt = Stmts[Stmts.size() - 1];
  SgStatement* LastStmt = Stmts.back();

  SageInterface::insertStatementBefore(LastStmt,
                    NewFunction2);



  #endif
}
#endif

SgType* ArithCheck::getNewVarType(SgType* oldvarType) {

  SgType* newvarType = NULL;

  if(isSgPointerType(oldvarType)) {
    // We have found a pointer member variable. Lets create a structed version of this
    // in the newly created class declaration.
    // FIXME: Also record that this variable's structed version is the newly created variable


    // FIXME: Create corresponding class/VoidStruct objects/pointers -- not VoidStructs all
    // the way.
    #if 0
    SgType* newvarType = getStructType(SgPointerType::createType(SgTypeVoid::createType()));
    #endif

    // Find the base type of the pointer, and create a structed pointer variable
    // for a class object pointer, or a void struct pointer variable for PODs
    SgType* varType = skip_RefsPointersAndTypedefs(oldvarType);
    if(isSgClassType(varType)) {
      // Pointer to an object. Find the struct version of the class
      std::string orig_class_name = isSgClassType(varType)->get_name().getString();
      printf("orig_class_name: %s\n", orig_class_name.c_str());
      StringClassMap_t::iterator iter = ArithCheck::TransClassDecls.find(orig_class_name);
      ROSE_ASSERT(iter != ArithCheck::TransClassDecls.end());

      // Associated struct version of the class is
      SgClassDeclaration* classdecl = iter->second;


      // Pointer to the structed version of the object
      newvarType = SgPointerType::createType(classdecl->get_type());

    }
    else {
      // Must be a pointer of POD type. So, lets create a pointer version to VoidStruct
      newvarType = SgPointerType::createType(getStructType(SgPointerType::createType(SgTypeVoid::createType())));
    }
  }
  else if(isSgClassType(oldvarType)) {
    // An object of class type
    std::string orig_class_name = isSgClassType(oldvarType)->get_name().getString();
    printf("orig_class_name: %s\n", orig_class_name.c_str());
    StringClassMap_t::iterator iter = ArithCheck::TransClassDecls.find(orig_class_name);

    ROSE_ASSERT(iter != ArithCheck::TransClassDecls.end());

    // Associated struct version of the class is
    SgClassDeclaration* classdecl = iter->second;

    // Pointer to the structed version of the object
    newvarType = classdecl->get_type();
  }

  return newvarType;
}

void ArithCheck::handleClassDecl(SgClassDeclaration* decl) {

  printf("handleClassDecl - begin\n");
  // Now, we need to create another class which contains the structed versions
  // of the pointer members of this class
  // Then, we record the mapping from the previous class decl to the new structed
  // version of the same, so that we use the structed version to track the pointer
  // members


  // 1. Lets create a new SgClassDeclaration
  std::string newname_string = decl->get_name().getString() + "_structed";

  // Asserting that the class is not nested. Just a simple way to
  // get scope. Not a necessary condition at all.
  // classes within functions, or within other classes, require more work
  #if 0
  ROSE_ASSERT(isSgGlobal(isSgNode(decl)->get_parent()));
  SgScopeStatement* global_scope = isSgScopeStatement(isSgGlobal(isSgNode(decl)->get_parent()));
  #endif
  SgScopeStatement* scope = isSgStatement(decl)->get_scope();

  // Could change buildDefiningClassDeclaration to buildStructDeclaration to get a struct instead of class
  // Left it at class since I am unsure of struct inheritances -- not an issue for now.
  //SgClassDeclaration* newdecl = SageBuilder::buildDefiningClassDeclaration(newname_string, global_scope);
  SgClassDeclaration* newdecl = SageBuilder::buildDefiningClassDeclaration(newname_string, scope);
  SgClassDefinition*  newdef = buildClassDefinition(newdecl);

  ArithCheck::TransClassDecls.insert(StringClassMap_t::value_type(decl->get_name().getString(), newdecl));

  SgClassDefinition* def = decl->get_definition();
  ROSE_ASSERT(def);

  SgDeclarationStatementPtrList& members = def->get_members();

  // FIXME: If a class contains an object of another class, also handle that case -- create a corresponding
  // struct version of that object

  for(SgDeclarationStatementPtrList::iterator iter = members.begin(); iter != members.end(); iter++) {

    SgDeclarationStatement* stmt = *iter;

    if(SgVariableDeclaration* vardecl = isSgVariableDeclaration(stmt)) {
      SgInitializedNamePtrList& names = vardecl->get_variables();
      for(SgInitializedNamePtrList::iterator iter2 = names.begin(); iter2 != names.end(); iter2++) {

        SgInitializedName* initname = *iter2;


        SgType* newvarType = getNewVarType(initname->get_type());
        // Must be a variable of POD type
        if(newvarType == NULL) {
          continue;
        }

        std::string newvar_name = initname->get_name().getString() + "_structed";

        SgInitializer* initializer = initname->get_initializer();
        // Initializer has to be NULL -- we are within a class definition here
        ROSE_ASSERT(initializer == NULL);

        SgVariableDeclaration* newvar = SageBuilder::buildVariableDeclaration(newvar_name, newvarType, initializer, scope);

        newdef->append_member(newvar);

        #if 0
        if(isSgPointerType(initname->get_type())) {
          printf("Found pointer variable: ");
          printf("%s\n", initname->get_name().getString().c_str());

          // We have found a pointer member variable. Lets create a structed version of this
          // in the newly created class declaration.
          // FIXME: Also record that this variable's structed version is the newly created variable


          // FIXME: Create corresponding class/VoidStruct objects/pointers -- not VoidStructs all
          // the way.
          #if 0
          SgType* newvarType = getStructType(SgPointerType::createType(SgTypeVoid::createType()));
          #endif

          // Find the base type of the pointer, and create a structed pointer variable
          // for a class object pointer, or a void struct pointer variable for PODs
          SgType* varType = skip_RefsPointersAndTypedefs(initname->get_type());

          SgType* newvarType;
          if(isSgClassType(varType)) {
            // Pointer to an object. Find the struct version of the class
            std::string orig_class_name = isSgClassType(varType)->get_name().getString();
            printf("orig_class_name: %s\n", orig_class_name.c_str());

            StringClassMap_t::iterator iter = ArithCheck::TransClassDecls.find(orig_class_name);

            ROSE_ASSERT(iter != ArithCheck::TransClassDecls.end());

            // Associated struct version of the class is
            SgClassDeclaration* classdecl = iter->second;


            // Pointer to the structed version of the object
            newvarType = SgPointerType::createType(classdecl->get_type());

          }
          else {
            // Must be a pointer of POD type. So, lets create a pointer version to VoidStruct
            newvarType = SgPointerType::createType(getStructType(SgPointerType::createType(SgTypeVoid::createType())));
          }

          std::string newvar_name = initname->get_name().getString() + "_structed";

          SgInitializer* initializer = initname->get_initializer();
          // Initializer has to be NULL -- we are within a class definition here
          ROSE_ASSERT(initializer == NULL);

          SgVariableDeclaration* newvar = SageBuilder::buildVariableDeclaration(newvar_name, newvarType, initializer, scope);



          newdef->append_member(newvar);

        }
        else if(isSgClassType(initname->get_type())) {
          // An object of class type
          std::string orig_class_name = isSgClassType(initname->get_type())->get_name().getString();
          printf("orig_class_name: %s\n", orig_class_name.c_str());

          StringClassMap_t::iterator iter = ArithCheck::TransClassDecls.find(orig_class_name);

          ROSE_ASSERT(iter != ArithCheck::TransClassDecls.end());

          // Associated struct version of the class is
          SgClassDeclaration* classdecl = iter->second;


          // Pointer to the structed version of the object
          SgType* newvarType = classdecl->get_type();

          std::string newvar_name = initname->get_name().getString() + "_structed";

          SgInitializer* initializer = initname->get_initializer();
          // Initializer has to be NULL -- we are within a class definition here
          ROSE_ASSERT(initializer == NULL);

          SgVariableDeclaration* newvar = SageBuilder::buildVariableDeclaration(newvar_name, newvarType, initializer, scope);

          newdef->append_member(newvar);


        }
        #endif
      }
    }
  }

  // Need to get to copy over the inheritances as well
  SgBaseClassPtrList& inheritances = def->get_inheritances();

  for(SgBaseClassPtrList::iterator iter = inheritances.begin(); iter != inheritances.end(); iter++) {

//SgClassDeclaration* inh_decl = isSgClassDeclaration(*iter);

    SgClassDeclaration* inh_decl = (isSgBaseClass(*iter))->get_base_class();

    ROSE_ASSERT(inh_decl);

    StringClassMap_t::iterator iter2 = ArithCheck::TransClassDecls.find(inh_decl->get_name().getString());
    ROSE_ASSERT(iter2 != ArithCheck::TransClassDecls.end());

    SgClassDeclaration* new_inh_decl = iter2->second;

    // Probably need to create a base class out of the
    SgBaseClass* new_base_class = new SgBaseClass(new_inh_decl);

    newdef->append_inheritance(new_base_class);

  //  newdef->append_inheritance
  }


  // insert the struct declaration, so that ROSE knows that it exists
  // This one puts it right at the top of the file... which may not be correct
  // when going in the reverse order of decls... since the last decl comes up
  // on top
  //global_scope->insertStatementInScope(newdecl, true);

  SageInterface::insertStatementBefore(isSgStatement(decl), isSgStatement(newdecl));


  // FIXME: Add a mapping from this new class decl, to the old one, so that we know which type of variable
  // to create to track the original class' objects

  printf("handleClassDecl - end\n");
  #if 0

    // Getting current file and scope for it
    SgSourceFile* cur_file = isSgSourceFile(*iter);
    SgGlobal* global_scope = cur_file->get_globalScope();

    // Get the top node for this file. Struct will be inserted at this scope
    // FIXME: May want to do this at the "project" level instead, but not sure yet.
    // The problem with this approach is that there might re-definitions, since each file
    // has its version of struct
    SgNode* fileTop = isSgNode(cur_file);

    // Create a struct declaration. Variables on this struct will replace the current pointer
    // variables
    // STOPPED HERE

    for(unsigned int index = 0; index < STRUCT_ARRAY; index++) {

      SgClassDeclaration* structdecl = SageBuilder::buildStructDeclaration(Structs[index], global_scope);
      SgType* struct_type = structdecl->get_type();

      ArithCheck::created_struct_type = struct_type;

      // To get this structure into ROSE's symbol table, and access its members, the struct/class
      // needs to be defined here.
      SgClassDefinition* classdef = buildClassDefinition(structdecl);

      // Adding the ptr2obj variable to the struct (struct and class mean the same within ROSE)
      // struct IntStruct {
      //  unsigned int* ptr2obj;
      //  unsigned int* L;
      //  unsigned int* H;
      // };

      #if 1
      SgType* ptr2objvarType = SgPointerType::createType(Types[index]);
      SgVariableDeclaration* ptr2objvar = SageBuilder::buildVariableDeclaration("ptr2obj", ptr2objvarType , NULL, global_scope);
      classdef->append_member(ptr2objvar);
      SgVariableDeclaration* lowervar = SageBuilder::buildVariableDeclaration("L", ptr2objvarType, NULL, global_scope);
      classdef->append_member(lowervar);
      SgVariableDeclaration* uppervar = SageBuilder::buildVariableDeclaration("H", ptr2objvarType, NULL, global_scope);
      classdef->append_member(uppervar);
      #endif
      // FIXME: This needs to be done at the file level -- i.e. There has to be another level of indirection
      // so that we do this at the file, or -- we could do the traversal and instrumentation on one file
      // after another -- this might be better...
      ArithCheck::UnderlyingType.insert(TypeMap_t::value_type(struct_type, ptr2objvarType));
      ArithCheck::RelevantStructType.insert(TypeMap_t::value_type(ptr2objvarType, struct_type));

      // insert the struct declaration, so that ROSE knows that it exists
      isSgScopeStatement(global_scope)->insertStatementInScope(structdecl, true);
    }
  #endif

}

void ArithCheck::checkType(SgType* type) {

  printf("checkType\n");
  printf("type: \n");
  printNode(type);

  SgClassType *cls_type = isSgClassType (type);
  ROSE_ASSERT(cls_type != NULL);

  printf("cls_type: \n");
  printNode(cls_type);

    SgClassDeclaration *cls_decl = isSgClassDeclaration (cls_type->get_declaration());
    ROSE_ASSERT(cls_decl);

  printf("cls_decl:\n");
  printNode(cls_decl);
    ROSE_ASSERT(cls_decl->get_firstNondefiningDeclaration()!= NULL);

  printf("First Defining decl: \n");
  printNode(isSgClassDeclaration(cls_decl->get_firstNondefiningDeclaration()));

    ROSE_ASSERT(isSgClassDeclaration(cls_decl->get_firstNondefiningDeclaration()) == cls_decl);
}

SgType* ArithCheck::getArgStructType(SgType* varType, SgType* newvarType, SgScopeStatement* scope) {

  printf("getArgStructType\n");
  printf("varType: %s, newvarType: %s\n", varType->class_name().c_str(), newvarType->class_name().c_str());



  SgType* mapType;

  if(isSgPointerType(varType)) {
    SgType* varBaseType = skip_RefsPointersAndTypedefs(varType);
    if(isSgClassType(varBaseType)) {
      // Pointer to an object - keep the original one
      mapType = varType;
    }
    else {
      // Pointer to a POD - use the void struct
      mapType = SgPointerType::createType(SgTypeVoid::createType());
    }
  }
  else if (isSgClassType(varType)) {
    // Class object
    mapType = varType;
  }
  else {
    ROSE_ASSERT(0);
  }

  #if 0
  if(isSgClassType(varBaseType)) {
    mapType = varBaseType;
  }
  else {
    mapType = SgTypeVoid::createType();
  }
  #endif

  printf("mapType: %s\n", mapType->class_name().c_str());
  //TypeMap_t::iterator iter = ArithCheck::RelevantArgStructType.find(varType);
  TypeMap_t::iterator iter = ArithCheck::RelevantArgStructType.find(mapType);

  SgType* retType = NULL;

  if(iter == ArithCheck::RelevantArgStructType.end()) {

    printf("Can't find mapType in RelevantArgStructType\n");

    SgType* objType = NULL;
    SgType* trackerType = newvarType;

//    std::string objname;
    std::string structname;
//    std::string trackername;


    if(isSgPointerType(varType)) {
      SgType* baseType = skip_RefsPointersAndTypedefs(varType);
      if(isSgClassType(baseType)) {
        objType = varType;
        structname = isSgClassType(baseType)->get_name().getString() + "Ptr";
      }
      else {
        //objType = SgPointerType::createType(getStructType(SgPointerType::createType(SgTypeVoid::createType())));
        objType = SgPointerType::createType(SgTypeVoid::createType());
        structname = "VoidPtr";
      }
    }
    else if(isSgClassType(varType)) {
      objType = varType;
      structname = isSgClassType(varType)->get_name().getString();
    }
    else {
      ROSE_ASSERT(0);
    }

    structname = structname + "_Struct";
    printf("structname: %s\n", structname.c_str());

    SgType* struct_type;

    SgProject* project = CheckBase::CBProject;
    SgNode* TopNode = isSgNode(project);

    SgFilePtrList file_list = project->get_fileList();
    SgFilePtrList::iterator iter;

    for(iter = file_list.begin(); iter != file_list.end(); iter++) {

      // Getting current file and scope for it
      SgSourceFile* cur_file = isSgSourceFile(*iter);
      SgGlobal* global_scope = cur_file->get_globalScope();


      //SgClassDeclaration* structdecl = SageBuilder::buildStructDeclaration(structname, scope);
      SgClassDeclaration* structdecl = SageBuilder::buildStructDeclaration(structname, global_scope);
      struct_type = structdecl->get_type();
      SgClassDefinition* classdef = buildClassDefinition(structdecl);

      //SgVariableDeclaration* objvar = SageBuilder::buildVariableDeclaration("obj", objType, NULL, scope);
      SgVariableDeclaration* objvar = SageBuilder::buildVariableDeclaration("obj", objType, NULL, global_scope);
      classdef->append_member(objvar);
      //SgVariableDeclaration* trackervar = SageBuilder::buildVariableDeclaration("tracker", trackerType, NULL, scope);
      SgVariableDeclaration* trackervar = SageBuilder::buildVariableDeclaration("tracker", trackerType, NULL, global_scope);
      classdef->append_member(trackervar);

      printf("Inserting declaration in scope\n");
        // insert the struct declaration, so that ROSE knows that it exists
      //scope->insertStatementInScope(structdecl, false);
      global_scope->insertStatementInScope(structdecl, false);
      //ArithCheck::RelevantArgStructType.insert(TypeMap_t::value_type(varType, struct_type));
      ArithCheck::RelevantArgStructType.insert(TypeMap_t::value_type(mapType, struct_type));
    }

    retType = struct_type;


  }
  else {
    retType = iter->second;
  }
  printf("Done with getArgStructType\n");


  return retType;
}

//void ArithCheck::handleVarDeclInFuncParamList(SgVariableDeclaration* vardecl) {
void ArithCheck::handleInitNameInFuncParamList(SgInitializedName* name) {

  printf("handleVarDeclInFuncParamLists\n");
  // This variable declaration needs to be converted to a std::pair
  // with void pointer/class object and VoidStruct
  // std::pair looks too complicated to create -- should find an alternative

  // Discard those parameters which are not pointer/class object type
  if(!isSgPointerType(name->get_type()) && !isSgClassType(name->get_type())) {
    return;
  }

  //SgGlobal* globalScope = getFirstGlobalScope(CheckBase::CBProject);
  //pushScopeStack(isSgScopeStatement(globalScope));

  // Case 1: object of a class is passed to another function.
  // Create a struct to hold the object and its associated tracking counterpart



  SgNode* parent = isSgNode(name)->get_parent();

  SgFunctionParameterList* oldParamList = isSgFunctionParameterList(name->get_parent());
  SgFunctionDeclaration* fndecl = isSgFunctionDeclaration(isSgNode(oldParamList)->get_parent());

  // Function def is NULL for forward declaration of functions
  // No symbol table change is necessary when there is no definition
  #if 0
  SgFunctionDefinition* def = fndecl->get_definition();
  if(def == NULL) {
    printf("Looks like an external function call. vardecl->def = NULL\n");
    return;
  }
  #endif

  // Adding global scope to ScopeStack -- this will be the
  // default scope for now
  SgScopeStatement* scope = isSgStatement(fndecl)->get_scope();
  #if 0
  SgGlobal* globalScope = getFirstGlobalScope(project);
  pushScopeStack(isSgScopeStatement(globalScope));
  #endif

  // Get the initialized name

  // Get the type of the current vardecl.
  SgType* varType = name->get_type();
  // From that, figure out the type of the new variable
  SgType* newvarType = getNewVarType(varType);

  SgType* argstruct_type = getArgStructType(varType, newvarType, scope);
  ROSE_ASSERT(argstruct_type);

  printf("var: %s\n", name->get_name().str());

  // Lets start creating the new variable, which will be a struct variable

  std::string newname_string;

  if(strcmp(name->get_name().getString().c_str(), "") == 0) {
    newname_string = "";
  }
  else {
    newname_string = name->get_name().getString() + "_structed" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++);
  }

  // FIXME: For now the initializer will be set to NULL always. This
  // behavior needs to be changed to push the original "default" parameter value
  // into a constructor initializer

  SgInitializedName* new_name = buildInitializedName(SgName(newname_string), argstruct_type, NULL);
  ROSE_ASSERT(new_name);

  new_name->set_scope(scope);

  printf("Function Parameter List\n");
  SgInitializedNamePtrList& args = oldParamList->get_args();


  unsigned int index;
  unsigned int orig_size = args.size();
  for(index = 0; index < args.size(); index++) {
    SgInitializedName* curr_name = args[index];
    if(curr_name == name) {
      break;
    }
  }
  ROSE_ASSERT(index != args.size());

  // We remove the contents at index, and place the new_name there.

  SgInitializedNamePtrList::iterator iter;
  iter = args.begin() + index;

  args.insert(iter, new_name);
  isSgNode(new_name)->set_parent(oldParamList);

  ROSE_ASSERT(args[index] == new_name);

  ROSE_ASSERT(args[index+1] == name);

  iter = args.begin() + index + 1;
  args.erase(iter);

  ROSE_ASSERT(args.size() == orig_size);

  // Check if this has a def. If it doesn't, no symbol table work.
  // If it has a def, modify symbol table
  SgFunctionDefinition* def = fndecl->get_definition();
  if(def == NULL) {
    printf("Nondefining Function Decl. No symbol table work\n");
    deepDelete(isSgNode(name));
    return;
  }

  // FIXME: Create two variables in the function to hold the
  // obj and tracker -- if this is a definition

  SgSymbol* symbol = name->get_symbol_from_symbol_table();
  SgVariableSymbol *varsymbol = isSgVariableSymbol(symbol);

  ROSE_ASSERT(symbol);
  ROSE_ASSERT(varsymbol);

  printf("Got scope. Now, symbolTable\n");

  #if 0
  SgSymbolTable* symbolTable = scope->get_symbol_table();

//  ROSE_ASSERT(symbol->get_parent() == symbolTable);

  SgVariableSymbol* newsymbol = new SgVariableSymbol(new_name);
  isSgNode(newsymbol)->set_parent(symbolTable);
  symbolTable->insert(new_name->get_name(), newsymbol);
  #endif

  #if 1
  new_name->set_scope(def);
  SgVariableSymbol* newsymbol = new SgVariableSymbol(new_name);
  def->insert_symbol(new_name->get_name(), newsymbol);
  #if 0
  isSgNode(newsymbol)->set_parent(isSgNode(varsymbol)->get_parent());
  SgSymbolTable* currSymbolTable = isSgSymbolTable(isSgNode(varsymbol)->get_parent());
  currSymbolTable->insert(new_name->get_name(), newsymbol);
  varRemap.insert(VariableSymbolMap_t::value_type(varsymbol, isSgVariableSymbol(newsymbol)));
  #endif
  #endif

  //ROSE_ASSERT(new_name->get_symbol_from_symbol_table() != NULL);

  // Deleting this to avoid a dangling node. Insert the variables
  // before deleting the node
  deepDelete(isSgNode(name));

  //popScopeStack();
  return;

  #if 0
  // STOPPED HERE




  SgName newName(newname_string);
  printf("created new name: %s\n", newname_string.c_str());
  // Before we replace anything, lets check what the initializer is. If it is NULL, we'll replace the *current* variable declaration itself!
  // If the initializer is not NULL, we create a statement for it, and then replace the *current* variable declaration
  SgInitializedName *new_name = NULL;
  SgExpression* new_init_value = NULL;
  SgAssignInitializer* new_init = NULL;

  SgType* struct_type = getStructType(name->get_type());
  if(init != NULL) {
    // There is a valid initializer. Make a new var decl using it
    SgExpression* cur_init_value = isSgAssignInitializer(init)->get_operand();
    //SgExpression* new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
    new_init_value = isSgExpression(SageInterface::deepCopyNode(isSgNode(cur_init_value)));
    printf("copied initialization\n");
    //SgAssignInitializer* new_init = buildAssignInitializer(new_init_value, new_init_value->get_type());
    new_init = buildAssignInitializer(new_init_value, new_init_value->get_type());
    //newvar->reset_initializer(new_init);
    //newvar = buildVariableDeclaration(newName, struct_type, new_init, name->get_declaration()->get_scope());
    new_name = buildInitializedName(newName, struct_type, new_init);
  }
  else {
    new_name = buildInitializedName(newName, struct_type, NULL);
    //newvar = buildVariableDeclaration(newName, struct_type, NULL, name->get_declaration()->get_scope());
  }
  ROSE_ASSERT(new_name != NULL);

  SgScopeStatement* scopestmt = fndecl->get_scope();
  new_name->set_scope(scopestmt);

  printf("Function Parameter List\n");
  SgInitializedNamePtrList& args = oldParamList->get_args();

  #if 0
  ROSE_ASSERT(def != NULL);
  SgScopeStatement* scopestmt = isSgScopeStatement(def);
  #endif

  #if OLD_WORKING_PARAM_LIST
  oldParamList->append_arg(new_name);
  isSgNode(new_name)->set_parent(oldParamList);
  #else
  #if 0
  for(SgInitializedNamePtrList::iterator iter = args.begin(); iter != args.end();
                          iter++) {

    SgInitializedName* curr_param = *iter;
    if(curr_param == name) {
  #endif

  unsigned int index;
  unsigned int orig_size = args.size();
  for(index = 0; index < args.size(); index++) {
    SgInitializedName* curr_name = args[index];
    if(curr_name == name) {
      break;
    }
  }
  ROSE_ASSERT(index != args.size());

  // We remove the contents at index, and place the new_name there.

//  SgInitializedNamePtrList::iterator iter = &args[index];
  SgInitializedNamePtrList::iterator iter;
  iter = args.begin() + index;
//  iter = &args[index];

//  args.insert(index, new_name);
  args.insert(iter, new_name);
  isSgNode(new_name)->set_parent(oldParamList);

  ROSE_ASSERT(args[index] == new_name);

  ROSE_ASSERT(args[index+1] == name);

//  iter = &args[index+1];
  iter = args.begin() + index + 1;
//  args.erase(index+1);
  args.erase(iter);

  ROSE_ASSERT(args.size() == orig_size);



  #endif

  // Check if this has a def. If it doesn't, no symbol table work.
  // If it has a def, modify symbol table
  SgFunctionDefinition* def = fndecl->get_definition();
  if(def == NULL) {
    printf("Nondefining Function Decl. No symbol table work\n");
    #ifndef OLD_WORKING_PARAM_LIST
    deepDelete(isSgNode(name));
    #endif
    return;
  }

  SgSymbol* symbol = name->get_symbol_from_symbol_table();
  SgVariableSymbol *varsymbol = isSgVariableSymbol(symbol);


  printf("Got scope. Now, symbolTable\n");
  SgSymbolTable* symbolTable = scopestmt->get_symbol_table();

  SgVariableSymbol* newsymbol = new SgVariableSymbol(new_name);
  isSgNode(newsymbol)->set_parent(isSgNode(varsymbol)->get_parent());
  SgSymbolTable* currSymbolTable = isSgSymbolTable(isSgNode(varsymbol)->get_parent());
  currSymbolTable->insert(new_name->get_name(), newsymbol);
  varRemap.insert(VariableSymbolMap_t::value_type(varsymbol, isSgVariableSymbol(newsymbol)));

  #ifndef OLD_WORKING_PARAM_LIST
  deepDelete(isSgNode(name));
  #endif
  #endif

  // Case 2: pointer to a class/POD is passed to another function. In this
  // case, we pass the pointer and its associated struct in a pair
}
#if 0
void ArithCheck::getNewInitializer(SgInitializer* init, SgType* newvarType) {

  // handle Initializations -- with new and constructor calls
  // use buildNewExp and buildConstructorInitializer
  if(isAssignInitializer(init)) {

  }
  else if(isConstructorInitializer(init)) {

  }

}
#endif

void ArithCheck::handleVarDeclInFuncDef(SgVariableDeclaration* vardecl) {

  printf("handleVarDeclInFuncDef\n");
  // If it an object of a class, create another object of the structed
  // version of the same class

  SgInitializedNamePtrList& names = vardecl->get_variables();

  ROSE_ASSERT(names.size() == 1);

  SgInitializedName* varname = *names.begin();

  SgType* newvarType = getNewVarType(varname->get_type());

  // Must be a variable of POD type
  if(newvarType == NULL) {
    return;
  }

  std::string name_str = varname->get_name().getString();

  std::string new_name_str = name_str + "_structed";

  SgInitializer* initializer = varname->get_initializer();
//  SgInitializer* newinitializer = getNewInitializer(initializer, newvarType);

  SgVariableDeclaration* new_vardecl = SageBuilder::buildVariableDeclaration(new_name_str,
                    newvarType,
                    NULL,
                    isSgStatement(vardecl)->get_scope());

  SageInterface::insertStatementBefore(vardecl, new_vardecl);

  // FIXME: Record the mapping between both the old variable and the new one to
  // schedule checks


  #if 0
  if(isSgClassType(varname->get_type())) {

    printf("Found object of a class\n");

    std::string name_str = varname->get_name().getString();

    std::string orig_class_name = isSgClassType(varname->get_type())->get_name().getString();
    printf("orig_class_name: %s\n", orig_class_name.c_str());

    StringClassMap_t::iterator iter = ArithCheck::TransClassDecls.find(orig_class_name);

    ROSE_ASSERT(iter != ArithCheck::TransClassDecls.end());

    // Associated struct version of the class is
    SgClassDeclaration* classdecl = iter->second;

    // Now, build a variable declaration using this classdecl

    std::string new_name_str = name_str + "_structed";


    SgVariableDeclaration* new_vardecl = SageBuilder::buildVariableDeclaration(new_name_str,
                                      classdecl->get_type(),
                                      NULL,
                                      isSgStatement(vardecl)->get_scope());

    SageInterface::insertStatementBefore(vardecl, new_vardecl);

    // FIXME: Record the mapping between both the old variable and the new one to
    // schedule checks

  }

  // If its a pointer, associate a VoidStruct variable with it
  if(isSgPointerType(varname->get_type())) {

    printf("Found a pointer variable. Adding VoidStruct\n");

    printf("%s\n", varname->get_name().getString().c_str());

    SgType* newvarType = getStructType(SgPointerType::createType(SgTypeVoid::createType()));
    std::string new_varname = varname->get_name().getString() + "_structed";

    // FIXME: How to handle initializer?
//    SgInitializer* initializer = initname->get_initializer();
//    ROSE_ASSERT(initializer == NULL);
    SgInitializer* initializer = NULL;

    SgVariableDeclaration* new_vardecl = SageBuilder::buildVariableDeclaration(new_varname,
                                      newvarType,
                                      initializer,
                                      isSgStatement(vardecl)->get_scope());

    SageInterface::insertStatementBefore(vardecl, new_vardecl);
  }

  // If its a pointer of an aggregate type, like struct or class,
  // use the obj variable within the VoidStruct to track the variables
  // at the location pointed to by the pointer... i.e. VoidStruct
  // tracks the pointer, the obj pointer, is used to track variables
  // within the aggregate structure
  #endif
}

void ArithCheck::handleVarDecls2(SgVariableDeclaration* vardecl) {

  printf("handleVarDecls2 - begin\n");

  // Figure out if this variable declaration is either a pointer or
  // an object of a class. If its neither, then we don't do anything

  SgInitializedNamePtrList& names = vardecl->get_variables();

  ROSE_ASSERT(names.size() == 1);

  SgInitializedName* varname = *names.begin();

  if(isSgClassType(varname->get_type()) || isSgPointerType(varname->get_type())) {
    printf("Found varname which is either class type or pointer type\n");
  }
  else {
    return;
  }


  if(isSgFunctionParameterList(vardecl)) {
    ROSE_ASSERT(0);
    //handleVarDeclInFuncParamList(vardecl);
  }
  else {
    handleVarDeclInFuncDef(vardecl);
  }

}

void ArithCheck::InstrumentNodes3(SgProject* project) {

  printf("InstrumentNodes3 - begin\n");
  for(NodeContainer::iterator nit = ArithCheck::NodesToInstrument.begin(); nit != ArithCheck::NodesToInstrument.end(); ++nit) {

    SgNode* node = *nit;
    Sg_File_Info* File = isSgNode(node)->get_file_info();
    printf("Current: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());
    printf("File: (%s, %d, %d) %s = %s\n", File->get_filenameString().c_str(),
                      File->get_line(),
                      File->get_col(),
                      isSgNode(node)->sage_class_name(),
                      isSgNode(node)->unparseToString().c_str());
    // NOT CLASS DEFINITIONS -- DEFINING CLASS DECLARATIONS
    // FIXME: Should we look at all class defs, instead of traversal ones?
    // No, I think because we would see a class def before allocating space for it.
    #if 0
    if(isSgClassDefinition(node)) {
      printf("Found class definition\n");
      handleClassDef(isSgClassDefinition(node));
    }
    #endif
    if(isSgClassDeclaration(node)) {
      ROSE_ASSERT(isSgClassDeclaration(node)->get_definition() != NULL);
      handleClassDecl(isSgClassDeclaration(node));
    }

    if(isSgVariableDeclaration(node)) {
      handleVarDecls2(isSgVariableDeclaration(node));
    }

    if(isSgInitializedName(node) && isSgFunctionParameterList(node->get_parent())) {
      // FIXME: Some problem with the symbol tables created for the structs generated
      // on the fly
      //handleInitNameInFuncParamList(isSgInitializedName(node));
    }



  }
  printf("InstrumentNodes3 - end\n");
}

void ArithCheck::createVoidStruct(SgProject* project) {
  // Create many different structs -- including
  // the VoidStruct
  createStructs(project);
}

void ArithCheck::HackyPtrCheck6() {

  printf("HackyPtrCheck6\n");

  // Get the top level project
  SgProject* project = CheckBase::CBProject;

  TopBotTracking TB;
  nodeType inhAttr(UNKNOWN,INH_UNKNOWN);
  TB.traverseInputFiles(project, inhAttr);

  createVoidStruct(project);

  InstrumentNodes3(project);

}

std::string ArithCheck::generateNameForType(SgType* ptr_type) {

  SgType* baseType = skip_RefsPointersAndTypedefs(ptr_type);

  std::string name;

  if(isSgClassType(baseType)) {
    name = "Class_";
  }
  else {
    switch(baseType->variantT()) {
    case V_SgTypeInt: name = "Int_"; break;
    case V_SgTypeLong: name = "Long_"; break;
    case V_SgTypeLongLong: name = "TLongLong_"; break;
    case V_SgTypeFloat: name = "Float_"; break;
    case V_SgTypeDouble: name = "Double_"; break;
    case V_SgTypeChar: name = "Char_"; break;
    case V_SgTypeUnsignedInt: name = "UnsignedInt_"; break;
    case V_SgTypeVoid: name = "Void_"; break;
    default: printf("Unknown Type: %u\n", baseType->variantT()), ROSE_ASSERT(0);
    }

  }

  name = name + "Type" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++);

  return name;
}


SgType* ArithCheck::createStruct(SgType* ptr_type) {

  printf("creating struct of type: ");
  printNode(ptr_type);

  SgName str_name(generateNameForType(ptr_type));

  // Input type has to be pointer type -- obviously
  ROSE_ASSERT(isSgPointerType(ptr_type));
  // Addresses can be stored in unsigned long long
  SgType* addr_type = SgTypeUnsignedLongLong::createType();

  SgFilePtrList file_list = CheckBase::CBProject->get_fileList();
  SgFilePtrList::iterator iter;


  SgType* str_type;

  for(iter = file_list.begin(); iter != file_list.end(); iter++) {

    // Getting current file and scope for it
    SgSourceFile* cur_file = isSgSourceFile(*iter);
    SgGlobal* global_scope = cur_file->get_globalScope();

    // Get the top node for this file. Struct will be inserted at this scope
    // FIXME: May want to do this at the "project" level instead, but not sure yet.
    // The problem with this approach is that there might re-definitions, since each file
    // has its version of struct
    SgNode* fileTop = isSgNode(cur_file);

    SgClassDeclaration* str_decl = SageBuilder::buildStructDeclaration(str_name, global_scope);
//    SgClassDeclaration* str_decl = SageBuilder::buildDefiningClassDeclaration(str_name, global_scope);
    str_type = str_decl->get_type();

    // To get this structure into ROSE's symbol table, and access its members, the struct/class
    // needs to be defined here.
    SgClassDefinition* str_def = buildClassDefinition(str_decl);

    #if 0
    str_decl->set_definition(str_def);

    str_def->set_parent(str_decl);
    #endif

    ROSE_ASSERT(str_decl->get_definition() != NULL);

    // Adding the ptr and addr variables
    // struct str_name {
    //    (ptr_type) ptr;
    //    unsigned long long addr;
    // };

    SgVariableDeclaration* ptr_var = SageBuilder::buildVariableDeclaration("ptr", ptr_type, NULL, global_scope);
//    ArithCheck::VarDeclForName.insert(NameVarMap_t::value_type("ptr", ptr_var));
    str_def->append_member(ptr_var);
    SgVariableDeclaration* addr_var = SageBuilder::buildVariableDeclaration("addr", addr_type, NULL, global_scope);
//    ArithCheck::VarDeclForName.insert(NameVarMap_t::value_type("addr", addr_var));
    str_def->append_member(addr_var);

    // FIXME: This could be done outside of the loop as well.
    // In this mapping into respective structures so that we can look it up later
    SgType* str_type_copy = deepCopyNode(str_type);
    SgType* ptr_type_copy = deepCopyNode(ptr_type);

    //ArithCheck::UnderlyingType.insert(TypeMap_t::value_type(str_type, ptr_type));
    ArithCheck::UnderlyingType.insert(TypeMap_t::value_type(str_type_copy, ptr_type_copy));

    ArithCheck::RelevantStructType.insert(TypeMap_t::value_type(ptr_type, str_type));

    // insert the struct declaration in the current scope
    isSgScopeStatement(global_scope)->insertStatementInScope(str_decl, true);

    printNodeExt(str_decl);
    ROSE_ASSERT(str_decl->get_definition() != NULL);
    printNodeExt(str_def);
  }

  checkType(str_type);

  return str_type;
}


void ArithCheck::createTrackingStruct(SgProject* project) {

  printf("createTrackingStruct\n");

  SgNode* TopNode = isSgNode(project);

  SgFilePtrList file_list = project->get_fileList();
  SgFilePtrList::iterator iter;

  std::string str_name = "VoidStruct";

  SgType* ptr_type = SgPointerType::createType(SgTypeVoid::createType());
  SgType* addr_type = SgTypeUnsignedLongLong::createType();


  for(iter = file_list.begin(); iter != file_list.end(); iter++) {

    // Getting current file and scope for it
    SgSourceFile* cur_file = isSgSourceFile(*iter);
    SgGlobal* global_scope = cur_file->get_globalScope();

    // Get the top node for this file. Struct will be inserted at this scope
    // FIXME: May want to do this at the "project" level instead, but not sure yet.
    // The problem with this approach is that there might re-definitions, since each file
    // has its version of struct
    SgNode* fileTop = isSgNode(cur_file);

    SgClassDeclaration* str_decl = SageBuilder::buildStructDeclaration(str_name, global_scope);
    SgType* str_type = str_decl->get_type();

    // To get this structure into ROSE's symbol table, and access its members, the struct/class
    // needs to be defined here.
    SgClassDefinition* str_def = buildClassDefinition(str_decl);

    // Adding the ptr and addr variables
    // struct VoidStruct {
    //    void* ptr;
    //    unsigned long long addr;
    // };

    SgVariableDeclaration* ptr_var = SageBuilder::buildVariableDeclaration("ptr", ptr_type, NULL, global_scope);
    ArithCheck::VarDeclForName.insert(NameVarMap_t::value_type("ptr", ptr_var));
    str_def->append_member(ptr_var);
    SgVariableDeclaration* addr_var = SageBuilder::buildVariableDeclaration("addr", addr_type, NULL, global_scope);
    ArithCheck::VarDeclForName.insert(NameVarMap_t::value_type("addr", addr_var));
    str_def->append_member(addr_var);


    // In this mapping into respective structures so that we can look it up later
    ArithCheck::UnderlyingType.insert(TypeMap_t::value_type(str_type, ptr_type));
    ArithCheck::RelevantStructType.insert(TypeMap_t::value_type(ptr_type, str_type));



    // insert the struct declaration in the current scope
    isSgScopeStatement(global_scope)->insertStatementInScope(str_decl, true);

    printf("str_decl: %s = %s\n", isSgNode(str_decl)->sage_class_name(), isSgNode(str_decl)->unparseToString().c_str());

  }


}

//SgVariableDeclaration* ArithCheck::createStructVariableFor(SgVariableDeclaration* var_decl) {
SgVariableDeclaration* ArithCheck::createStructVariableFor(SgVariableDeclaration* var_decl, bool array_var) {


  SgInitializedName* var_name = getNameForDecl(var_decl);

  SgScopeStatement* var_scope = var_name->get_scope();

  std::string str_var_name_String;

  if(strcmp(var_name->get_name().getString().c_str(), "") == 0) {
    str_var_name_String = "";
  }
  else {
    str_var_name_String = var_name->get_name().getString() + "_str";
  }

  printf("str_var_name_String: %s\n", str_var_name_String.c_str());

  #if 0
  SgType* str_ptr_type = SgPointerType::createType(SgTypeVoid::createType());

  // Use the VoidStruct. To find that, use a void pointer.
  TypeMap_t::iterator iter = ArithCheck::RelevantStructType.find(str_ptr_type);

  ROSE_ASSERT(iter != ArithCheck::RelevantStructType.end());

  SgType* str_var_type = iter->second;
  #endif

  SgType* var_type;

  if(array_var) {
    // For arrays.. get the base type, and create a pointer out of it
    // since the array variable is a pointer to the type contained in the
    // array itself. So, for example, a variable which represents an array
    // of pointers, is, in itself, a double pointer.
    SgType* temp_type = var_name->get_type();

    SgArrayType* arr_type = isSgArrayType(temp_type);

    SgType* base_type = arr_type->get_base_type();

    // create the struct type necessary to hold the base pointer
    // for this array
    // Before that, we need to change the base_type to its corresponding
    // pointer type
    var_type = SgPointerType::createType(base_type);
  }
  else {
    // For pointers, simply get the type of init name
    var_type = var_name->get_type();
  }

  SgType* str_var_type = getStructType(var_type, true);


  // Lets zero out the initializer for now
  SgVariableDeclaration* str_var_decl = SageBuilder::buildVariableDeclaration(str_var_name_String, str_var_type, NULL, var_scope);

  return str_var_decl;
}

void ArithCheck::handleSymbolTable(SgInitializedName* orig_name, SgInitializedName* str_name) {

  SgScopeStatement* orig_scope = orig_name->get_scope();

  SgSymbol* orig_symbol = orig_name->get_symbol_from_symbol_table();
  SgVariableSymbol *orig_var_symbol = isSgVariableSymbol(orig_symbol);
  printf("Got scope. Now, symbolTable\n");

  SgSymbol* str_symbol = str_name->get_symbol_from_symbol_table();

  if(str_symbol == NULL) {

    SgVariableSymbol* str_var_symbol = new SgVariableSymbol(str_name);
    isSgNode(str_var_symbol)->set_parent(isSgNode(orig_var_symbol)->get_parent());
    SgSymbolTable* currSymbolTable = isSgSymbolTable(isSgNode(orig_var_symbol)->get_parent());
    currSymbolTable->insert(str_name->get_name(), str_var_symbol);

    // Check that this worked
    str_symbol = str_name->get_symbol_from_symbol_table();
    ROSE_ASSERT(str_symbol);
  }


  varRemap.insert(VariableSymbolMap_t::value_type(orig_var_symbol, isSgVariableSymbol(str_symbol)));

  ReverseMap.insert(VariableSymbolMap_t::value_type(isSgVariableSymbol(str_symbol), orig_var_symbol));
}



SgInitializedName* getNameForDecl(SgVariableDeclaration* decl) {

  // get info about original declaration
  SgInitializedNamePtrList& name_list = decl->get_variables();
  ROSE_ASSERT(name_list.size() == 1);
  SgInitializedName* name = *(name_list.begin());

  return name;
}


void ArithCheck::handleSymbolTable(SgVariableDeclaration* orig_decl, SgVariableDeclaration* str_decl) {

  SgInitializedName* orig_name = getNameForDecl(orig_decl);
  SgInitializedName* str_name = getNameForDecl(str_decl);

  handleSymbolTable(orig_name, str_name);
}

SgVariableDeclaration* ArithCheck::getCorrectMemberDecl(SgInitializedName* str_var_name, std::string str_elem) {

  // We can't use the str_elem to figure out which variable to use, since all the structures
  // have internal variables by the same name! So, only the last struct's version of that
  // variable will show up.

//  SgDeclarationStatement* str_decl = str_var_name->get_declaration();

  printf("getCorrectMemberDecl\n");

  printf("str_var_name: \n");
  printNode(str_var_name);

  #if 0
  SgDeclarationStatement* str_decl = str_var_name->get_type()->getAssociatedDeclaration();

  ROSE_ASSERT(isSgClassDeclaration(str_decl));
  SgClassDeclaration* class_decl = isSgClassDeclaration(str_decl);

  printf("class decl\n");
  printNode(class_decl);

  ROSE_ASSERT(class_decl != NULL);

  SgClassDeclaration* class_decl_def = isSgClassDeclaration(class_decl->get_definingDeclaration());

  SgClassDefinition* class_def = class_decl_def->get_definition();

  ROSE_ASSERT(class_def != NULL);

  #endif

  SgClassType* cls_type = isSgClassType(str_var_name->get_type());

  SgClassDeclaration * cls_decl = isSgClassDeclaration (cls_type->get_declaration());
    ROSE_ASSERT (cls_decl);
    ROSE_ASSERT(cls_decl->get_firstNondefiningDeclaration()!= NULL);
    ROSE_ASSERT(isSgClassDeclaration(cls_decl->get_firstNondefiningDeclaration()) == cls_decl);

  SgClassDeclaration* class_decl_def = isSgClassDeclaration(cls_decl->get_definingDeclaration());

  SgClassDefinition* class_def = class_decl_def->get_definition();

  ROSE_ASSERT(class_def != NULL);

  SgDeclarationStatementPtrList& members = class_def->get_members();

  SgDeclarationStatementPtrList::iterator iter = members.begin();

  bool found = false;
  SgVariableDeclaration* ptr_decl = NULL;
  for(; iter != members.end(); ++iter) {

    SgDeclarationStatement* decl_stmt = *iter;
    // This is a struct that we created -- should only have var decls.. right?
    ROSE_ASSERT(isSgVariableDeclaration(decl_stmt));
    SgVariableDeclaration* var_decl = isSgVariableDeclaration(decl_stmt);

    SgInitializedName* var_name = getNameForDecl(var_decl);

    if(strcmp(var_name->get_name().getString().c_str(), str_elem.c_str()) == 0) {
      found = true;
      ptr_decl = var_decl;
      break;
    }
  }

  ROSE_ASSERT(found);

  printf("ptr_decl\n");
  printNode(ptr_decl);

  return ptr_decl;
}

SgDotExp* ArithCheck::createDotExpFor(SgInitializedName* str_var_name, std::string str_elem) {

  #if 0
  // Next, lets use the dot exp to create a reference to the newly created struct var's ptr
  NameVarMap_t::iterator iter2 = ArithCheck::VarDeclForName.find(str_elem);
  ROSE_ASSERT(iter2 != ArithCheck::VarDeclForName.end());

  SgVariableDeclaration* ptr_decl = iter2->second;
  #endif

  printf("create Dot Exp For\n");
  printf("str_var_name: \n");
  printNode(str_var_name);

  SgVariableDeclaration* ptr_decl = getCorrectMemberDecl(str_var_name, str_elem);
  printf("ptr_decl:\n");
  printNode(ptr_decl);

  SgVarRefExp* ptr_ref_exp = SageBuilder::buildVarRefExp(ptr_decl);
  printf("ptr_ref_exp:\n");
  printNode(ptr_ref_exp);

  //SgVarRefExp* str_var_ref_exp = SageBuilder::buildVarRefExp(str_var_decl);
  SgVarRefExp* str_var_ref_exp = SageBuilder::buildVarRefExp(str_var_name, str_var_name->get_scope());

  SgDotExp* dot_exp = SageBuilder::buildDotExp(str_var_ref_exp, ptr_ref_exp);

  printf("ptr_ref_exp: type: %s\n", ptr_ref_exp->get_type()->get_mangled().getString().c_str());

  return dot_exp;
}

SgType* ArithCheck::getVoidPointerType() {
  return SgPointerType::createType(SgTypeVoid::createType());
}

//SgCommaOpExp* ArithCheck::initializeStructWith(SgVariableDeclaration* var_decl, SgVariableDeclaration* str_var_decl) {
//SgCommaOpExp* ArithCheck::initializeStructWith(SgInitializedName* var_name, SgInitializedName* str_var_name) {
SgCommaOpExp* ArithCheck::initializeStructWith(SgInitializedName* var_name, SgInitializedName* str_var_name, bool flip_ptr_init) {
  printf("initializeStructWith -- \n");
  printf("original var -\n");
  printNode(var_name);

  // Lets create a variable reference expression for the pointer var
  SgVarRefExp* var_ref_exp = SageBuilder::buildVarRefExp(var_name, var_name->get_scope());

  // This cast is not required since the type of the ptr in the struct is already the same type
  #if 0
  // Now, for the ptr assignment, cast it to a void pointer (ptr type in the struct)
  SgCastExp* cast_exp = SageBuilder::buildCastExp(var_ref_exp, getVoidPointerType(), SgCastExp::e_reinterpret_cast);
  #endif

  SgDotExp* dot_exp = createDotExpFor(str_var_name, "ptr");

  #if 0
  SgAssignOp* assign_op = SageBuilder::buildAssignOp(dot_exp, cast_exp);
  #endif

  // This assign input_recr = input_str.ptr instead of the default case (else below)
  // where input_str.ptr = input_recr
  SgAssignOp* assign_op;
  if(flip_ptr_init) {
    assign_op = SageBuilder::buildAssignOp(var_ref_exp, dot_exp);
  }
  else {
    assign_op = SageBuilder::buildAssignOp(dot_exp, var_ref_exp);
  }

  printf(" ptr init: %s = %s\n", isSgNode(assign_op)->sage_class_name(),
          isSgNode(assign_op)->unparseToString().c_str());



  // Get variable address
  // Now, address of op on this var ref
  SgAddressOfOp* addr_of_op = createAddressOfOpFor(var_name);


  // This casting is required since the addr in the struct is of unsigned long long type
  // Now, cast it to long long -- this is the type of addr in the VoidStruct
  SgType* str_addr_type = SgTypeUnsignedLongLong::createType();

  SgCastExp* cast_exp2 = SageBuilder::buildCastExp(addr_of_op, str_addr_type, SgCastExp::e_reinterpret_cast);

  SgDotExp* dot_exp2 = createDotExpFor(str_var_name, "addr");

  SgAssignOp* assign_op2 = SageBuilder::buildAssignOp(dot_exp2, cast_exp2);

  printf(" addr init: %s = %s\n", isSgNode(assign_op2)->sage_class_name(),
          isSgNode(assign_op2)->unparseToString().c_str());

  // Create comma exp with both these exprs
  SgCommaOpExp* comma_op = buildCommaOpExp(assign_op, assign_op2);

  return comma_op;

}

SgExpression* ArithCheck::buildOverloadFn(SgName fn_name, SgExpression* lhs, SgExpression* rhs, SgType* retType, SgScopeStatement* scope) {

  SgExprListExp* parameter_list = buildExprListExp(lhs);

  if(rhs != NULL) {
    appendExpression(parameter_list, rhs);
  }

  SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(fn_name,
                                                                retType,
                                                                parameter_list,
                                                                scope);

  createForwardDeclIfNotAvailable(fn_name, retType, parameter_list, scope, CheckBase::CBProject);

  return NewFunction;
}

SgExpression* ArithCheck::buildAssignOverload(SgExpression* lhs, SgExpression* rhs, SgScopeStatement* scope) {

  SgType* retType = lhs->get_type();

  // Need to use the address of lhs - since we are updating it during the assign op.
  ROSE_ASSERT(isSgVarRefExp(lhs));
  SgExpression* lhs_addr = createAddressOfOpFor(isSgVarRefExp(lhs));

  SgExpression* overload = buildOverloadFn("Assign", lhs_addr, rhs, retType, scope);

  return overload;
}

//SgExpression* ArithCheck::updatePointer(SgVariableDeclaration* var_decl, SgVariableDeclaration* str_var_decl) {
SgExpression* ArithCheck::updatePointer(SgInitializedName* var_name, SgInitializedName* str_var_name) {

  // LHS - original pointer ref
  SgVarRefExp* var_ref = buildVarRefExp(var_name, var_name->get_scope());

  // RHS - str.ptr ref
  SgDotExp* dot_exp = createDotExpFor(str_var_name, "ptr");


  #if 0
  // We don't need to cast here since the type of the variable from the dot_exp
  // is correct
  // Cast it to the right type
  SgType* var_type = var_name->get_type();
  SgExpression* cast_exp = buildCastExp(dot_exp, var_type, SgCastExp::e_C_style_cast);
  #endif

  // Do the assignment
  //SgAssignOp* update_op = SageBuilder::buildAssignOp(var_ref, cast_exp);
  SgAssignOp* update_op = SageBuilder::buildAssignOp(var_ref, dot_exp);

  return update_op;

}

SgCommaOpExp* ArithCheck::copyVarInitAndUpdate(SgVariableDeclaration* var_decl,
              SgVariableDeclaration* str_var_decl) {

  SgInitializedName* var_name = getNameForDecl(var_decl);

  SgInitializer* var_initializer = var_name->get_initializer();

  if(var_initializer == NULL) {
    printf("variable not initialized at decl. Nothing to do\n");
    return NULL;
  }

  printf("initializer: %s = %s\n", isSgNode(var_initializer)->sage_class_name(),
                        isSgNode(var_initializer)->unparseToString().c_str());

  // Handle only assign initializers for now.
  if(!isSgAssignInitializer(var_initializer)) {
    printf("Only handling assign initializers for now.\n");
    printf("This is not assign initializer\n");
    ROSE_ASSERT(0);
  }

  SgAssignInitializer* assign_init = isSgAssignInitializer(var_initializer);

  // All the variable references would be replaced by their struct counterparts.
  // At initialization, the lhs will still be struct since its not a variable reference
  // exp, but instead, its an intialized name.
  // So, we copy over the operand of the initializer, which should be of struct type
  // and use assign_overload to do the struct to struct copy
  // Afterwards, we update the original pointer, using the ptr field in the struct var

  SgExpression* init_exp = assign_init->get_operand();
  SgExpression* init_exp_copy = copyExpression(init_exp);

  SgExpression* var_ref_exp = buildVarRefExp(str_var_decl);

  SgExpression* init_op = buildAssignOverload(var_ref_exp, init_exp_copy, var_name->get_scope());

  SageInterface::deepDelete(isSgNode(var_initializer));
  var_name->set_initializer(NULL);

  // Now, to update the original pointer
  SgExpression* update_op = updatePointer(getNameForDecl(var_decl), getNameForDecl(str_var_decl));

  SgCommaOpExp* comma_op = SageBuilder::buildCommaOpExp(init_op, update_op);

  return comma_op;

}

bool ArithCheck::NoInitializer(SgVariableDeclaration* var_decl) {

  SgInitializedName* var_name = getNameForDecl(var_decl);
  if(var_name->get_initializer() == NULL) {
    return true;
  }
  else {
    return false;
  }
}

// Using multiple types of structs seems to be the best way to handle the
// the type and arithmetic problem.

void ArithCheck::handlePointerVars(SgVariableDeclaration* var_decl) {

  SgProject* project = CheckBase::CBProject;

  // 1. Create a tracking struct (VoidStruct) variable to track this pointer
  // 2. Initialize that variable with the location that this pointer points to,
  // and the address of this pointer
  // 3. If this pointer variable is initialized, use the struct version instead
  // in the initialization
  // and create a copy from the struct var.ptr to this pointer after the
  // initialization

  printf("handlePointerVars\n");

  // Checking for initializer:
  if(NoInitializer(var_decl)) {
    // If the variable is not initialized, nothing to do.
    return;
  }

  SgVariableDeclaration* str_var_decl = createStructVariableFor(var_decl);

  SageInterface::insertStatementAfter(var_decl, str_var_decl);

  handleSymbolTable(var_decl, str_var_decl);

  printf(" Created variable decl: %s = %s\n", isSgNode(str_var_decl)->sage_class_name(),
                        isSgNode(str_var_decl)->unparseToString().c_str());

  // Initialize created str variable with original var info
  SgCommaOpExp* init_expr = initializeStructWith(getNameForDecl(var_decl), getNameForDecl(str_var_decl));

  // Now, we do the initialization of the original var_decl, to the
  // str var
  SgCommaOpExp* copy_update_expr = copyVarInitAndUpdate(var_decl, str_var_decl);

  printf("creating comma op by combining init_expr and copy_update\n");

  SgExprStatement* init_update_stmt;

  if(copy_update_expr != NULL) {
    // Combine the comma ops. Create a statement. Insert it after current one.
    SgCommaOpExp* init_update_expr = buildCommaOpExp(init_expr, copy_update_expr);

    init_update_stmt = buildExprStatement(isSgExpression(init_update_expr));
  }
  else {
    init_update_stmt = buildExprStatement(isSgExpression(init_expr));
  }

  #if 1
  SageInterface::insertStatementAfter(str_var_decl, init_update_stmt);

  printf(" Created init_update_stmt: %s = %s\n", isSgNode(init_update_stmt)->sage_class_name(),
                        isSgNode(init_update_stmt)->unparseToString().c_str());
  #endif

}

#if 0
SgVariableDeclaration* ArithCheck::createStructVariableForArrayVar(SgVariableDeclaration* var_decl) {

  SgInitializedName* var_name = getNameForDecl(var_decl);
  // Check that we only ever get array variables here.
  ROSE_ASSERT(isSgArrayType(var_name->get_type()));

  SgType* var_type = var_name->get_type();

  SgArrayType* arr_type = isSgArrayType(var_type);

  SgType* base_type = arr_type->get_base_type();

  // create the struct type necessary to hold the base pointer
  // for this array
  // Before that, we need to change the base_type to its corresponding
  // pointer type
  SgType* base_ptr_type = SgPointerType::createType(base_type);
  SgType* str_var_type = getStructType(base_ptr_type, true);

  SgScopeStatement* str_var_scope = var_name->get_scope();

  std::string str_var_name_String;

  if(strcmp(var_name->get_name().getString().c_str(), "") == 0) {
    str_var_name_String = "";
  }
  else {
    str_var_name_String = var_name->get_name().getString() + "_str";
  }

  printf("str_var_name_String: %s\n", str_var_name_String.c_str());

  // Lets zero out the initializer for now
  SgVariableDeclaration* str_var_decl = SageBuilder::buildVariableDeclaration(str_var_name_String, str_var_type, NULL, str_var_scope);

  return str_var_decl;
}
#endif


SgExpression* ArithCheck::build3ArgOverloadFn(SgName fn_name, SgExpression* arg1, SgExpression* arg2, SgExpression* arg3, SgType* retType, SgScopeStatement* scope) {

  SgExprListExp* parameter_list = buildExprListExp(arg1);

  if(arg2 != NULL) {
    appendExpression(parameter_list, arg2);
  }

  if(arg3 != NULL) {
    appendExpression(parameter_list, arg3);
  }

  SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(fn_name,
                                                                retType,
                                                                parameter_list,
                                                                scope);

  createForwardDeclIfNotAvailable(fn_name, retType, parameter_list, scope, CheckBase::CBProject);

  return NewFunction;
}

SgVariableDeclaration* ArithCheck::pushIndexToLocalVar(SgName arr_name, SgExpression* index_exp, SgScopeStatement* scope) {
  // Move the index_exp into a single statement by itself, and assign it to a local
  // variable.

//  SgType* arr_type = isSgArrayType(array_name->get_type());

  SgType* index_var_type = getArrayIndexType();
  SgExpression* index_var_init = copyExpression(index_exp);
//  SgName index_var_sgname(array_name->get_name().getString() + "_index" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++));
  SgName index_var_sgname(arr_name.getString() + "_index" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++));

  SgVariableDeclaration* index_var_decl = createLocalVariable(index_var_sgname, index_var_type, index_var_init, scope);

  return index_var_decl;
}

SgType* ArithCheck::getArrayIndexType() {
  return SgTypeUnsignedLong::createType();
}

void ArithCheck::handleArrayVars(SgVariableDeclaration* var_decl) {

  SgProject* project = CheckBase::CBProject;

  // This is an array declaration ... which means that
  // the bounds are set by the declaration itself. To find the
  // the bounds, we will use the fields in the ArrayType

  SgInitializedName* var_name = getNameForDecl(var_decl);
  // Check that we only ever get array variables here.
  ROSE_ASSERT(isSgArrayType(var_name->get_type()));

  SgType* var_type = var_name->get_type();
  printf("var_type\n");
  printNode(var_type);

  SgArrayType* arr_type = isSgArrayType(var_type);
  printf("arr_type\n");
  printNode(arr_type);

  SgType* base_type = arr_type->get_base_type();
  //ROSE_ASSERT(!isSgPointerType(base_type));
  printf("base_type\n");
  printNode(base_type);

  SgExpression* index_exp = arr_type->get_index();
  printf("index_exp\n");
  printNode(index_exp);

  // Move the index_exp into a single statement by itself, and assign it to a local
  // variable.
  // That local variable will be used in the variable declaration, and
  // also in the create_entry function.

  SgVariableDeclaration* index_var_decl = pushIndexToLocalVar(var_name->get_name(), index_exp, var_name->get_scope());

  #if 0
  SgExpression* index_var_init = copyExpression(index_exp);
  SgType* index_var_type = base_type;
  SgName index_var_sgname(var_name->get_name().getString() + "_index");

  SgVariableDeclaration* index_var_decl = createLocalVariable(index_var_sgname, index_var_type, index_var_init, var_name->get_scope());
  #endif
  // Insert the local variable decl before the current var_decl
  insertStatementBefore(var_decl, index_var_decl);


  printf("index_var_decl\n");
  printNode(index_var_decl);

  SgVarRefExp* index_var_ref = buildVarRefExp(index_var_decl);

  // Make the switch from index_exp to index_var
  deepDelete(isSgNode(index_exp));
  arr_type->set_index(index_var_ref);
  index_var_ref->set_parent(arr_type);


  // We don't need to create a struct variable to shadow the array... we'll create a struct at each access from the original variable
  // ****************************RETURNING******************************
  return;



  // Now, we create a local variable to shadow the array variable
  //SgVariableDeclaration* str_var_decl = createStructVariableForArrayVar(var_decl);
  SgVariableDeclaration* str_var_decl = createStructVariableFor(var_decl, true);
  // Insert this var_decl after the original decl
  insertStatementAfter(var_decl, str_var_decl);
  handleSymbolTable(var_decl, str_var_decl);

  printf("str_var_decl\n");
  printNode(str_var_decl);

  // Lets initialize the struct
  // No flipping of pointer init -- thats useful in the func param case
  SgCommaOpExp* init_expr = initializeStructWith(getNameForDecl(var_decl), getNameForDecl(str_var_decl));

  // Now, for the interesting part --
  // To actually create an entry -- from the array lower bound and upper bound.
  // fncall will be: create_entry(addr, base, size);
  // addr - is address of the array variable
  // base - reference to array variable
  // size - index_var_ref

  SgName fn_name("create_entry");
  // In fact, we could create a new function which takes the struct
  // and the index, and does the insertion. We are taking a more generic
  // approach here by providing the address, the base and the offset -- like
  // the malloc case
  SgExpression* addr = createDotExpFor(getNameForDecl(str_var_decl), "addr");
  SgExpression* base = createDotExpFor(getNameForDecl(str_var_decl), "ptr");

  // We will be using the base as the lower bound... so, cast it to the addr type
  // C doesn't like unnecessary casts.
  if(base->get_type()->get_mangled() != getAddrType()->get_mangled()) {
    base = castToAddr(base);
  }

  SgExpression* index_ref = copyExpression(index_var_ref);
  SgType* retType = SgTypeVoid::createType();

  SgExpression* create_fn = build3ArgOverloadFn(fn_name, addr, base, index_ref, retType, var_name->get_scope());

  SgExpression* init_create = buildCommaOpExp(init_expr, create_fn);

  SgExprStatement* init_create_stmt = buildExprStatement(init_create);

  insertStatementAfter(str_var_decl, init_create_stmt);

  printf("init_create_stmt\n");
  printNode(init_create_stmt);

}


void ArithCheck::handleVarRefs(SgVarRefExp* var_ref) {
  // FIXME: Instead of looking up the map to use a previously declared struct,
  // create a struct everytime a variable is referenced.
  // Currently, this handles both pointer and array var refs
  printf("handleVarRefs\n");

  SgVariableSymbol* var_symbol = var_ref->get_symbol();
  //SgSymbol* var_symbol = var_ref->get_symbol();
  ROSE_ASSERT(var_symbol != NULL);
  VariableSymbolMap_t::iterator iter = ArithCheck::varRemap.find(var_ref->get_symbol());
  ROSE_ASSERT(iter != ArithCheck::varRemap.end());
  SgVariableSymbol* str_symbol = iter->second;

  ROSE_ASSERT(str_symbol != NULL);
  SgVarRefExp* str_var_ref = buildVarRefExp(isSgVariableSymbol(str_symbol));
  ROSE_ASSERT(str_var_ref != NULL);
  replaceExpression(var_ref, str_var_ref);
  printf("Done\n");
}

SgName ArithCheck::getFunctionName(SgFunctionCallExp* fncall) {

  SgFunctionSymbol* fnsymbol = fncall->getAssociatedFunctionSymbol();
  return fnsymbol->get_name();
}

SgScopeStatement* ArithCheck::getScopeForExp(SgExpression* exp) {
//  SgStatement* stmt = getSurroundingStatement(*isSgNode(exp));
  SgStatement* stmt = getEnclosingStatement(isSgNode(exp));
  ROSE_ASSERT(stmt != NULL);
    SgScopeStatement* scope = stmt->get_scope();
  return scope;
}

void ArithCheck::handleFuncCalls(SgFunctionCallExp* fncall) {

  printf("handleFuncCallExp\n");
  printf("Function: %s\n", fncall->getAssociatedFunctionDeclaration()->get_name().str());

  // Replace malloc calls with malloc_wrap
  if(strcmp(fncall->getAssociatedFunctionDeclaration()->get_name().str(), "malloc") == 0) {
    printf("Handling malloc\n");
    SgStatement* stmt = getSurroundingStatement(*isSgExpression(fncall));
      SgScopeStatement* scope = stmt->get_scope();

    SgExpression* args = fncall->get_args();
    SgExpression* args_copy = copyExpression(args);

    // Return type is VoidStruct
    // The return type for malloc stays as VoidStruct since this is the parallel to returning
    // a void pointer
    // We could be more systematic here, and use the getStructType
    // Since we may not have used void pointers before, we should account
    // for the fact that a new structure might need to be created
    SgType* retType = getStructType(fncall->get_type(), true);
    //SgType* retType = getStructType(SgPointerType::createType(SgTypeVoid::createType()));

    // We use buildOverloadFn here because we are supplying the function malloc_overload.
    // In typically func-calls, the function signature is being changed everywhere, so we
    // would be using the programmer's versions of the functions -- albeit slightly tweaked
    SgExpression* overload = buildOverloadFn("malloc_overload", args_copy, NULL, retType, scope);


    replaceExpression(fncall, overload);

  }
  else {
    printf("Function call returning pointer. Change return type to struct\n");

    ROSE_ASSERT(isSgPointerType(fncall->get_type()));

    // We'll create a new func call with a different type, but everything else
    // stays the same.

    SgExprListExp* parameters = isSgExprListExp(copyExpression(isSgCallExpression(fncall)->get_args()));
    SgScopeStatement* scope = getScopeForExp(fncall);
    SgName fn_name(getFunctionName(fncall));
    // New return type
    // The return type becomes the struct version of the original return type.
    // its possible that a variable of this type hasn't been declared yet, so a struct
    // type may not be available, so we should allow it to create a new struct type
    SgType* retType = getStructType(fncall->get_type(), true);
    //SgType* retType = getStructType(getVoidPointerType());

    SgFunctionCallExp* new_fncall = buildFunctionCallExp(fn_name, retType, parameters, scope);

    replaceExpression(fncall, new_fncall);

  }
}

SgType* ArithCheck::getUnderlyingTypeForStruct(SgType* str_type) {

  TypeMap_t::iterator iter = ArithCheck::UnderlyingType.find(str_type);

  ROSE_ASSERT(iter != ArithCheck::UnderlyingType.end());

  return iter->second;
}


SgExpression* ArithCheck::createStructUsingAddressOf(SgExpression* exp) {

  SgExpression* copy_exp = copyExpression(exp);

  SgExpression* addr_of = castToAddr(createAddressOfOpFor(exp));

  SgType* retType;

  if(isSgArrayType(exp->get_type())) {
    // If its an array type, then we need to use the pointer to the base type
    // struct
    SgType* base_type = (isSgArrayType(exp->get_type()))->get_base_type();
    retType = getStructType(SgPointerType::createType(base_type), true);
  }
  else {
    retType = getStructType(exp->get_type(), true);
  }

  SgScopeStatement* scope = getScopeForExp(exp);

  SgExpression* createfn = buildOverloadFn("create_struct_from_addr", addr_of, NULL, retType, scope);

  return createfn;

}

void ArithCheck::handleDerefExp(SgPointerDerefExp* ptr_deref) {

  printf("handleDerefExp\n");
  SgExpression* oper = isSgUnaryOp(ptr_deref)->get_operand();
  SgExpression* oper_copy = copyExpression(oper);

  // Find scope
  SgScopeStatement* scope = getScopeForExp(ptr_deref);

  // The return type is given by the ReverseMap from struct var
  //SgType* retType = SgPointerType::createType(SgTypeInt::createType());

  // Assert that current operand type is struct type
  ROSE_ASSERT(isValidStructType(oper->get_type()));
  // Now, get the type that we will be returning
  SgType* retType = getUnderlyingTypeForStruct(oper->get_type());

  SgExpression* overload = buildOverloadFn("Deref", oper_copy, NULL, retType, scope);
  printf("overload\n");
  printNode(overload);

  SgExpression* new_deref_exp = buildPointerDerefExp(overload);

//  replaceExpression(oper, overload);
  replaceExpression(ptr_deref, new_deref_exp);
  printf("new_deref_exp\n");
  printNode(new_deref_exp);




  // Now, suppose the deref returns a pointer/array... that needs to be handled...
  // we would need to create a struct for it, on the fly. What we should do
  // is pass the address of the return var of the deref to a create_struct.
  // function. This function takes the address, and create a struct
  // of the appropriate type from it... and return that struct.
  // The crucial thing here is that we are using the address of that variable
  // deref'ed or pntr arr ref'ed, to create a struct.
  // We can't take the pointer value, and address to the create_struct
  // because doing the deref twice might have side effects.

//  if(isQualifyingType(ptr_deref->get_type())) {
  if(isQualifyingType(new_deref_exp->get_type())) {

    printf("Deref returns a qualifying type\n");

//    SgExpression* createfn = createStructUsingAddressOf(ptr_deref);

//    replaceExpression(ptr_deref, createfn);

    SgExpression* createfn = createStructUsingAddressOf(new_deref_exp);

    replaceExpression(new_deref_exp, createfn);

  }



  // FIXME: Until we know how to handle func derefs correctly,
  // we can't fill up this gap
  #if 0
  // Two cases here:
  // 1. Return VoidStruct if the type of node is pointer
  // 2. Return POD if the type of the node is something else

  SgType* expr_type = ptr_deref->get_type();

  SgType* ret_type;

  if(isSgPointerType(expr_type)) {
  #endif


}

void ArithCheck::handleConditionals(SgBinaryOp* bop) {

  printf("handleConditionals\n");

  //std::string op_name(getStringForVariantT(bop->variantT()));

  SgType* retType = SgTypeBool::createType();

  // Conditionals always return bool
  std::string op_name = getStringForOp(isSgNode(bop), retType);

  SgExpression* LHS = bop->get_lhs_operand();
  SgExpression* LHS_Copy = copyExpression(LHS);

  SgExpression* RHS = bop->get_rhs_operand();
  SgExpression* RHS_Copy = copyExpression(RHS);

  if(isSgValueExp(RHS) || isSgValueExp(LHS)) {
    // Both can't be values -- right?
    ROSE_ASSERT(isSgValueExp(LHS) && isSgValueExp(RHS));
    op_name = "_ValueCast";
  }

  SgExpression* overload = buildOverloadFn(SgName(op_name), LHS_Copy, RHS_Copy, retType, getScopeForExp(bop));

  replaceExpression(bop, overload);

}

SgInitializedName* ArithCheck::createStructVariableFor(SgInitializedName* name) {

  std::string new_name_string;

  if(strcmp(name->get_name().getString().c_str(), "") == 0) {
    new_name_string = "";
  }
  else {
    new_name_string = name->get_name().getString() + "_str";
  }

  SgName new_name_sg(new_name_string);
  printf("created new name: %s\n", new_name_string.c_str());

  // FIXME: Assuming no initializer
  SgInitializer* name_init = name->get_initializer();
  ROSE_ASSERT(name_init == NULL);

  #if 0
  // Get the VoidStruct Type
  SgType* new_name_type = getStructType(SgPointerType::createType(SgTypeVoid::createType()));
  #endif

  // create one if necessary
  SgType* new_name_type = getStructType(name->get_type(), true);

  SgInitializedName* new_name = buildInitializedName(new_name_sg, new_name_type, NULL);

  ROSE_ASSERT(new_name != NULL);

  new_name->set_scope(name->get_scope());

  return new_name;
}


SgVariableDeclaration* ArithCheck::createLocalVariable(SgInitializedName* orig) {

  // Create a local variable of the type given by orig
  std::string local_var_name = orig->get_name().getString() + "_recr";

  SgVariableDeclaration* local_var_decl = SageBuilder::buildVariableDeclaration(local_var_name, orig->get_type(), NULL, orig->get_scope());

  return local_var_decl;
}

SgVariableDeclaration* ArithCheck::createLocalVariable(SgName name, SgType* type, SgExpression* init, SgScopeStatement* scope) {


  SgAssignInitializer* assign_init = NULL;
  if(init != NULL) {
    // Create a local variable from the arguments
    assign_init = buildAssignInitializer(init, init->get_type());
  }

  SgVariableDeclaration* local_var_decl = SageBuilder::buildVariableDeclaration(name, type, assign_init, scope);

  return local_var_decl;

}

SgAddressOfOp* ArithCheck::createAddressOfOpFor(SgInitializedName* name) {

  SgVarRefExp* var_ref_exp = buildVarRefExp(name, name->get_scope());

  return createAddressOfOpFor(var_ref_exp);

}

#if 0
SgAddressOfOp* ArithCheck::createAddressOfOpFor(SgVarRefExp* exp) {

  SgAddressOfOp* address_of_op = buildAddressOfOp(exp);

  return address_of_op;
}
#endif

SgAddressOfOp* ArithCheck::createAddressOfOpFor(SgExpression* exp) {

  SgAddressOfOp* address_of_op = buildAddressOfOp(exp);

  return address_of_op;
}




void ArithCheck::createLocalVariableAndUpdateMetadata(SgInitializedName* vs,
                            SgInitializedName* orig,
                            SgFunctionDeclaration* fn_decl) {


  SgVariableDeclaration* local_var_decl = createLocalVariable(orig);

  // Insert this variable at the top of the body
  SgFunctionDefinition* fn_def = fn_decl->get_definition();
  ROSE_ASSERT(fn_def != NULL);
  SgBasicBlock* bb = fn_def->get_body();
  SgStatementPtrList& stmts = bb->get_statements();

  //isSgScopeStatement(fn_decl->get_scope())->insertStatementInScope(local_var_decl, true);
  SageInterface::insertStatementBefore(*(stmts.begin()), local_var_decl);
  printf("Insert local_var_decl\n");


  // Now, insert a function call which creates an entry from this variable's address
  // and uses data from the vs addr
  SgExpression* addressOfOp = createAddressOfOpFor(getNameForDecl(local_var_decl));
  // Lets cast this addressOfOp to unsigned long long
  SgCastExp* cast_exp = buildCastExp(addressOfOp, SgTypeUnsignedLongLong::createType(), SgCastExp::e_reinterpret_cast);

  SgExpression* dot_exp = createDotExpFor(vs, "addr");

  // Could also use the fn def scope
  //SgExpression* overload = buildOverloadFn("create_entry", addressOfOp, dot_exp, SgTypeVoid::createType(), getNameForDecl(local_var_decl)->get_scope());
  SgExpression* overload = buildOverloadFn("create_entry", cast_exp, dot_exp, SgTypeVoid::createType(), getNameForDecl(local_var_decl)->get_scope());

  // We should assign input_recr = input_str.ptr -- not the other way round
  // This tweak makes initializeStructWith act this way.
  bool flip_ptr_init = true;
  // Initialize this local_var with the ptr value in the vs
  SgCommaOpExp* init_op = initializeStructWith(getNameForDecl(local_var_decl), vs, flip_ptr_init);

  // Combine both
  SgCommaOpExp* overload_init = SageBuilder::buildCommaOpExp(overload, init_op);


  // create a statement and insert it here
  SgExprStatement* ov_in = SageBuilder::buildExprStatement(isSgExpression(overload_init));

  SageInterface::insertStatementAfter(local_var_decl, ov_in);



  // Now, update the symbol so that all references to the orig
  // variable are replaced with references to vs
  handleSymbolTable(orig, vs);

}

void ArithCheck::handleFuncDecls(SgFunctionDeclaration* fn_decl) {

  // The problem with this technique is that the var ref exp substitutions
  // in the body happen before we make this change -- since we are doing a bottom up
  // traversal. We should be doing this work, therefore, in the parameter list
  // and then, the varRemap will contain the mapping from old symbol to new symbol
  // We could do the actual insertion in the body after we reach this stage.
  // We could simply stack up the instructions to be inserted in a list.
  // and insert all the statements at once, here.

  // Here, we modify the declaration so that it returns a VoidStruct instead of a pointer
  // and each pointer input is converted to a VoidStruct with a copy to the original pointer
  // and an update to the metadata

  printf("handleFuncDecls\n");

  SgName fn_name = fn_decl->get_name();

  SgScopeStatement* scope = fn_decl->get_scope();
  printf("Got scope\n");

  SgFunctionParameterList* param_list = fn_decl->get_parameterList();
  ROSE_ASSERT(param_list != NULL);

  printf("Got paramList\n");

  // Now, two things
  // 1. Find return type, change if necessary
  // 2. Find pointers in argument list, change if necessary -- DOING THIS PARAMETER WORK IN PARAM_LIST FUNCTION
  // create copy and update instructions in the function body

  SgFunctionDefinition* fndef = fn_decl->get_definition();
  bool defining_decl = (fndef != NULL);


  // Return type is given by getStructType on the current poitner type
  SgFunctionType* fn_type = fn_decl->get_type();
  SgType* ret_type = fn_type->get_return_type();
//  SgType* ptr_type = getVoidPointerType();

  SgType* new_ret_type;
  printf("Return type is pointer type?\n");

  if(isSgPointerType(ret_type)) {
    printf("Yes\n");
    // Since this type may not have been seen before, allow it to create a struct
    new_ret_type = getStructType(ret_type, true);
  }
  else {
    printf("No. Retaining old ret type\n");
    new_ret_type = ret_type;
  }

  // Since the parameter work is done in handleFuncParams already, just copy over the parameter list
  SgFunctionParameterList* new_args = isSgFunctionParameterList(SageInterface::deepCopyNode(isSgNode(param_list)));

  // Keeping decorator list the same
  SgExprListExp* dec_list = fn_decl->get_decoratorList();
  SgExprListExp* new_dec_list = isSgExprListExp(deepCopyNode(isSgNode(dec_list)));

  if(fndef) {
    printf("Defining fn decl\n");
    // This is a defining func decl.
    SgFunctionDeclaration* new_fn_decl = buildDefiningFunctionDeclaration(fn_name,
                                      new_ret_type,
                                      new_args,
                                      scope,
                                      new_dec_list);

    SgFunctionDefinition* new_fndef = isSgFunctionDefinition(deepCopyNode(isSgNode(fndef)));

    new_fn_decl->set_definition(new_fndef);
    isSgNode(new_fndef)->set_parent(new_fn_decl);

    replaceStatement(fn_decl, new_fn_decl);

    // Removed assert to check return type

  }
  else {
    printf("Nondefining fn decl\n");
    // Nondefining fn decl
    SgFunctionDeclaration* new_fn_decl = buildNondefiningFunctionDeclaration(fn_name,
                                      new_ret_type,
                                      new_args,
                                      scope,
                                      new_dec_list);

    replaceStatement(fn_decl, new_fn_decl);

    // Removed assert to check return type
  }

}

void ArithCheck::handleFuncParams(SgFunctionParameterList* param_list) {

  // Change those parameters which are pointers, to VoidStruct.
  // Add patch up code to the body
  printf("handleFuncParams\n");
  // 2. parameter list
  // Instead of using the type list, we are using the initialized name
  // list, since we would need to look up the symbol in case we
  // chnage the arg in a defining declaration
  SgInitializedNamePtrList& args = param_list->get_args();

  SgFunctionDeclaration* fn_decl = isSgFunctionDeclaration(isSgNode(param_list)->get_parent());
  ROSE_ASSERT(fn_decl != NULL);

  SgFunctionParameterList* new_args = SageBuilder::buildFunctionParameterList();
  printf("created empty func params\n");

  SgFunctionDefinition* fndef = fn_decl->get_definition();
  bool defining_decl = (fndef != NULL);


  printf("Traversing parameter list\n");

  for(SgInitializedNamePtrList::iterator iter = args.begin(); iter != args.end(); iter++) {

    // Get the initialize name
    SgInitializedName* arg_name = *iter;

    printf("arg_name: %s = %s\n", isSgNode(arg_name)->sage_class_name(), isSgNode(arg_name)->unparseToString().c_str());

    // Check if this arg is a pointer
    SgType* arg_type = arg_name->get_type();

    printf("pointer type?");
    if(isSgPointerType(arg_type)) {
      printf("Yes\n");


      // Now, we have to replace this arg with a VoidStruct version of it
      SgInitializedName* new_arg_name = createStructVariableFor(arg_name);
      new_args->append_arg(new_arg_name);
      new_arg_name->set_parent(new_args);

      // FIXME: If its not a forward declaration, we would need to make
      // further changes -- like create a local version of the original argument
      // and then copy over the pointer data from VoidStruct and update
      // VoidStruct metadata
      if(defining_decl) {
        printf("Defining decl\n");
//        createLocalVariableAndUpdateMetadata(new_arg_name, arg_name, fn_decl);
        // Replace all uses of the original arg_name with the new_arg_name
        // This creates a symbol for new_arg_name, and creates the necessary
        // mappings
        handleSymbolTable(arg_name, new_arg_name);

        ROSE_ASSERT(new_arg_name->get_symbol_from_symbol_table() != NULL);

        // Things to do: 1. create local variable
        // 2. create entry at address given by local variable.
        // 3. initialize this variable with local variable address
        // FIXME: 4. copy over any initialization from orig variable, and updatePointer afterwards
        // also add new struct variable at the end... since return for the whole expression
        // has to be the new struct variable

        createLocalVariableAndUpdateMetadata(new_arg_name, arg_name, fn_decl);
      }

    }
    else {
      printf("No\n");
      SgInitializedName* new_arg_name = isSgInitializedName(SageInterface::deepCopyNode(isSgNode(arg_name)));
      new_args->append_arg(new_arg_name);
      new_arg_name->set_parent(new_args);
      // Nothing else to do in this case
    }
  }

  SageInterface::deepDelete(isSgNode(param_list));

  new_args->set_parent(isSgNode(fn_decl));

  fn_decl->set_parameterList(new_args);

}

bool ArithCheck::ArithOrAssignOp(SgNode* node) {

  if(ArithOpWithSelfUpdate(node)) {
    return true;
  }

  // These are arith ops which don't change
  // the original variable
  switch(node->variantT()) {
  case V_SgAddOp:
  case V_SgSubtractOp: return true;
  default: return false;
  }
}

// These arith ops change the original variable as well
bool ArithCheck::ArithOpWithSelfUpdate(SgNode* node) {
  switch(node->variantT()) {
  case V_SgPlusPlusOp:
  case V_SgMinusMinusOp:
  case V_SgPlusAssignOp:
  case V_SgMinusAssignOp:
  case V_SgAssignOp: return true;
  default: return false;
  }
}


SgExpression* ArithCheck::buildOverloadFnForOp(SgName fn_name, SgExpression* Op, SgType* retType, SgExpression* extraArg) {

  SgExprListExp* arguments;

  if(SgBinaryOp* bop = isSgBinaryOp(Op)) {

    SgExpression* LHS = bop->get_lhs_operand();
    SgExpression* RHS = bop->get_rhs_operand();

    SgExpression* LHS_Copy = SageInterface::copyExpression(LHS);
    SgExpression* RHS_Copy = SageInterface::copyExpression(RHS);

    arguments = SageBuilder::buildExprListExp(LHS_Copy, RHS_Copy);
  }
  else if(SgUnaryOp* uop = isSgUnaryOp(Op)) {
    SgExpression* operand = uop->get_operand();

    SgExpression* operand_copy = SageInterface::copyExpression(operand);

    arguments = SageBuilder::buildExprListExp(operand_copy);
  }
  else {
    printf("Unsupported Op\n");
    ROSE_ASSERT(0);
  }

  if(extraArg != NULL) {
      appendExpression(arguments, extraArg);
  }

  SgScopeStatement* scope = getScopeForExp(Op);


  SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(fn_name,
                                                                retType,
                                                                arguments,
                                                                scope);

  createForwardDeclIfNotAvailable(fn_name, retType, arguments, scope, CheckBase::CBProject);

  return NewFunction;
}

// FIXME: In order to generate the sizeof argument properly, it is
// is critical that we know the base type we are refering to --
// or atleast, the offset for the base size. In fact, in order to
// correctly cast any pointer to another, we would need to know the
// exact type, but since we always use VoidStructs, we don't have that
// problem at the moment.
// Since we do not have that base type available to us, at this point
// of time, we need to find a way to atleast get the size of that
// base type, which would be used as a factor when changing the pointer
// size
// For now, we always increment by sizeof(char)
SgExpression* ArithCheck::createSizeOfArg(SgNode* node) {

  // Defaulting to sizeof(int) for now.
  SgExpression* sizeofArg = SageBuilder::buildSizeOfOp(SgTypeInt::createType());


  return sizeofArg;

}

SgVariableSymbol* ArithCheck::findSymbolForVarRef(SgVarRefExp* exp) {

  if(exp == NULL) {
    ROSE_ASSERT(0);
  }

  return exp->get_symbol();
}

SgVariableSymbol* ArithCheck::findInReverseMap(SgVariableSymbol* var_symbol) {


  VariableSymbolMap_t::iterator iter = ArithCheck::ReverseMap.find(var_symbol);
  ROSE_ASSERT(iter != ArithCheck::ReverseMap.end());
  SgVariableSymbol* str_symbol = iter->second;

  return str_symbol;
}

SgInitializedName* ArithCheck::getNameForSymbol(SgVariableSymbol* var_symbol) {

  return var_symbol->get_declaration();
}

std::string ArithCheck::getStringForOp(SgNode* node, SgType* retType) {

  std::string fn_name_String = getStringForVariantT(node->variantT());

  if(retType != NULL) {
    fn_name_String = retType->get_mangled() + "_" + fn_name_String + "_";
  }
  else {
    fn_name_String = fn_name_String + "_";
  }

  if(isSgUnaryOp(node)) {
    SgUnaryOp* uop = isSgUnaryOp(node);

    SgExpression* oper = uop->get_operand();

    fn_name_String = fn_name_String + oper->get_type()->get_mangled();
  }
  else if(isSgBinaryOp(node)) {
    SgBinaryOp* bop = isSgBinaryOp(node);

    SgExpression* lhs_oper = bop->get_lhs_operand();
    SgExpression* rhs_oper = bop->get_rhs_operand();

    fn_name_String = fn_name_String + lhs_oper->get_type()->get_mangled()
                    + "_" + rhs_oper->get_type()->get_mangled();
  }
  else {
    printf("getStringForOp: Unknown op\n");
    ROSE_ASSERT(0);
  }

  return fn_name_String;
}

SgType* ArithCheck::getAddrType() {
  SgType* addr_type = SgTypeUnsignedLongLong::createType();
  return addr_type;
}

SgExpression* ArithCheck::castToAddr(SgExpression* exp) {
  SgExpression* cast_exp = buildCastExp(exp, getAddrType(), SgCastExp::e_reinterpret_cast);
  return cast_exp;
}


SgExpression* ArithCheck::handleNormalVarAddressOfOp(SgAddressOfOp* aop) {

  SgUnaryOp* uop =isSgUnaryOp(aop);

  SgExpression* oper = uop->get_operand();

  ROSE_ASSERT(isSgVarRefExp(oper));

  // We need the address of this variable -- so just copy this op itself!
//  SgExpression* aop_copy = copyExpression(aop);

  SgExpression* aop_copy = createAddressOfOpFor(isSgVarRefExp(copyExpression(oper)));

  // Need to cast it to address type -- and thats our first parameter
  SgExpression* lhs = castToAddr(aop_copy);

  // Second parameter is the sizeof the variable type
  SgExpression* rhs = buildSizeOfOp(oper->get_type());

  // Return type is the struct type of the address of return type
  // create one if necessary
  // We effectively create a struct variable of this type, which
  // will hold the address of this variable. This is similar
  // to a cast in that sense, since we create a struct variable in the
  // overloaded function --- but its unlike a cast function, in
  // that we are providing the limits, explicitly as arguments
  // to the address of function
  // This operand is not of a pointer -- convert it to a pointer
  // before sending it in, since getStructType expects a pointer type
  SgType* retType = getStructType(SgPointerType::createType(oper->get_type()), true);

  SgExpression* overload = buildOverloadFn("AddressOf", lhs, rhs, retType, getScopeForExp(aop));

  return overload;
}

void ArithCheck::handleAddressOfOp(SgAddressOfOp* aop) {

  SgUnaryOp* uop =isSgUnaryOp(aop);

  SgExpression* oper = uop->get_operand();

  if(isSgVarRefExp(oper)) {
    // Its a variable ref exp -- check if its of struct type
    // or its a normal stack variable

    // Of course, it can't be a pointer!
    ROSE_ASSERT(!isSgPointerType(oper->get_type()));

    if(!isValidStructType(oper->get_type())) {
      // If its not a struct type variable, its a normal (global or stack
      // variable
      // Simplest case
      // global or stack variable
      // take its address and size and create an entry. pass that entry back
      // this is a particularly interesting case since we don't know
      // where to create the entry. we'll make up a variable within
      // the overloaded function, and pass that variable and its
      // address back.
      // This is unlike previous cases where the address of the variable
      // is supplied to create_entry

      SgExpression* replacement = handleNormalVarAddressOfOp(aop);
      replaceExpression(aop, replacement);
    }
    else {
      // Its a struct type variable
      // In effect, we are taking the address of a pointer -- creating
      // a double pointer
    }

  }
  else {
    // Taking the address of an arbitrary location --
    // We could detect the metadata for the expression
    // if its struct type, and use it to create a struct
    // which uses the old metadata, and points to the
    // address given by this op
    // i.e. TrackingDB[address given by aop] = TrackingDB[expression's metadata location]
    // but this won't be correct since by taking the address
    // we are no longer bound by the limits placed by
    // previous metadata
    // In effect, this boils down to the problem of double
    // pointers -- or something there of
  }

}

SgExpression* ArithCheck::createBoundsCheckFn(SgInitializedName* str_array_name, SgExpression* index_exp, SgScopeStatement* scope) {

  SgExpression* str_addr = createDotExpFor(str_array_name, "addr");

  SgExpression* fncall = buildOverloadFn("bounds_check", str_addr, index_exp, SgTypeVoid::createType(), scope);

  return fncall;

}

SgExpression* ArithCheck::buildPntrArrRefOverload(SgPntrArrRefExp* array_ref, SgType* retType, SgExpression* new_lhs, SgExpression* new_rhs) {

  printf("buildPntrArrRefExpOverload\n");
  // use the array to find the return type, scope and name
  //SgType* retType = array_ref->get_type();
  //SgType* retType = isSgArrayType(array_type)->get_base_type();

  printf("retType\n");
  printNode(retType);

  // We could use the original expression's types to make up the
  // function name -- we retain the types from the original
  // we simply change the rhs operand to use a var ref, rather
  // than the earlier expression
  SgName fn_name(getStringForOp(array_ref, retType));

  SgScopeStatement* scope = getScopeForExp(array_ref);

  // use the new_lhs and new_rhs as operands
  SgExpression* fncall = buildOverloadFn(fn_name, new_lhs, new_rhs, retType, scope);

  return fncall;
}



void ArithCheck::handlePntrArrRefExp(SgPntrArrRefExp* array_ref) {


  // Get the lhs and rhs operands.
  // lhs should be the array/ptr variable -- so, it should now be a struct
  // variable, and rhs is an expression.
  SgExpression* lhs = isSgBinaryOp(array_ref)->get_lhs_operand();
  SgExpression* rhs = isSgBinaryOp(array_ref)->get_rhs_operand();

  // Assert that the base type on the lhs has been converted to a struct type
  ROSE_ASSERT(isValidStructType(lhs->get_type()));
  // and its refering to an array
  //ROSE_ASSERT(isSgVarRefExp(lhs)); -- It could be the output of a create struct
  // since no longer have references to struct variables, but rather
  // create_struct is called in their place.

  // We don't need to copy the index var since its already being passed into the
  // pntr arr ref overload function...
  #if 0
  SgVariableDeclaration* index_var_decl = pushIndexToLocalVar("index_" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++),
                                rhs,
                                getScopeForExp(array_ref));

  insertStatementBefore(getEnclosingStatement(array_ref), index_var_decl);

  printf("index_var_decl\n");
  printNode(index_var_decl);

  // copy lhs.
  SgExpression* new_lhs = copyExpression(lhs);
  // build rhs
  SgExpression* new_rhs = buildVarRefExp(index_var_decl);
  #endif

  // copy lhs.
  SgExpression* new_lhs = copyExpression(lhs);
  // copy rhs -- since there is only one use of the earlier RHS
  SgExpression* new_rhs = copyExpression(rhs);

  // We have to find the return type... which we can do, by
  // actually finding the underlying type for the struct, and stripping
  // the pointer type in that.
  SgType* ptr_type = getUnderlyingTypeForStruct(lhs->get_type());
  // Now, we have a pointer type -- assert that.
  ROSE_ASSERT(isSgPointerType(ptr_type));
  // This base type is the one that is the returned.
  // Remember that when we create the struct, we do the opposite, we start with the
  // base type, and wrap a pointer around it.
  SgType* base_type = isSgPointerType(ptr_type)->get_base_type();

  SgExpression* new_array_ref = buildPntrArrRefOverload(array_ref, base_type, new_lhs, new_rhs);

  // Now, the bounds check can be done in the pntr_arr_ref_overload function itself... so lets not
  // worry about it for now.

  // Lets replace the array_ref with new_array_ref.
  replaceExpression(array_ref, new_array_ref);

  // new_array_ref->get_type() should be equal to base_type
  ROSE_ASSERT(new_array_ref->get_type()->get_mangled() == base_type->get_mangled());
  if(isQualifyingType(new_array_ref->get_type())) {
    printf("PntrArrRefExp is returning a pointer/array type. Create a struct using addr\n");
    SgExpression* createfn = createStructUsingAddressOf(new_array_ref);
    // Here, we replace new_array_ref with createfn
    replaceExpression(new_array_ref, createfn);
  }

  #if 0
  // Find the original variable for this
  // Find symbol for var_ref operand
  #if 0
  SgVariableSymbol* var_symbol = findSymbolForVarRef(isSgVarRefExp(lhs));

  ROSE_ASSERT(isValidStructType(isSgSymbol(var_symbol)->get_type()));

  SgVariableSymbol* orig_var_symbol = findInReverseMap(var_symbol);

  SgInitializedName* orig_name = getNameForSymbol(orig_var_symbol);

  #endif
  // Now, we have to create a local variable to hold the index var, as we
  // did in the handleArrayVars.
  // That index variable will be used to both do a bounds check, and then
  // in the array ref.
  // It is because of the two uses, that we have to create a local variable.
  SgType* array_type = orig_name->get_type();
  // Now, assert that its of ArrayType
  ROSE_ASSERT(isSgArrayType(array_type));

  SgVariableDeclaration* index_var_decl = pushIndexToLocalVar(orig_name->get_name(), rhs, getScopeForExp(array_ref));

  // Insert this calculate as the previous stmt -- previous stmt because its a variable declaration
  // and can't be in a comma op
  insertStatementBefore(getEnclosingStatement(array_ref), index_var_decl);

  printf("index_var_decl\n");
  printNode(index_var_decl);

  // Now, push index_var ref in place of rhs -- instead of swapping things, we take a slightly different
  // route here.
  // We create a new op -- we anyway remove the current one later, and create a comma op with bounds check

  // copy lhs.
  SgExpression* new_lhs = copyExpression(lhs);
  // build rhs
  SgExpression* new_rhs = buildVarRefExp(index_var_decl);

//  SgPntrArrRefExp* new_array_ref = buildPntrArrRefExp(new_lhs, new_rhs);
  SgExpression* new_array_ref = buildPntrArrRefOverload(array_ref, array_type, new_lhs, new_rhs);

  // Now, for the bounds check function
  // This function only requires the address of the entry, and the current index.
  // It can add the current index to the lower bounds found at TrackingDB[addr].L
  // and do the bounds check.

  SgExpression* bound_check = createBoundsCheckFn(getNameForSymbol(var_symbol), buildVarRefExp(index_var_decl), getScopeForExp(array_ref));

  // lets create a comma op with the new_array_ref and bounds_check.. and
  // replace the original expression with this one.
  // By keeping the array at the rhs, we automatically ensure its the value passed back
  SgCommaOpExp* comma_op = buildCommaOpExp(bound_check, new_array_ref);

  replaceExpression(array_ref, comma_op);

  // If we are returning a pointer/array type from the comma op,
  // we need to take the address, and create a struct from that -- just like deref.
  if(isQualifyingType(comma_op->get_type())) {
    printf("PntrArrRefExp is returning a pointer/array type. Create a struct using addr\n");
    SgExpression* createfn = createStructUsingAddressOf(comma_op);

    replaceExpression(comma_op, createfn);
  }
  #endif
}

void ArithCheck::handleCastExp(SgCastExp* cast_exp) {

    // The Cast exp now has actual meaning... it changes from one struct variable
    // to another...
    // The operand for the cast exp could be of pointer (now Struct) type
    // or other long int type (like NULL). We need to handle the latter as
    // Cast_Value cases

    SgExpression* oper = isSgUnaryOp(cast_exp)->get_operand();

    SgExpression* oper_copy = copyExpression(oper);

    // We might be casting to a type for which we haven't created an
    // entry yet (we create entries when we see variable declarations
    // and parameter lists)

    SgType* retType = getStructType(cast_exp->get_type(), true);
    printf("cast_exp: %s = %s\n", isSgNode(cast_exp->get_type())->sage_class_name(), isSgNode(cast_exp->get_type())->unparseToString().c_str());
    printf("retType: %s = %s\n", isSgNode(retType)->sage_class_name(), isSgNode(retType)->unparseToString().c_str());

    //fn_name_String = retType->get_mangled() + "_" + fn_name_String + "_" + oper_copy->get_type()->get_mangled();

    std::string fn_name_String = getStringForOp(cast_exp, retType);

    if(isSgValueExp(oper)) {
       fn_name_String += "_ValueCast";
    }

    SgName fn_name(fn_name_String);

    // RHS operand is NULL
    SgExpression* overload = buildOverloadFn(fn_name, oper_copy, NULL, retType, getScopeForExp(cast_exp));

    ROSE_ASSERT(overload->get_type() == retType);

    replaceExpression(cast_exp, overload);

}

SgExpression* ArithCheck::updatePointerUsingAddr(SgVarRefExp* var_ref) {

  SgVarRefExp* var_ref_copy = isSgVarRefExp(copyExpression(var_ref));

  ROSE_ASSERT(isValidStructType(var_ref_copy->get_type()));
  // Basically, this function uses the address in the struct, to update
  // the original pointer.

  SgVariableSymbol* var_symbol = var_ref_copy->get_symbol();

  SgExpression* ptr_exp = createDotExpFor(getNameForSymbol(var_symbol), "ptr");

  SgExpression* addr_exp = createDotExpFor(getNameForSymbol(var_symbol), "addr");
  // Cast the addr to the correct type -- i.e pointer of the ptr type
  SgExpression* addr_dbl_ptr_exp = buildCastExp(addr_exp, SgPointerType::createType(ptr_exp->get_type()), SgCastExp::e_reinterpret_cast);


  // First deref the addr
  SgExpression* deref_exp = buildPointerDerefExp(addr_dbl_ptr_exp);
  //SgExpression* casted_addr = buildCastExp(addr_exp, getUnderlyingTypeForStruct(var_ref->get_type()), SgCastExp::e_C_style_cast);
  SgExpression* casted_addr = buildCastExp(deref_exp, getUnderlyingTypeForStruct(var_ref->get_type()), SgCastExp::e_C_style_cast);



  SgExpression* update = buildAssignOp(casted_addr, ptr_exp);

  return update;

}

void ArithCheck::handleOverloadOps(SgNode* node) {
  // The operations listed here would be
  //AddOp:
  //SubtractOp:
  //PlusPlusOp:
  //MinusMinusOp:
  //CastExp:
  //AssignOp:
  //PlusAssignOp:
  //MinusAssignOp:

  // For add and subtract ops, replace operation with overload functions

  // For plusplus and minusminus op, replace operation with overload functions
  // and update the original ptr

  // For cast exp, if the return type is not pointer type, insert a
  // deref overload with a cast to the required type.
  // If the return type is pointer type, overload with Cast_Overload

  // For assign op, replace operation with overload functions and
  // update the original ptr


  // We could update the add/subtract as well, so that we handle
  // add, subtract, plusplus, minusminus and assign in the same
  // fashion -- but this is too much work when it comes to add
  // and subtract, since a new variable would need to be created
  // instead, we'll only update for assign, plusplus and minusminus
  // -- where its absolutely required

  // Add, subtract, plusplus, minusminus, assign
  if(ArithOrAssignOp(node)) {



    #if 0
    SgType* retType = getStructType(getVoidPointerType());
    #endif
    // Return type is that given by the op itself since we
    // have different structs for different types
    SgType* retType = isSgExpression(node)->get_type();

    SgName fn_name(getStringForOp(node, retType));

    SgExpression* overload;
    SgExpression* sizeofArg = NULL;

    // SizeofArg is not required since we always work
    // with the correct type of pointers --
    #if 0
    if(!isSgAssignOp(node)) {
      sizeofArg = createSizeOfArg(node);
    }
    #endif

    //overload = buildOverloadFnForOp(fn_name, isSgExpression(node), retType, sizeofArg);

    // If its a plusplus, or minusminus -- update the pointer
    // If the underlying operand is a var-ref, then we should find the original
    // pointer, and use updatePointer --- and then, return the struct --
    if(ArithOpWithSelfUpdate(node)) {
//    if(isSgPlusPlusOp(node) || isSgMinusMinusOp(node) || isSgAssignOp(node)) {


      //overload = buildOverloadFnForOp(fn_name, isSgExpression(node), retType, sizeofArg);

      SgExpression* oper;
      SgExpression* lhs_copy;
      SgExpression* rhs_copy;

//      if(isSgPlusPlusOp(node) || isSgMinusMinusOp(node)) {
      if(isSgUnaryOp(node)) {

        SgUnaryOp* uop = isSgUnaryOp(node);

        oper = uop->get_operand();

        lhs_copy = copyExpression(oper);

        rhs_copy = NULL;

      }
      else {
        //ROSE_ASSERT(isSgAssignOp(node));

        SgBinaryOp* bop = isSgBinaryOp(node);

        oper = bop->get_lhs_operand();

        lhs_copy = copyExpression(oper);

        rhs_copy = copyExpression(bop->get_rhs_operand());
      }

      // build an overload fn which handles the operation.... take the
      // address of the lhs so that the update happens to the struct
      // without making a copy in the callee.

      ROSE_ASSERT(isValidStructType(oper->get_type()));

      if(!isSgVarRefExp(oper)) {
        // create a local variable of the same type as the operand
        // Generate name using type and counter
        SgName s_name(oper->get_type()->get_mangled() + "_ovl_" + boost::lexical_cast<std::string>(ArithCheck::VarCounter++));

        SgVariableDeclaration* local_var_decl = createLocalVariable(s_name, oper->get_type(), NULL, getScopeForExp(isSgExpression(node)));

        insertStatementBefore(getEnclosingStatement(node), local_var_decl);
        //getScopeForExp(isSgExpression(node))->insertStatementInScope(local_var_decl, true);


        SgVarRefExp* local_var_ref = buildVarRefExp(local_var_decl);

        // assign oper to local variable
        SgExpression* local_var_assign = buildAssignOp(local_var_ref, lhs_copy);

        // Now, we should insert this prior to the overloaded fn... and use
        // the local in the overloaded fn..

        SgExpression* local_var_addr =  castToAddr(createAddressOfOpFor(copyExpression(local_var_ref)));

        overload = buildOverloadFn(fn_name, local_var_addr, rhs_copy, retType, getScopeForExp(isSgExpression(node)));

        // build a comma op with local_var_assign and local_var_overload
        SgExpression* assign_over = buildCommaOpExp(local_var_assign, overload);

        // Now, we update the original variable's value. For that, since we don't maintain the
        // reverse map anymore... we will use the address of the variable itself!
        SgExpression* update_exp = updatePointerUsingAddr(local_var_ref);

        // build a comma op with assign_over and update
        SgExpression* assign_over_update = buildCommaOpExp(assign_over, update_exp);

        // Now, create a copy of local_var_ref and add it as the last one
        SgExpression* assign_over_update_local = buildCommaOpExp(assign_over_update, copyExpression(local_var_ref));

        printf("assign_over_update_local -- the final one in handleOverloadOps\n");
        printNode(assign_over_update_local);

        // Now, replace the original expression, with this one.
        replaceExpression(isSgExpression(node), assign_over_update_local);

      }
      else {


        SgExpression* lhs_addr = castToAddr(createAddressOfOpFor(lhs_copy));

        overload = buildOverloadFn(fn_name, lhs_addr, rhs_copy, retType, getScopeForExp(isSgExpression(node)));

        // Now, we update the original variable's value. For that, since we don't maintain the
        // reverse map anymore... we will use the address of the variable itself!
        SgExpression* update_exp = updatePointerUsingAddr(isSgVarRefExp(lhs_copy));

        // build a comma op with both these exps
        SgCommaOpExp* over_update = buildCommaOpExp(overload, update_exp);

        // And of course, put the struct as the last
        // Assuming here that the lhs is a variable.
        SgExpression* lhs_struct = copyExpression(lhs_copy);

        SgCommaOpExp* over_update_lhs = buildCommaOpExp(over_update, lhs_struct);

        replaceExpression(isSgExpression(node), over_update_lhs);
      }


      #if 0

      if(isSgVarRefExp(oper)) {

        // A variable is being updated here -- so, we need to send the address of the lhs -- the variable being
        // updated by this operation
        // Also, we return a variable with the updated data -- by value -- as normal semantics dictate

        SgExpression* lhs_addr = createAddressOfOpFor(isSgVarRefExp(lhs_copy));

        overload = buildOverloadFn(fn_name, lhs_addr, rhs_copy, retType, getScopeForExp(isSgExpression(node)));

        // This is a variable reference... do an update pointer

        // Find symbol for var_ref operand
        SgVariableSymbol* var_symbol = findSymbolForVarRef(isSgVarRefExp(oper));

        // This doesn't hold true anymore... instead, we could check that the type of the
        // var_symbol is of struct type
        //ROSE_ASSERT(isSgSymbol(var_symbol)->get_type() == getStructType(getVoidPointerType()));
        ROSE_ASSERT(isValidStructType(isSgSymbol(var_symbol)->get_type()));


        SgVariableSymbol* orig_var_symbol = findInReverseMap(var_symbol);

        SgExpression* update_exp = updatePointer(getNameForSymbol(orig_var_symbol), getNameForSymbol(var_symbol));

        SgCommaOpExp* over_update = buildCommaOpExp(overload, update_exp);

        // We need to return the struct -- not the pointer -- so, add the struct as a single
        // var ref expression, to the end of the comma op.

        SgVarRefExp* var_ref = buildVarRefExp(var_symbol);

        SgCommaOpExp* over_update_var = buildCommaOpExp(over_update, var_ref);

        replaceExpression(isSgExpression(node), over_update_var);
      }
      else {
        // Since its not a variable reference, no one pointer is begin affected
        // Its more of a change in value...
        // we treat this as a simple plus/minus - insert overload fn and replace expression
        overload = buildOverloadFnForOp(fn_name, isSgExpression(node), retType, sizeofArg);
        replaceExpression(isSgExpression(node), overload);
      }
      #endif

    }
    else {
      // For add/subtract, no need to send in the address
      overload = buildOverloadFnForOp(fn_name, isSgExpression(node), retType, sizeofArg);
      replaceExpression(isSgExpression(node), overload);
    }

  }
  #if 0
  else if(isSgCastExp(node)){


    // The Cast exp now has actual meaning... it changes from one struct variable
    // to another...
    // The operand for the cast exp could be of pointer (now Struct) type
    // or other long int type (like NULL). We need to handle the latter as
    // Cast_Value cases

    SgCastExp* cast_exp = isSgCastExp(node);

    SgExpression* oper = isSgUnaryOp(cast_exp)->get_operand();

    SgExpression* oper_copy = copyExpression(oper);

    #if 0
    std::string fn_name_String;

    if(isSgValueExp(oper)) {
       fn_name_String = "Cast_Value";
    }
    else {
      fn_name_String = getStringForVariantT(node->variantT());
    }
    #endif

    // Return type is now struct of the original return type
    #if 0
    SgType* retType = getStructType(getVoidPointerType());
    #endif
    // We might be casting to a type for which we haven't created an
    // entry yet (we create entries when we see variable declarations
    // and parameter lists)

    SgType* retType = getStructType(cast_exp->get_type(), true);
    printf("cast_exp: %s = %s\n", isSgNode(cast_exp->get_type())->sage_class_name(), isSgNode(cast_exp->get_type())->unparseToString().c_str());
    printf("retType: %s = %s\n", isSgNode(retType)->sage_class_name(), isSgNode(retType)->unparseToString().c_str());

    //fn_name_String = retType->get_mangled() + "_" + fn_name_String + "_" + oper_copy->get_type()->get_mangled();

    std::string fn_name_String = getStringForOp(node, retType);

    if(isSgValueExp(oper)) {
       fn_name_String += "_ValueCast";
    }

    SgName fn_name(fn_name_String);

    // RHS operand is NULL
    SgExpression* overload = buildOverloadFn(fn_name, oper_copy, NULL, retType, getScopeForExp(cast_exp));

    ROSE_ASSERT(overload->get_type() == retType);

    replaceExpression(isSgCastExp(node), overload);

  }
  else if(isSgAddressOfOp(node)) {
    handleAddressOfOp(isSgAddressOfOp(node));
  }
  else if(isSgPntrArrRefExp(node)) {
    handlePntrArrRefExp(isSgPntrArrRefExp(node));
    printNode(node);
  }
  #endif
  else {
    printf("handleOverloadOps:What else?\n");
    ROSE_ASSERT(0);
  }

}

SgScopeStatement* ArithCheck::getScopeThruParent(SgNode* node) {
  if(node->get_parent() != NULL) {
    SgNode* parent = node->get_parent();
    printNode(parent);
    if(isSgScopeStatement(parent)) {
      return isSgScopeStatement(parent);
    }
    else {
      return getScopeThruParent(parent);
    }
  }
  else {
    return NULL;
  }
}

SgScopeStatement* ArithCheck::getScopeForVarRef(SgVarRefExp* var_ref) {

  SgVariableSymbol* var_symbol = var_ref->get_symbol();
  SgInitializedName* init_name = getNameForSymbol(var_symbol);
  return init_name->get_scope();
}


void ArithCheck::handlePointerVarRefs(SgVarRefExp* var_ref) {

  printf("handlePointerVarRefs\n");
  // Here, we call create_struct function, which will
  // create a struct variable using the pointer value
  // and the pointer variable's address
  // Any initialization data for this pointer would already be
  // in the TrackingDB if this pointer was initialized.

  ROSE_ASSERT(isSgPointerType(var_ref->get_type()));

  SgExpression* ptr_value = copyExpression(var_ref);
  SgExpression* addr_ptr = castToAddr(createAddressOfOpFor(copyExpression(var_ref)));

  // We will be returning a struct variable based on the type
  // of this variable.
  // The struct might need to be created
  SgType* retType = getStructType(var_ref->get_type(), true);
  printf("getScopeForExp:var_ref\n");
  printNode(var_ref);

//  SgScopeStatement* scope = getScopeForExp(var_ref);
//  SgScopeStatement* scope = getScopeThruParent(isSgNode(var_ref));
  SgScopeStatement* scope = getScopeForVarRef(var_ref);
  printf("Got scope:\n");
  printNode(scope);

  SgExpression* createfn = buildOverloadFn("create_struct", ptr_value, addr_ptr, retType, scope);
  printf("createfn\n");
  printNode(createfn);

  replaceExpression(var_ref, createfn);

  // OLD STUFF
  #if 0
  // For now, we use the handleVarRefs to do pointer var refs
  handleVarRefs(var_ref);
  #endif
}

SgExpression* ArithCheck::getArrayIndex(SgExpression* exp) {

  SgType* exp_type = exp->get_type();
  SgArrayType* exp_arr_type = isSgArrayType(exp_type);
  return exp_arr_type->get_index();
}

SgType* ArithCheck::getArrayBaseType(SgExpression* exp) {

  SgType* exp_type = exp->get_type();
  SgArrayType* exp_arr_type = isSgArrayType(exp_type);
  return exp_arr_type->get_base_type();
}

void ArithCheck::handleArrayVarRefs(SgVarRefExp* var_ref) {

  // Here, we call create_struct function, which will
  // create a struct variable using the array's base
  // address, its index (size of the array from the ArrayType)
  // and the array variable's address.
  // the size of the array is required because this would
  // be inserted into the TrackingDB if an entry doesn't exist
  // for the array.

  ROSE_ASSERT(isSgArrayType(var_ref->get_type()));

  SgExpression* array_value = copyExpression(var_ref);
  SgExpression* addr_array = castToAddr(createAddressOfOpFor(copyExpression(var_ref)));
  SgExpression* array_index = copyExpression(getArrayIndex(var_ref));

  // We get the base type of the array... and then, get a pointer
  // version of that... and create a struct of that type.
  // Change here is that we are converting that this array type... into an
  // equivalent pointer type
  SgType* retType = getStructType(SgPointerType::createType(getArrayBaseType(var_ref)), true);

  SgScopeStatement* scope = getScopeForExp(var_ref);

  SgExpression* createfn = build3ArgOverloadFn("create_struct", array_value, addr_array, array_index, retType, scope);

  replaceExpression(var_ref, createfn);

  // OLD STUFF
  #if 0
  // For now, we use the handleVarRefs to do array var refs
  handleVarRefs(var_ref);
  #endif
}

void ArithCheck::handlePointerDeref(SgPointerDerefExp* deref_exp) {
  handleDerefExp(deref_exp);
}

void ArithCheck::handleArrayDeref(SgPointerDerefExp* deref_exp) {
  // For now, we use handleDerefExp to handle array derefs
  // handleDerefExp returns the underlying type
  handleDerefExp(deref_exp);
}

void ArithCheck::handlePointerArrRefs(SgPntrArrRefExp* pntr_arr_ref) {
  // Using handlePntrArrRefExp on pointers as well as array types
  // since the operation is similar on both variables
  handlePntrArrRefExp(pntr_arr_ref);
}

void ArithCheck::handleArrayArrRefs(SgPntrArrRefExp* pntr_arr_ref) {
  handlePntrArrRefExp(pntr_arr_ref);
}

void ArithCheck::handlePointerDotExp(SgDotExp* dot_exp) {
}

void ArithCheck::handleArrayDotExp(SgDotExp* dot_exp) {
}

void ArithCheck::handlePointerArrowExp(SgArrowExp* arrow_exp) {
}

void ArithCheck::handleArrayArrowExp(SgArrowExp* arrow_exp) {
}

void ArithCheck::handlePointerCastExp(SgCastExp* cast_exp) {
  // Cast expressions typically go from one struct to another
  // or one value to a struct, or vice versa.
  // This behavior is regardless of whether
  // its a pointer/array type
  handleCastExp(cast_exp);
}

void ArithCheck::handleArrayCastExp(SgCastExp* cast_exp) {
  handleCastExp(cast_exp);
}

void ArithCheck::handlePointerAddrOfOp(SgAddressOfOp* addr_of) {
  // FIXME: Not checking whether the address of op exactly
  // fits in here well...
  handleAddressOfOp(addr_of);
}

void ArithCheck::handleArrayAddrOfOp(SgAddressOfOp* addr_of) {
  // FIXME: Not checking whether the address of op exactly
  // fits in here well...
  handleAddressOfOp(addr_of);

}




void ArithCheck::handleVarDecls4(SgVariableDeclaration* var_decl) {

  SgInitializedName* var_name = getNameForDecl(var_decl);

  if(isSgPointerType(var_name->get_type())) {
    printf("variable is a pointer\n");
    handlePointerVars(var_decl);
  }
  else if(isSgArrayType(var_name->get_type())) {
    printf("variable is an array\n");

    handleArrayVars(var_decl);
  }
  else {
    printf("What is this variable decl doing here?\n");
    printNode(var_decl);
    ROSE_ASSERT(0);
  }
}

void ArithCheck::handleVarRefs4(SgVarRefExp* var_ref) {
  // FIXME: Skip cases where parent is
  // arrow or dot exp... and this is the rhs!
  if(isSgPointerType(var_ref->get_type())) {
    handlePointerVarRefs(var_ref);
  }
  else if(isSgArrayType(var_ref->get_type())) {
    handleArrayVarRefs(var_ref);
  }
  else {
    printf("What is this var ref doing here?\n");
    printNode(var_ref);
    ROSE_ASSERT(0);
  }


}

void ArithCheck::handleFuncCalls4(SgFunctionCallExp* fncall) {

  if(isSgPointerType(fncall->get_type())) {
    handleFuncCalls(fncall);
  }
  else if(isSgArrayType(fncall->get_type())) {
    printf("Function call returning array type. No handle for this case\n");
    printNode(fncall);
    ROSE_ASSERT(0);
  }
  else {
    printf("What is this var ref doing here?\n");
    printNode(fncall);
    ROSE_ASSERT(0);
  }


}

void ArithCheck::handleDerefs4(SgPointerDerefExp* deref_exp) {

  // We will always see the type to be class type...
  // since the var ref would be changed to struct.
  #if 0
  if(isSgPointerType(deref_exp->get_type())) {
    handlePointerDeref(deref_exp);
  }
  else if(isSgArrayType(deref_exp->get_type())) {
    handleArrayDeref(deref_exp);
  }
  #endif
  if(isSgClassType(deref_exp->get_operand()->get_type())) {
    handleDerefExp(deref_exp);
  }
  else {
    printf("What is this deref?\n");
    printNode(deref_exp);
    ROSE_ASSERT(0);
  }

}

void ArithCheck::handlePntrArrRefs4(SgPntrArrRefExp* pntr_arr_ref) {

  // We will always see the type to be class type...
  // since the var ref would be changed to struct.

  #if 0
  if(isSgPointerType(pntr_arr_ref->get_type())) {
    handlePointerArrRefs(pntr_arr_ref);
  }
  else if(isSgArrayType(pntr_arr_ref->get_type())) {
    handleArrayArrRefs(pntr_arr_ref);
  }
  #endif
  if(isSgClassType(pntr_arr_ref->get_type())) {
    handlePntrArrRefExp(pntr_arr_ref);
  }
  else {
    printf("What is this pntr arr ref?");
    printNode(pntr_arr_ref);
    ROSE_ASSERT(0);
  }
}

void ArithCheck::handleDotExp4(SgDotExp* dot_exp) {

  // We will always see the type to be class type...
  // since the var ref would be changed to struct.
  // FIXME: This is not correct, I think.
  //
  if(isSgPointerType(dot_exp->get_type())) {
    handlePointerDotExp(dot_exp);
  }
  else if(isSgArrayType(dot_exp->get_type())) {
    handleArrayDotExp(dot_exp);
  }
  else {
    printf("What is this dot exp?");
    printNode(dot_exp);
    ROSE_ASSERT(0);
  }

}

void ArithCheck::handleArrowExp4(SgArrowExp* arrow_exp) {

  // We will always see the type to be class type...
  // since the var ref would be changed to struct.
  // FIXME: This is not correct, I think.
  if(isSgPointerType(arrow_exp->get_type())) {
    handlePointerArrowExp(arrow_exp);
  }
  else if(isSgArrayType(arrow_exp->get_type())) {
    handleArrayArrowExp(arrow_exp);
  }
  else {
    printf("What is this arrow exp?");
    printNode(arrow_exp);
    ROSE_ASSERT(0);
  }
}

void ArithCheck::handleCastExp4(SgCastExp* cast_exp) {

  // We will always see the type to be class type...
  // since the var ref would be changed to struct.
  // FIXME: This could be a value as well... Handle
  // that case

  if(isSgPointerType(cast_exp->get_type())) {
    handlePointerCastExp(cast_exp);
  }
  else if(isSgArrayType(cast_exp->get_type())) {
    handleArrayCastExp(cast_exp);
  }
  else {
    printf("What is this cast exp?");
    printNode(cast_exp);
    ROSE_ASSERT(0);
  }
}

void ArithCheck::handleAddressOfOp4(SgAddressOfOp* addr_of) {

  // We will always see the type to be class type...
  // since the var ref would be changed to struct.
  // FIXME: This could be address of stack variable... not handled
  // here... !

  if(isSgPointerType(addr_of->get_type())) {
    handlePointerAddrOfOp(addr_of);
  }
  else if(isSgArrayType(addr_of->get_type())) {
    handleArrayAddrOfOp(addr_of);
  }
  else {
    printf("What is this addr of op?");
    printNode(addr_of);
    ROSE_ASSERT(0);
  }
}


void ArithCheck::InstrumentNodes4(SgProject* project) {

  printf("InstrumentNodes4 - begin\n");
  for(NodeContainer::iterator nit = ArithCheck::NodesToInstrument.begin(); nit != ArithCheck::NodesToInstrument.end(); ++nit) {

    SgNode* node = *nit;
    Sg_File_Info* File = isSgNode(node)->get_file_info();
    printf("Current: %s = %s\n", node->sage_class_name(), node->unparseToString().c_str());
    printf("File: (%s, %d, %d) %s = %s\n", File->get_filenameString().c_str(),
                      File->get_line(),
                      File->get_col(),
                      isSgNode(node)->sage_class_name(),
                      isSgNode(node)->unparseToString().c_str());

    printf("is variable declaration?");
    if(isSgVariableDeclaration(node)) {
      printf("Yes\n");
      handleVarDecls4(isSgVariableDeclaration(node));
    }
    else {
      printf("No\n");
    }

    printf("is variable reference?");
    if(isSgVarRefExp(node)) {
      printf("Yes\n");
      handleVarRefs4(isSgVarRefExp(node));
    }
    else {
      printf("No\n");
    }

    printf("is func call?");
    if(isSgFunctionCallExp(node)) {
      printf("Yes\n");
      handleFuncCalls4(isSgFunctionCallExp(node));
    }
    else {
      printf("No\n");
    }

    printf("is deref exp?");
    if(isSgPointerDerefExp(node)) {
      printf("Yes\n");
      handleDerefs4(isSgPointerDerefExp(node));
    }
    else {
      printf("No\n");
    }

    printf("is pntr arr ref?");
    if(isSgPntrArrRefExp(node)) {
      printf("Yes\n");
      handlePntrArrRefs4(isSgPntrArrRefExp(node));
    }
    else {
      printf("No\n");
    }

    printf("is dot exp?");
    if(isSgDotExp(node)) {
      printf("Yes\n");
      handleDotExp4(isSgDotExp(node));
    }
    else {
      printf("No\n");
    }

    printf("is arrow exp?");
    if(isSgArrowExp(node)) {
      printf("Yes\n");
      handleArrowExp4(isSgArrowExp(node));
    }
    else {
      printf("No\n");
    }

    printf("is cast exp?");
    if(isSgCastExp(node)) {
      printf("Yes\n");
      handleCastExp4(isSgCastExp(node));
    }
    else {
      printf("No\n");
    }

    printf("is address of exp?");
    if(isSgAddressOfOp(node)) {
      printf("Yes\n");
      handleAddressOfOp4(isSgAddressOfOp(node));
    }
    else {
      printf("No\n");
    }

    printf("is comma op?");
    if(isSgCommaOpExp(node)) {
      printf("Yes\n");
      printf("Nothing to do.\n");
    }
    else {
      printf("No\n");
    }

    // Conditional ops return bool... and its
    // a simple overload -- irrespective of whether
    // its a pointer or array type -- just use the
    // struct available
    printf("is conditional op?");
    if(isConditionalOp(node)) {
      printf("Yes\n");
      handleConditionals(isSgBinaryOp(node));
    }
    else {
      printf("No\n");
    }

    // if the return type is of qualifying type..
    // change it to struct type... works the same for
    // pointers and arrays.
    printf("is function decl?");
    if(isSgFunctionDeclaration(node)) {
      printf("Yes\n");
      handleFuncDecls(isSgFunctionDeclaration(node));
    }
    else {
      printf("No\n");
    }

    // We will modify handleFuncParams to handle pointers
    // and arrays differently. No need to create different
    // calls at the top level.
    printf("is param list?");
    if(isSgFunctionParameterList(node)) {
      printf("Yes\n");
      handleFuncParams(isSgFunctionParameterList(node));
    }
    else {
      printf("No\n");
    }

    // Changed needs to be overloaded to check for arith ops
    // only -- so this would be used to handle those ops which
    // don't change the type of pointer/array, or create
    // a pointer/array type
    // they simply
    // perform arithmetic operations on the given type.
    // should work the same for both pointer and array types
    printf("is it an overloadable op?");
    if(NeedsToBeOverloaded(node)) {
      printf("Yes\n");
      handleOverloadOps(node);
    }
    else {
      printf("No\n");
    }

    // Casts from those expressions which output VoidStr should be removed -- or we could simply
    // put a Cast_Overload. Removing an expression might require clean up. Putting a Cast_Overload for
    // now would be a good idea.

  }
  printf("InstrumentNodes4 - end\n");

}

void ArithCheck::HackyPtrCheck7() {

  printf("HackyPtrCheck7\n");

  SgProject* project = CheckBase::CBProject;

  // This will remove all the original expression trees -
  // generated through constant propagation/folding
  SageInterface::removeAllOriginalExpressionTrees(isSgNode(project));

  TopBotTrack2 TB2;
  nodeType inhAttr(UNKNOWN, INH_UNKNOWN);
  TB2.traverseInputFiles(project, inhAttr);

  //createTrackingStruct(project);

  InstrumentNodes4(project);
}

void ArithCheck::insertPreamble() {

  insertLibHeader();

  //HackyPtrCheck4();
  //HackyPtrCheck5();
  //HackyPtrCheck6();
  HackyPtrCheck7();

  insertTimingSupport(CheckBase::CBProject);

}

void ArithCheck::instrument() {

    insertPreamble();

    // FIXME: Removed actual overflow checks to test pointer checking
    #if 0
  for(BopContainer::iterator bpit = SelectedBops.begin(); bpit != SelectedBops.end();
      ++bpit) {

    SgBinaryOp* Bop = *bpit;
    instrument(Bop);
  }
  #endif
}






bool checkDontInstrumentList(SgBinaryOp* Parent, SgExpression* LHS, SgExpression* RHS) {

  // Unsigned Subtract Ops - cannot overflow
  if(Parent->variantT() == V_SgSubtractOp &&
    (LHS->get_type()->isUnsignedType() || RHS->get_type()->isUnsignedType())) {
    return true;
  }
  // Pointer Types are not currently handled - Return type or Op types shouldn't be pointer types
  else if((Parent->get_type()->variantT() == V_SgPointerType) ||
    (LHS->get_type()->variantT() == V_SgPointerType) ||
    (RHS->get_type()->variantT() == V_SgPointerType)) {
    return true;
  }
  // Array Types are not currently handled - Return type or Op types shouldn't be array types
  else if((Parent->get_type()->variantT() == V_SgArrayType) ||
    (LHS->get_type()->variantT() == V_SgArrayType) ||
    (RHS->get_type()->variantT() == V_SgArrayType)) {
    return true;
  }

  // We can handle all other cases
  return false;

}

void ArithCheck::instrument(SgBinaryOp* bop) {

    printf("insertArithCheck\n");

    printf("bop: %lu\n", &(*bop));

    // Seg faulting here. Possibly due to the fact that the bop
    // has been "removed" somehow... --- can't seem to get a
    // read on it

    SgExpression* LHS = bop->get_lhs_operand();
    SgExpression* RHS = bop->get_rhs_operand();


    printf("LHS: %lu\n", &(*LHS));
  printf("RHS: %lu\n", &(*RHS));



    if(checkDontInstrumentList(bop, LHS, RHS)) {
        printf("Part of dontInstrumentList\n");
        return;
    }

    printInfo(bop, LHS, RHS);

    SgStatement* stmt = getSurroundingStatement(*isSgExpression(bop));
    SgScopeStatement* scope = stmt->get_scope();

    ROSE_ASSERT(scope);

    SgExpression* LHS_Copy = copyExpression(LHS);
    SgExpression* RHS_Copy = copyExpression(RHS);

    SgType* LHSTy = resolveTypedefsAndReferencesToBaseTypes(LHS->get_type());
    SgType* RHSTy = resolveTypedefsAndReferencesToBaseTypes(RHS->get_type());
    SgType* ParTy = resolveTypedefsAndReferencesToBaseTypes(bop->get_type());

    VariantT ParV = bop->variantT();
    VariantT ParV_Ty = ParTy->variantT();
    VariantT LHSV = LHSTy->variantT();
    VariantT RHSV = RHSTy->variantT();

    ROSE_ASSERT(LHSV != V_SgTypedefType);
    ROSE_ASSERT(RHSV != V_SgTypedefType);

    char* FnName = getString(ParV_Ty, ParV, LHSV, RHSV);

    SgName s_name(FnName);
    SgExprListExp* parameter_list = buildExprListExp();

    appendExpression(parameter_list, LHS_Copy);
    appendExpression(parameter_list, RHS_Copy);

    SgExpression* NewFunction = SageBuilder::buildFunctionCallExp(s_name,
                                                                bop->get_type(),
                                                                parameter_list,
                                                                scope);

    replaceExpression(bop, NewFunction);


}


void ArithCheck::instrument(SgNode* Node) {
  printf("ArithCheck:process\n");
  if(isSgBinaryOp(Node)) {
    instrument(isSgBinaryOp(Node));
    }
}



#endif
